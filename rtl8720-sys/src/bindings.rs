/* automatically generated by rust-bindgen 0.57.0 */

pub const RTW_NOTCH_FILTER: u8 = 0;
pub const RTW_ADAPTIVITY_EN_DISABLE: u8 = 0;
pub const RTW_ADAPTIVITY_EN_ENABLE: u8 = 1;
pub const RTW_ADAPTIVITY_MODE_NORMAL: u8 = 0;
pub const RTW_ADAPTIVITY_MODE_CARRIER_SENSE: u8 = 1;
pub const DISABLE: u8 = 0;
pub const RTW_RX_HANDLED: u8 = 2;
pub const RTW_RFRAME_UNAVAIL: u8 = 3;
pub const RTW_RFRAME_PKT_UNAVAIL: u8 = 4;
pub const RTW_RBUF_UNAVAIL: u8 = 5;
pub const RTW_RBUF_PKT_UNAVAIL: u8 = 6;
pub const RTW_SDIO_READ_PORT_FAIL: u8 = 7;
pub const RTW_MAX_DELAY: u32 = 4294967295;
pub const RTW_WAIT_FOREVER: u32 = 4294967295;
pub const RTW_MAX_PSK_LEN: u8 = 64;
pub const RTW_MIN_PSK_LEN: u8 = 8;
pub type __uint8_t = crate::ctypes::c_uchar;
pub type __uint16_t = crate::ctypes::c_ushort;
pub type __uint32_t = crate::ctypes::c_uint;
pub type __uint64_t = crate::ctypes::c_ulong;
extern "C" {
    pub fn initstate(
        arg1: crate::ctypes::c_uint,
        arg2: *mut crate::ctypes::c_char,
        arg3: usize,
    ) -> *mut crate::ctypes::c_char;
}
pub type BOOLEAN = crate::ctypes::c_uchar;
pub const SHA2_NONE: _SHA2_TYPE_ = 0;
pub const SHA2_224: _SHA2_TYPE_ = 28;
pub const SHA2_256: _SHA2_TYPE_ = 32;
pub const SHA2_384: _SHA2_TYPE_ = 48;
pub const SHA2_512: _SHA2_TYPE_ = 64;
pub type _SHA2_TYPE_ = crate::ctypes::c_uint;
pub use self::_SHA2_TYPE_ as SHA2_TYPE;
extern "C" {
    pub fn rtl_crypto_md5(
        message: *const u8,
        msglen: u32,
        pDigest: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_md5_init() -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_md5_process(
        message: *const u8,
        msglen: u32,
        pDigest: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_md5_update(message: *const u8, msglen: u32) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_md5_final(pDigest: *mut u8) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_sha1(
        message: *const u8,
        msglen: u32,
        pDigest: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_sha1_init() -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_sha1_process(
        message: *const u8,
        msglen: u32,
        pDigest: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_sha1_update(message: *const u8, msglen: u32) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_sha1_final(pDigest: *mut u8) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_sha2(
        sha2type: SHA2_TYPE,
        message: *const u8,
        msglen: u32,
        pDigest: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_sha2_init(sha2type: SHA2_TYPE) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_sha2_process(
        message: *const u8,
        msglen: u32,
        pDigest: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_sha2_update(message: *const u8, msglen: u32) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_sha2_final(pDigest: *mut u8) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_hmac_md5(
        message: *const u8,
        msglen: u32,
        key: *const u8,
        keylen: u32,
        pDigest: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_hmac_md5_init(key: *const u8, keylen: u32) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_hmac_md5_process(
        message: *const u8,
        msglen: u32,
        pDigest: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_hmac_md5_update(message: *const u8, msglen: u32) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_hmac_md5_final(pDigest: *mut u8) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_hmac_sha1(
        message: *const u8,
        msglen: u32,
        key: *const u8,
        keylen: u32,
        pDigest: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_hmac_sha1_start(key: *const u8, keylen: u32) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_hmac_sha1_init(key: *const u8, keylen: u32) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_hmac_sha1_process(
        message: *const u8,
        msglen: u32,
        pDigest: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_hmac_sha1_update(message: *const u8, msglen: u32) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_hmac_sha1_final(pDigest: *mut u8) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_hmac_sha2(
        sha2type: SHA2_TYPE,
        message: *const u8,
        msglen: u32,
        key: *const u8,
        keylen: u32,
        pDigest: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_hmac_sha2_start(key: *const u8, keylen: u32) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_hmac_sha2_init(
        sha2type: SHA2_TYPE,
        key: *const u8,
        keylen: u32,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_hmac_sha2_process(
        message: *const u8,
        msglen: u32,
        pDigest: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_hmac_sha2_update(message: *const u8, msglen: u32) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_hmac_sha2_final(pDigest: *mut u8) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_aes_cbc_init(key: *const u8, keylen: u32) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_aes_cbc_encrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_aes_cbc_decrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_aes_ecb_init(key: *const u8, keylen: u32) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_aes_ecb_encrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_aes_ecb_decrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_aes_ctr_init(key: *const u8, keylen: u32) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_aes_ctr_encrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_aes_ctr_decrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_aes_cfb_init(key: *const u8, keylen: u32) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_aes_cfb_encrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_aes_cfb_decrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_aes_ofb_init(key: *const u8, keylen: u32) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_aes_ofb_encrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_aes_ofb_decrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_aes_gcm_init(key: *const u8, keylen: u32) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_aes_gcm_encrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        aad: *const u8,
        aadlen: u32,
        pResult: *mut u8,
        pTag: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_aes_gcm_decrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        aad: *const u8,
        aadlen: u32,
        pResult: *mut u8,
        pTag: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_3des_cbc_init(key: *const u8, keylen: u32) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_3des_cbc_encrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_3des_cbc_decrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_3des_ecb_init(key: *const u8, keylen: u32) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_3des_ecb_encrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_3des_ecb_decrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_3des_ctr_init(key: *const u8, keylen: u32) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_3des_ctr_encrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_3des_ctr_decrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_3des_cfb_init(key: *const u8, keylen: u32) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_3des_cfb_encrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_3des_cfb_decrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_3des_ofb_init(key: *const u8, keylen: u32) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_3des_ofb_encrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_3des_ofb_decrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_des_cbc_init(key: *const u8, keylen: u32) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_des_cbc_encrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_des_cbc_decrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_des_ecb_init(key: *const u8, keylen: u32) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_des_ecb_encrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_des_ecb_decrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_des_ctr_init(key: *const u8, keylen: u32) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_des_ctr_encrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_des_ctr_decrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_des_cfb_init(key: *const u8, keylen: u32) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_des_cfb_encrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_des_cfb_decrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_des_ofb_init(key: *const u8, keylen: u32) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_des_ofb_encrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_des_ofb_decrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_poly1305_init(key: *const u8) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_poly1305_process(
        message: *const u8,
        msglen: u32,
        pDigest: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_poly1305(
        message: *const u8,
        msglen: u32,
        key: *const u8,
        pDigest: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_chacha_init(key: *const u8) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_chacha_encrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        count: u32,
        pResult: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_chacha_decrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        count: u32,
        pResult: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_chacha_poly1305_init(key: *const u8) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_chacha_poly1305_encrypt(
        message: *const u8,
        msglen: u32,
        nonce: *const u8,
        aad: *const u8,
        aadlen: u32,
        pResult: *mut u8,
        pTag: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_chacha_poly1305_decrypt(
        message: *const u8,
        msglen: u32,
        nonce: *const u8,
        aad: *const u8,
        aadlen: u32,
        pResult: *mut u8,
        pTag: *mut u8,
    ) -> crate::ctypes::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FLASH_InitTypeDef {
    pub FLASH_Id: u32,
    pub FLASH_cur_bitmode: u8,
    pub FLASH_baud_rate: u8,
    pub FLASH_baud_boot: u8,
    pub FLASH_cur_cmd: u32,
    pub FLASH_QuadEn_bit: u32,
    pub FLASH_Busy_bit: u32,
    pub FLASH_WLE_bit: u32,
    pub FLASH_Status2_exist: u32,
    pub FLASH_rd_sample_phase_cal: u8,
    pub FLASH_rd_sample_phase: u8,
    pub FLASH_rd_dummy_cyle: [u8; 3usize],
    pub FLASH_rd_dual_o: u32,
    pub FLASH_rd_dual_io: u32,
    pub FLASH_rd_quad_o: u32,
    pub FLASH_rd_quad_io: u32,
    pub FLASH_wr_dual_i: u32,
    pub FLASH_wr_dual_ii: u32,
    pub FLASH_wr_quad_i: u32,
    pub FLASH_wr_quad_ii: u32,
    pub FALSH_dual_valid_cmd: u32,
    pub FALSH_quad_valid_cmd: u32,
    pub FLASH_cmd_wr_en: u8,
    pub FLASH_cmd_rd_id: u8,
    pub FLASH_cmd_rd_status: u8,
    pub FLASH_cmd_rd_status2: u8,
    pub FLASH_cmd_wr_status: u8,
    pub FLASH_cmd_wr_status2: u8,
    pub FLASH_cmd_chip_e: u8,
    pub FLASH_cmd_block_e: u8,
    pub FLASH_cmd_sector_e: u8,
    pub FLASH_cmd_pwdn_release: u8,
    pub FLASH_cmd_pwdn: u8,
    pub debug: u8,
    pub phase_shift_idx: u8,
    pub FLASH_addr_phase_len: u8,
    pub FLASH_pseudo_prm_en: u8,
    pub FLASH_pinmux: u8,
    pub FLASH_rd_fast_single: u32,
}
extern "C" {
    pub fn FLASH_Erase(EraseType: u32, Address: u32);
}
extern "C" {
    pub fn FLASH_SetStatus(Cmd: u8, Len: u32, Status: *mut u8);
}
extern "C" {
    pub fn FLASH_SetStatusBits(SetBits: u32, NewState: u32);
}
extern "C" {
    pub fn FLASH_WaitBusy(WaitType: u32);
}
extern "C" {
    pub fn FLASH_WriteEn();
}
extern "C" {
    pub fn FLASH_TxCmd(cmd: u8, DataPhaseLen: u8, pData: *mut u8);
}
extern "C" {
    pub fn FLASH_RxCmd(cmd: u8, read_len: u32, read_data: *mut u8);
}
extern "C" {
    pub fn FLASH_StructInit(FLASH_InitStruct: *mut FLASH_InitTypeDef);
}
extern "C" {
    pub fn FLASH_StructInit_Micron(FLASH_InitStruct: *mut FLASH_InitTypeDef);
}
extern "C" {
    pub fn FLASH_StructInit_MXIC(FLASH_InitStruct: *mut FLASH_InitTypeDef);
}
extern "C" {
    pub fn FLASH_StructInit_GD(FLASH_InitStruct: *mut FLASH_InitTypeDef);
}
extern "C" {
    pub fn FLASH_Init(SpicBitMode: u8) -> u8;
}
extern "C" {
    pub fn FLASH_SetSpiMode(FLASH_InitStruct: *mut FLASH_InitTypeDef, SpicBitMode: u8);
}
extern "C" {
    pub fn FLASH_DeepPowerDown(NewState: u32);
}
extern "C" {
    pub fn FLASH_TxData256B(StartAddr: u32, DataPhaseLen: u32, pData: *mut u8);
}
extern "C" {
    pub fn FLASH_TxData12B(StartAddr: u32, DataPhaseLen: u8, pData: *mut u8);
}
extern "C" {
    pub fn FLASH_RxData(cmd: u8, StartAddr: u32, read_len: u32, read_data: *mut u8);
}
extern "C" {
    pub fn FLASH_Calibration(
        FLASH_InitStruct: *mut FLASH_InitTypeDef,
        SpicBitMode: u8,
        LineDelay: u8,
    ) -> u32;
}
extern "C" {
    pub fn FLASH_ClockDiv(Div: u8) -> u32;
}
extern "C" {
    pub fn FLASH_CalibrationNew(
        FLASH_InitStruct: *mut FLASH_InitTypeDef,
        SpicBitMode: u8,
        Div: u8,
        CalStep: u8,
        LineDelay: u8,
        StartIdx: u8,
    ) -> u32;
}
extern "C" {
    pub fn FLASH_CalibrationNewCmd(NewStatus: u32) -> u32;
}
extern "C" {
    pub fn FLASH_CalibrationPhaseIdx(phase_idx: u8) -> u32;
}
extern "C" {
    pub fn FLASH_CalibrationPhase(phase_int: u8, phase_sel: u8) -> u32;
}
extern "C" {
    pub fn FLASH_Calibration500MPSCmd(NewStatus: u32) -> u32;
}
extern "C" {
    pub fn FLASH_CalibrationInit(CalibrationEnd: u8) -> u32;
}
extern "C" {
    pub fn FLASH_ClockSwitch(Source: u32, Protection: u32);
}
extern "C" {
    pub fn FLASH_WriteStream(address: u32, len: u32, data: *mut u8) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn FLASH_Write_Lock();
}
extern "C" {
    pub fn FLASH_Write_Unlock();
}
extern "C" {
    pub fn FLASH_RxCmdXIP(cmd: u8, read_len: u32, read_data: *mut u8);
}
extern "C" {
    pub fn FLASH_SetStatusXIP(Cmd: u8, Len: u32, Status: *mut u8);
}
extern "C" {
    pub fn FLASH_SetStatusBitsXIP(SetBits: u32, NewState: u32);
}
extern "C" {
    pub fn FLASH_TxData12BXIP(StartAddr: u32, DataPhaseLen: u8, pData: *mut u8);
}
extern "C" {
    pub fn FLASH_TxData256BXIP(StartAddr: u32, DataPhaseLen: u32, pData: *mut u8);
}
extern "C" {
    pub fn FLASH_EraseXIP(EraseType: u32, Address: u32);
}
extern "C" {
    pub fn FLASH_EreaseDwordsXIP(address: u32, dword_num: u32);
}
extern "C" {
    pub fn FLASH_Write_IPC_Int(Data: *mut crate::ctypes::c_void, IrqStatus: u32, ChanNum: u32);
}
extern "C" {
    pub fn flash_operation_config();
}
pub type TaskFunction_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut crate::ctypes::c_void)>;
pub type StackType_t = u32;
pub type BaseType_t = crate::ctypes::c_long;
pub type UBaseType_t = crate::ctypes::c_ulong;
pub type TickType_t = u32;
extern "C" {
    pub fn vPortYield();
}
extern "C" {
    pub fn vPortEnterCritical();
}
extern "C" {
    pub fn vPortExitCritical();
}
extern "C" {
    pub fn pxPortInitialiseStack(
        pxTopOfStack: *mut StackType_t,
        pxEndOfStack: *mut StackType_t,
        pxCode: TaskFunction_t,
        pvParameters: *mut crate::ctypes::c_void,
    ) -> *mut StackType_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HeapRegion {
    pub pucStartAddress: *mut u8,
    pub xSizeInBytes: usize,
}
impl Default for HeapRegion {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type HeapRegion_t = HeapRegion;
extern "C" {
    pub fn vPortDefineHeapRegions(pxHeapRegions: *const HeapRegion_t);
}
extern "C" {
    pub fn pvPortMalloc(xSize: usize) -> *mut crate::ctypes::c_void;
}
extern "C" {
    pub fn vPortFree(pv: *mut crate::ctypes::c_void);
}
extern "C" {
    pub fn vPortInitialiseBlocks();
}
extern "C" {
    pub fn xPortGetFreeHeapSize() -> usize;
}
extern "C" {
    pub fn xPortGetMinimumEverFreeHeapSize() -> usize;
}
extern "C" {
    pub fn xPortStartScheduler() -> BaseType_t;
}
extern "C" {
    pub fn vPortEndScheduler();
}
extern "C" {
    pub fn vPortSecCall(
        pvFunc: *mut crate::ctypes::c_void,
        ulArg0: u32,
        ulArg1: u32,
        ulArg2: u32,
    ) -> crate::ctypes::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_MINI_LIST_ITEM {
    pub xDummy2: TickType_t,
    pub pvDummy3: [*mut crate::ctypes::c_void; 2usize],
}
impl Default for xSTATIC_MINI_LIST_ITEM {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type StaticMiniListItem_t = xSTATIC_MINI_LIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_LIST {
    pub uxDummy2: UBaseType_t,
    pub pvDummy3: *mut crate::ctypes::c_void,
    pub xDummy4: StaticMiniListItem_t,
}
impl Default for xSTATIC_LIST {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type StaticList_t = xSTATIC_LIST;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xSTATIC_QUEUE {
    pub pvDummy1: [*mut crate::ctypes::c_void; 3usize],
    pub u: xSTATIC_QUEUE__bindgen_ty_1,
    pub xDummy3: [StaticList_t; 2usize],
    pub uxDummy4: [UBaseType_t; 3usize],
    pub ucDummy5: [u8; 2usize],
    pub pvDummy7: *mut crate::ctypes::c_void,
    pub uxDummy8: UBaseType_t,
    pub ucDummy9: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xSTATIC_QUEUE__bindgen_ty_1 {
    pub pvDummy2: *mut crate::ctypes::c_void,
    pub uxDummy2: UBaseType_t,
    _bindgen_union_align: u64,
}
impl Default for xSTATIC_QUEUE__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for xSTATIC_QUEUE__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "xSTATIC_QUEUE__bindgen_ty_1 {{ union }}")
    }
}
impl Default for xSTATIC_QUEUE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for xSTATIC_QUEUE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "xSTATIC_QUEUE {{ pvDummy1: {:?}, u: {:?}, xDummy3: {:?}, uxDummy4: {:?}, ucDummy5: {:?}, pvDummy7: {:?}, uxDummy8: {:?}, ucDummy9: {:?} }}" , self . pvDummy1 , self . u , self . xDummy3 , self . uxDummy4 , self . ucDummy5 , self . pvDummy7 , self . uxDummy8 , self . ucDummy9)
    }
}
pub type StaticQueue_t = xSTATIC_QUEUE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xLIST_ITEM {
    pub xItemValue: TickType_t,
    pub pxNext: *mut xLIST_ITEM,
    pub pxPrevious: *mut xLIST_ITEM,
    pub pvOwner: *mut crate::ctypes::c_void,
    pub pvContainer: *mut xLIST,
}
impl Default for xLIST_ITEM {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type ListItem_t = xLIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xMINI_LIST_ITEM {
    pub xItemValue: TickType_t,
    pub pxNext: *mut xLIST_ITEM,
    pub pxPrevious: *mut xLIST_ITEM,
}
impl Default for xMINI_LIST_ITEM {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type MiniListItem_t = xMINI_LIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xLIST {
    pub uxNumberOfItems: UBaseType_t,
    pub pxIndex: *mut ListItem_t,
    pub xListEnd: MiniListItem_t,
}
impl Default for xLIST {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type List_t = xLIST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tskTaskControlBlock {
    _unused: [u8; 0],
}
pub type TaskHandle_t = *mut tskTaskControlBlock;
pub const eRunning: eTaskState = 0;
pub const eReady: eTaskState = 1;
pub const eBlocked: eTaskState = 2;
pub const eSuspended: eTaskState = 3;
pub const eDeleted: eTaskState = 4;
pub const eInvalid: eTaskState = 5;
pub type eTaskState = crate::ctypes::c_uint;
pub const eNoAction: eNotifyAction = 0;
pub const eSetBits: eNotifyAction = 1;
pub const eIncrement: eNotifyAction = 2;
pub const eSetValueWithOverwrite: eNotifyAction = 3;
pub const eSetValueWithoutOverwrite: eNotifyAction = 4;
pub type eNotifyAction = crate::ctypes::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct xTIME_OUT {
    pub xOverflowCount: BaseType_t,
    pub xTimeOnEntering: TickType_t,
}
pub type TimeOut_t = xTIME_OUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xMEMORY_REGION {
    pub pvBaseAddress: *mut crate::ctypes::c_void,
    pub ulLengthInBytes: u32,
    pub ulParameters: u32,
}
impl Default for xMEMORY_REGION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type MemoryRegion_t = xMEMORY_REGION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xTASK_STATUS {
    pub xHandle: TaskHandle_t,
    pub pcTaskName: *const crate::ctypes::c_char,
    pub xTaskNumber: UBaseType_t,
    pub eCurrentState: eTaskState,
    pub uxCurrentPriority: UBaseType_t,
    pub uxBasePriority: UBaseType_t,
    pub ulRunTimeCounter: u32,
    pub pxStackBase: *mut StackType_t,
    pub usStackHighWaterMark: u16,
}
impl Default for xTASK_STATUS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type TaskStatus_t = xTASK_STATUS;
pub const eAbortSleep: eSleepModeStatus = 0;
pub const eStandardSleep: eSleepModeStatus = 1;
pub const eNoTasksWaitingTimeout: eSleepModeStatus = 2;
pub type eSleepModeStatus = crate::ctypes::c_uint;
extern "C" {
    pub fn xTaskCreate(
        pxTaskCode: TaskFunction_t,
        pcName: *const crate::ctypes::c_char,
        usStackDepth: u16,
        pvParameters: *mut crate::ctypes::c_void,
        uxPriority: UBaseType_t,
        pxCreatedTask: *mut TaskHandle_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn vTaskAllocateMPURegions(xTask: TaskHandle_t, pxRegions: *const MemoryRegion_t);
}
extern "C" {
    pub fn vTaskDelete(xTaskToDelete: TaskHandle_t);
}
extern "C" {
    pub fn vTaskDelay(xTicksToDelay: TickType_t);
}
extern "C" {
    pub fn vTaskDelayUntil(pxPreviousWakeTime: *mut TickType_t, xTimeIncrement: TickType_t);
}
extern "C" {
    pub fn xTaskAbortDelay(xTask: TaskHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn uxTaskPriorityGet(xTask: TaskHandle_t) -> UBaseType_t;
}
extern "C" {
    pub fn uxTaskPriorityGetFromISR(xTask: TaskHandle_t) -> UBaseType_t;
}
extern "C" {
    pub fn eTaskGetState(xTask: TaskHandle_t) -> eTaskState;
}
extern "C" {
    pub fn vTaskGetInfo(
        xTask: TaskHandle_t,
        pxTaskStatus: *mut TaskStatus_t,
        xGetFreeStackSpace: BaseType_t,
        eState: eTaskState,
    );
}
extern "C" {
    pub fn vTaskPrioritySet(xTask: TaskHandle_t, uxNewPriority: UBaseType_t);
}
extern "C" {
    pub fn vTaskSuspend(xTaskToSuspend: TaskHandle_t);
}
extern "C" {
    pub fn vTaskResume(xTaskToResume: TaskHandle_t);
}
extern "C" {
    pub fn xTaskResumeFromISR(xTaskToResume: TaskHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn vTaskStartScheduler();
}
extern "C" {
    pub fn vTaskEndScheduler();
}
extern "C" {
    pub fn vTaskSuspendAll();
}
extern "C" {
    pub fn xTaskResumeAll() -> BaseType_t;
}
extern "C" {
    pub fn xTaskGetTickCount() -> TickType_t;
}
extern "C" {
    pub fn xTaskGetTickCountFromISR() -> TickType_t;
}
extern "C" {
    pub fn uxTaskGetNumberOfTasks() -> UBaseType_t;
}
extern "C" {
    pub fn pcTaskGetName(xTaskToQuery: TaskHandle_t) -> *mut crate::ctypes::c_char;
}
extern "C" {
    pub fn xTaskGetHandle(pcNameToQuery: *const crate::ctypes::c_char) -> TaskHandle_t;
}
extern "C" {
    pub fn uxTaskGetStackHighWaterMark(xTask: TaskHandle_t) -> UBaseType_t;
}
extern "C" {
    pub fn uxTaskGetStackHighWaterMark2(xTask: TaskHandle_t) -> u16;
}
extern "C" {
    pub fn xTaskCallApplicationTaskHook(
        xTask: TaskHandle_t,
        pvParameter: *mut crate::ctypes::c_void,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xTaskGetIdleTaskHandle() -> TaskHandle_t;
}
extern "C" {
    pub fn uxTaskGetSystemState(
        pxTaskStatusArray: *mut TaskStatus_t,
        uxArraySize: UBaseType_t,
        pulTotalRunTime: *mut u32,
    ) -> UBaseType_t;
}
extern "C" {
    pub fn vTaskList(pcWriteBuffer: *mut crate::ctypes::c_char);
}
extern "C" {
    pub fn vTaskGetRunTimeStats(pcWriteBuffer: *mut crate::ctypes::c_char);
}
extern "C" {
    pub fn xTaskGetIdleRunTimeCounter() -> TickType_t;
}
extern "C" {
    pub fn xTaskGenericNotify(
        xTaskToNotify: TaskHandle_t,
        ulValue: u32,
        eAction: eNotifyAction,
        pulPreviousNotificationValue: *mut u32,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xTaskGenericNotifyFromISR(
        xTaskToNotify: TaskHandle_t,
        ulValue: u32,
        eAction: eNotifyAction,
        pulPreviousNotificationValue: *mut u32,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xTaskNotifyWait(
        ulBitsToClearOnEntry: u32,
        ulBitsToClearOnExit: u32,
        pulNotificationValue: *mut u32,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn vTaskNotifyGiveFromISR(
        xTaskToNotify: TaskHandle_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    );
}
extern "C" {
    pub fn ulTaskNotifyTake(xClearCountOnExit: BaseType_t, xTicksToWait: TickType_t) -> u32;
}
extern "C" {
    pub fn xTaskNotifyStateClear(xTask: TaskHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn xTaskIncrementTick() -> BaseType_t;
}
extern "C" {
    pub fn vTaskPlaceOnEventList(pxEventList: *mut List_t, xTicksToWait: TickType_t);
}
extern "C" {
    pub fn vTaskPlaceOnUnorderedEventList(
        pxEventList: *mut List_t,
        xItemValue: TickType_t,
        xTicksToWait: TickType_t,
    );
}
extern "C" {
    pub fn vTaskPlaceOnEventListRestricted(
        pxEventList: *mut List_t,
        xTicksToWait: TickType_t,
        xWaitIndefinitely: BaseType_t,
    );
}
extern "C" {
    pub fn xTaskRemoveFromEventList(pxEventList: *const List_t) -> BaseType_t;
}
extern "C" {
    pub fn vTaskRemoveFromUnorderedEventList(
        pxEventListItem: *mut ListItem_t,
        xItemValue: TickType_t,
    );
}
extern "C" {
    pub fn vTaskSwitchContext();
}
extern "C" {
    pub fn uxTaskResetEventItemValue() -> TickType_t;
}
extern "C" {
    pub fn xTaskGetCurrentTaskHandle() -> TaskHandle_t;
}
extern "C" {
    pub fn vTaskSetTimeOutState(pxTimeOut: *mut TimeOut_t);
}
extern "C" {
    pub fn xTaskCheckForTimeOut(
        pxTimeOut: *mut TimeOut_t,
        pxTicksToWait: *mut TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn vTaskMissedYield();
}
extern "C" {
    pub fn xTaskGetSchedulerState() -> BaseType_t;
}
extern "C" {
    pub fn xTaskPriorityInherit(pxMutexHolder: TaskHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn xTaskPriorityDisinherit(pxMutexHolder: TaskHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn vTaskPriorityDisinheritAfterTimeout(
        pxMutexHolder: TaskHandle_t,
        uxHighestPriorityWaitingTask: UBaseType_t,
    );
}
extern "C" {
    pub fn uxTaskGetTaskNumber(xTask: TaskHandle_t) -> UBaseType_t;
}
extern "C" {
    pub fn vTaskSetTaskNumber(xTask: TaskHandle_t, uxHandle: UBaseType_t);
}
extern "C" {
    pub fn vTaskStepTick(xTicksToJump: TickType_t);
}
extern "C" {
    pub fn eTaskConfirmSleepModeStatus() -> eSleepModeStatus;
}
extern "C" {
    pub fn pvTaskIncrementMutexHeldCount() -> TaskHandle_t;
}
extern "C" {
    pub fn vTaskInternalSetTimeOutState(pxTimeOut: *mut TimeOut_t);
}
extern "C" {
    pub fn vTaskStackAddr() -> *mut u32;
}
extern "C" {
    pub fn vTaskStackTOPAddr() -> *mut u32;
}
extern "C" {
    pub fn vTaskStackSize() -> u32;
}
extern "C" {
    pub fn vTaskName() -> *mut crate::ctypes::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QueueDefinition {
    _unused: [u8; 0],
}
pub type QueueHandle_t = *mut QueueDefinition;
pub type QueueSetHandle_t = *mut QueueDefinition;
pub type QueueSetMemberHandle_t = *mut QueueDefinition;
extern "C" {
    pub fn xQueueGenericSend(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const crate::ctypes::c_void,
        xTicksToWait: TickType_t,
        xCopyPosition: BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueuePeek(
        xQueue: QueueHandle_t,
        pvBuffer: *mut crate::ctypes::c_void,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueuePeekFromISR(
        xQueue: QueueHandle_t,
        pvBuffer: *mut crate::ctypes::c_void,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueReceive(
        xQueue: QueueHandle_t,
        pvBuffer: *mut crate::ctypes::c_void,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn uxQueueMessagesWaiting(xQueue: QueueHandle_t) -> UBaseType_t;
}
extern "C" {
    pub fn uxQueueSpacesAvailable(xQueue: QueueHandle_t) -> UBaseType_t;
}
extern "C" {
    pub fn vQueueDelete(xQueue: QueueHandle_t);
}
extern "C" {
    pub fn xQueueGenericSendFromISR(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const crate::ctypes::c_void,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
        xCopyPosition: BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueGiveFromISR(
        xQueue: QueueHandle_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueReceiveFromISR(
        xQueue: QueueHandle_t,
        pvBuffer: *mut crate::ctypes::c_void,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueIsQueueEmptyFromISR(xQueue: QueueHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn xQueueIsQueueFullFromISR(xQueue: QueueHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn uxQueueMessagesWaitingFromISR(xQueue: QueueHandle_t) -> UBaseType_t;
}
extern "C" {
    pub fn xQueueCRSendFromISR(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const crate::ctypes::c_void,
        xCoRoutinePreviouslyWoken: BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueCRReceiveFromISR(
        xQueue: QueueHandle_t,
        pvBuffer: *mut crate::ctypes::c_void,
        pxTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueCRSend(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const crate::ctypes::c_void,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueCRReceive(
        xQueue: QueueHandle_t,
        pvBuffer: *mut crate::ctypes::c_void,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueCreateMutex(ucQueueType: u8) -> QueueHandle_t;
}
extern "C" {
    pub fn xQueueCreateMutexStatic(
        ucQueueType: u8,
        pxStaticQueue: *mut StaticQueue_t,
    ) -> QueueHandle_t;
}
extern "C" {
    pub fn xQueueCreateCountingSemaphore(
        uxMaxCount: UBaseType_t,
        uxInitialCount: UBaseType_t,
    ) -> QueueHandle_t;
}
extern "C" {
    pub fn xQueueCreateCountingSemaphoreStatic(
        uxMaxCount: UBaseType_t,
        uxInitialCount: UBaseType_t,
        pxStaticQueue: *mut StaticQueue_t,
    ) -> QueueHandle_t;
}
extern "C" {
    pub fn xQueueSemaphoreTake(xQueue: QueueHandle_t, xTicksToWait: TickType_t) -> BaseType_t;
}
extern "C" {
    pub fn xQueueGetMutexHolder(xSemaphore: QueueHandle_t) -> TaskHandle_t;
}
extern "C" {
    pub fn xQueueGetMutexHolderFromISR(xSemaphore: QueueHandle_t) -> TaskHandle_t;
}
extern "C" {
    pub fn xQueueTakeMutexRecursive(xMutex: QueueHandle_t, xTicksToWait: TickType_t) -> BaseType_t;
}
extern "C" {
    pub fn xQueueGiveMutexRecursive(xMutex: QueueHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn xQueueGenericCreate(
        uxQueueLength: UBaseType_t,
        uxItemSize: UBaseType_t,
        ucQueueType: u8,
    ) -> QueueHandle_t;
}
extern "C" {
    pub fn xQueueCreateSet(uxEventQueueLength: UBaseType_t) -> QueueSetHandle_t;
}
extern "C" {
    pub fn xQueueAddToSet(
        xQueueOrSemaphore: QueueSetMemberHandle_t,
        xQueueSet: QueueSetHandle_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueRemoveFromSet(
        xQueueOrSemaphore: QueueSetMemberHandle_t,
        xQueueSet: QueueSetHandle_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueSelectFromSet(
        xQueueSet: QueueSetHandle_t,
        xTicksToWait: TickType_t,
    ) -> QueueSetMemberHandle_t;
}
extern "C" {
    pub fn xQueueSelectFromSetFromISR(xQueueSet: QueueSetHandle_t) -> QueueSetMemberHandle_t;
}
extern "C" {
    pub fn vQueueWaitForMessageRestricted(
        xQueue: QueueHandle_t,
        xTicksToWait: TickType_t,
        xWaitIndefinitely: BaseType_t,
    );
}
extern "C" {
    pub fn xQueueGenericReset(xQueue: QueueHandle_t, xNewQueue: BaseType_t) -> BaseType_t;
}
extern "C" {
    pub fn vQueueSetQueueNumber(xQueue: QueueHandle_t, uxQueueNumber: UBaseType_t);
}
extern "C" {
    pub fn uxQueueGetQueueNumber(xQueue: QueueHandle_t) -> UBaseType_t;
}
extern "C" {
    pub fn ucQueueGetQueueType(xQueue: QueueHandle_t) -> u8;
}
pub type SemaphoreHandle_t = QueueHandle_t;
extern "C" {
    pub fn GPIO_PortRead(GPIO_Port: u32, GPIO_Mask: u32) -> u32;
}
extern "C" {
    pub fn GPIO_PortWrite(GPIO_Port: u32, GPIO_Mask: u32, Port_State: u32);
}
extern "C" {
    pub fn GPIO_PortDirection(GPIO_Port: u32, GPIO_Mask: u32, data_direction: u32);
}
extern "C" {
    pub fn pvPortReAlloc(
        pv: *mut crate::ctypes::c_void,
        xWantedSize: usize,
    ) -> *mut crate::ctypes::c_void;
}
extern "C" {
    pub fn app_init_psram();
}
pub const PA_0: PinName = 0;
pub const PA_1: PinName = 1;
pub const PA_2: PinName = 2;
pub const PA_3: PinName = 3;
pub const PA_4: PinName = 4;
pub const PA_5: PinName = 5;
pub const PA_6: PinName = 6;
pub const PA_7: PinName = 7;
pub const PA_8: PinName = 8;
pub const PA_9: PinName = 9;
pub const PA_10: PinName = 10;
pub const PA_11: PinName = 11;
pub const PA_12: PinName = 12;
pub const PA_13: PinName = 13;
pub const PA_14: PinName = 14;
pub const PA_15: PinName = 15;
pub const PA_16: PinName = 16;
pub const PA_17: PinName = 17;
pub const PA_18: PinName = 18;
pub const PA_19: PinName = 19;
pub const PA_20: PinName = 20;
pub const PA_21: PinName = 21;
pub const PA_22: PinName = 22;
pub const PA_23: PinName = 23;
pub const PA_24: PinName = 24;
pub const PA_25: PinName = 25;
pub const PA_26: PinName = 26;
pub const PA_27: PinName = 27;
pub const PA_28: PinName = 28;
pub const PA_29: PinName = 29;
pub const PA_30: PinName = 30;
pub const PA_31: PinName = 31;
pub const PB_0: PinName = 32;
pub const PB_1: PinName = 33;
pub const PB_2: PinName = 34;
pub const PB_3: PinName = 35;
pub const PB_4: PinName = 36;
pub const PB_5: PinName = 37;
pub const PB_6: PinName = 38;
pub const PB_7: PinName = 39;
pub const PB_8: PinName = 40;
pub const PB_9: PinName = 41;
pub const PB_10: PinName = 42;
pub const PB_11: PinName = 43;
pub const PB_12: PinName = 44;
pub const PB_13: PinName = 45;
pub const PB_14: PinName = 46;
pub const PB_15: PinName = 47;
pub const PB_16: PinName = 48;
pub const PB_17: PinName = 49;
pub const PB_18: PinName = 50;
pub const PB_19: PinName = 51;
pub const PB_20: PinName = 52;
pub const PB_21: PinName = 53;
pub const PB_22: PinName = 54;
pub const PB_23: PinName = 55;
pub const PB_24: PinName = 56;
pub const PB_25: PinName = 57;
pub const PB_26: PinName = 58;
pub const PB_27: PinName = 59;
pub const PB_28: PinName = 60;
pub const PB_29: PinName = 61;
pub const PB_30: PinName = 62;
pub const PB_31: PinName = 63;
pub const VBAT_MEAS: PinName = 226;
pub const AD_0: PinName = 36;
pub const AD_1: PinName = 37;
pub const AD_2: PinName = 38;
pub const AD_3: PinName = 39;
pub const AD_4: PinName = 33;
pub const AD_5: PinName = 34;
pub const AD_6: PinName = 35;
pub const AD_7: PinName = 226;
pub const NC: PinName = 4294967295;
pub type PinName = crate::ctypes::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct serial_s {
    pub uart_idx: u8,
    pub tx_len: u32,
    pub rx_len: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct flash_s {
    pub SpicInitPara: FLASH_InitTypeDef,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gtimer_s {
    pub handler: *mut crate::ctypes::c_void,
    pub hid: u32,
    pub timer_id: u8,
    pub is_periodcal: u8,
}
impl Default for gtimer_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const ParityNone: SerialParity = 0;
pub const ParityOdd: SerialParity = 1;
pub const ParityEven: SerialParity = 2;
pub const ParityForced1: SerialParity = 3;
pub const ParityForced0: SerialParity = 4;
pub type SerialParity = crate::ctypes::c_uint;
pub const RxIrq: SerialIrq = 0;
pub const TxIrq: SerialIrq = 1;
pub type SerialIrq = crate::ctypes::c_uint;
pub const FlowControlNone: FlowControl = 0;
pub const FlowControlRTS: FlowControl = 1;
pub const FlowControlCTS: FlowControl = 2;
pub const FlowControlRTSCTS: FlowControl = 3;
pub type FlowControl = crate::ctypes::c_uint;
pub type uart_irq_handler = ::core::option::Option<unsafe extern "C" fn(id: u32, event: SerialIrq)>;
pub type serial_t = serial_s;
extern "C" {
    pub fn serial_init(obj: *mut serial_t, tx: PinName, rx: PinName);
}
extern "C" {
    pub fn serial_free(obj: *mut serial_t);
}
extern "C" {
    pub fn serial_baud(obj: *mut serial_t, baudrate: crate::ctypes::c_int);
}
extern "C" {
    pub fn serial_format(
        obj: *mut serial_t,
        data_bits: crate::ctypes::c_int,
        parity: SerialParity,
        stop_bits: crate::ctypes::c_int,
    );
}
extern "C" {
    pub fn serial_irq_handler(obj: *mut serial_t, handler: uart_irq_handler, id: u32);
}
extern "C" {
    pub fn serial_irq_set(obj: *mut serial_t, irq: SerialIrq, enable: u32);
}
extern "C" {
    pub fn serial_getc(obj: *mut serial_t) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn serial_putc(obj: *mut serial_t, c: crate::ctypes::c_int);
}
extern "C" {
    pub fn serial_readable(obj: *mut serial_t) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn serial_writable(obj: *mut serial_t) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn serial_clear(obj: *mut serial_t);
}
extern "C" {
    pub fn serial_break_set(obj: *mut serial_t);
}
extern "C" {
    pub fn serial_break_clear(obj: *mut serial_t);
}
extern "C" {
    pub fn serial_pinout_tx(tx: PinName);
}
extern "C" {
    pub fn serial_set_flow_control(
        obj: *mut serial_t,
        type_: FlowControl,
        rxflow: PinName,
        txflow: PinName,
    );
}
extern "C" {
    pub fn serial_rts_control(obj: *mut serial_t, rts_state: BOOLEAN);
}
extern "C" {
    pub fn sys_jtag_off();
}
extern "C" {
    pub fn sys_clear_ota_signature();
}
extern "C" {
    pub fn sys_recover_ota_signature();
}
extern "C" {
    pub fn sys_log_uart_on();
}
extern "C" {
    pub fn sys_log_uart_off();
}
extern "C" {
    pub fn sys_adc_calibration(write: u8, offset: *mut u16, gain: *mut u16);
}
extern "C" {
    pub fn sys_reset();
}
pub type flash_t = flash_s;
extern "C" {
    pub fn flash_erase_sector(obj: *mut flash_t, address: u32);
}
extern "C" {
    pub fn flash_erase_block(obj: *mut flash_t, address: u32);
}
extern "C" {
    pub fn flash_read_word(obj: *mut flash_t, address: u32, data: *mut u32)
        -> crate::ctypes::c_int;
}
extern "C" {
    pub fn flash_write_word(obj: *mut flash_t, address: u32, data: u32) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn flash_stream_read(
        obj: *mut flash_t,
        address: u32,
        len: u32,
        data: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn flash_stream_write(
        obj: *mut flash_t,
        address: u32,
        len: u32,
        data: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn flash_write_protect(obj: *mut flash_t, protect: u32);
}
extern "C" {
    pub fn flash_get_status(obj: *mut flash_t) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn flash_get_status2(obj: *mut flash_t) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn flash_set_status(obj: *mut flash_t, data: u32) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn flash_set_status2(obj: *mut flash_t, data: u32) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn flash_reset_status(obj: *mut flash_t);
}
extern "C" {
    pub fn flash_burst_write(
        obj: *mut flash_t,
        address: u32,
        Length: u32,
        data: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn flash_burst_read(
        obj: *mut flash_t,
        address: u32,
        Length: u32,
        data: *mut u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn flash_set_extend_addr(obj: *mut flash_t, data: u32) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn flash_get_extend_addr(obj: *mut flash_t) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn flash_read_id(obj: *mut flash_t, buf: *mut u8, len: u8) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn flash_read_unique_id(obj: *mut flash_t, buf: *mut u8, len: u8) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn flash_set_lock_mode(mode: u32);
}
extern "C" {
    pub fn flash_global_lock();
}
extern "C" {
    pub fn flash_global_unlock();
}
extern "C" {
    pub fn flash_individual_lock(address: u32);
}
extern "C" {
    pub fn flash_individual_unlock(address: u32);
}
extern "C" {
    pub fn flash_read_individual_lock_state(address: u32) -> crate::ctypes::c_int;
}
pub type gtimer_t = gtimer_s;
extern "C" {
    pub fn gtimer_init(obj: *mut gtimer_t, tid: u32);
}
extern "C" {
    pub fn gtimer_deinit(obj: *mut gtimer_t);
}
extern "C" {
    pub fn gtimer_read_tick(obj: *mut gtimer_t) -> u32;
}
extern "C" {
    pub fn gtimer_read_us(obj: *mut gtimer_t) -> u64;
}
extern "C" {
    pub fn gtimer_reload(obj: *mut gtimer_t, duration_us: u32);
}
extern "C" {
    pub fn gtimer_start(obj: *mut gtimer_t);
}
extern "C" {
    pub fn gtimer_start_one_shout(
        obj: *mut gtimer_t,
        duration_us: u32,
        handler: *mut crate::ctypes::c_void,
        hid: u32,
    );
}
extern "C" {
    pub fn gtimer_start_periodical(
        obj: *mut gtimer_t,
        duration_us: u32,
        handler: *mut crate::ctypes::c_void,
        hid: u32,
    );
}
extern "C" {
    pub fn gtimer_stop(obj: *mut gtimer_t);
}
pub const RT_DEV_LOCK_EFUSE: _RT_DEV_LOCK_E = 0;
pub const RT_DEV_LOCK_FLASH: _RT_DEV_LOCK_E = 1;
pub const RT_DEV_LOCK_CRYPTO: _RT_DEV_LOCK_E = 2;
pub const RT_DEV_LOCK_PTA: _RT_DEV_LOCK_E = 3;
pub const RT_DEV_LOCK_WLAN: _RT_DEV_LOCK_E = 4;
pub const RT_DEV_LOCK_MAX: _RT_DEV_LOCK_E = 5;
pub type _RT_DEV_LOCK_E = crate::ctypes::c_uint;
pub type RT_DEV_LOCK_E = u32;
extern "C" {
    pub fn device_mutex_lock(device: RT_DEV_LOCK_E);
}
extern "C" {
    pub fn device_mutex_unlock(device: RT_DEV_LOCK_E);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct list_head {
    pub next: *mut list_head,
    pub prev: *mut list_head,
}
impl Default for list_head {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn xTimerGetTimerDaemonTaskHandle() -> TaskHandle_t;
}
extern "C" {
    pub fn xTimerCreateTimerTask() -> BaseType_t;
}
pub type _sema = *mut crate::ctypes::c_void;
pub type _xqueue = *mut crate::ctypes::c_void;
pub type _list = list_head;
pub type _thread_hdl_ = *mut crate::ctypes::c_void;
pub type event_handler_t = ::core::option::Option<
    unsafe extern "C" fn(
        buf: *mut crate::ctypes::c_char,
        buf_len: crate::ctypes::c_int,
        flags: crate::ctypes::c_int,
        user_data: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct task_struct {
    pub task_name: *const crate::ctypes::c_char,
    pub task: _thread_hdl_,
    pub wakeup_sema: _sema,
    pub terminate_sema: _sema,
    pub blocked: u32,
    pub callback_running: u32,
}
impl Default for task_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rtw_worker_thread_t {
    pub event_queue: _xqueue,
    pub thread: task_struct,
}
impl Default for rtw_worker_thread_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rtw_event_message_t {
    pub function: event_handler_t,
    pub buf: *mut crate::ctypes::c_char,
    pub buf_len: crate::ctypes::c_int,
    pub flags: crate::ctypes::c_int,
    pub user_data: *mut crate::ctypes::c_void,
}
impl Default for rtw_event_message_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn init_mem_monitor(pmem_table: *mut _list, used_num: *mut crate::ctypes::c_int);
}
extern "C" {
    pub fn Psram_heap_init();
}
extern "C" {
    pub fn Psram_heap_allocmem(size: crate::ctypes::c_int) -> *mut crate::ctypes::c_void;
}
extern "C" {
    pub fn Psram_reserved_heap_freemem(mem: *mut crate::ctypes::c_void, size: crate::ctypes::c_int);
}
extern "C" {
    pub fn Psram_reserve_free_size() -> crate::ctypes::c_int;
}
extern "C" {
    pub fn Psram_reserve_malloc(size: crate::ctypes::c_int) -> *mut crate::ctypes::c_void;
}
extern "C" {
    pub fn Psram_reserve_calloc(
        num: crate::ctypes::c_int,
        size: crate::ctypes::c_int,
    ) -> *mut crate::ctypes::c_void;
}
extern "C" {
    pub fn Psram_reserve_free(mem: *mut crate::ctypes::c_void);
}
pub const RTW_SUCCESS: crate::ctypes::c_int = 0;
pub const RTW_PENDING: crate::ctypes::c_int = 1;
pub const RTW_TIMEOUT: crate::ctypes::c_int = 2;
pub const RTW_PARTIAL_RESULTS: crate::ctypes::c_int = 3;
pub const RTW_INVALID_KEY: crate::ctypes::c_int = 4;
pub const RTW_DOES_NOT_EXIST: crate::ctypes::c_int = 5;
pub const RTW_NOT_AUTHENTICATED: crate::ctypes::c_int = 6;
pub const RTW_NOT_KEYED: crate::ctypes::c_int = 7;
pub const RTW_IOCTL_FAIL: crate::ctypes::c_int = 8;
pub const RTW_BUFFER_UNAVAILABLE_TEMPORARY: crate::ctypes::c_int = 9;
pub const RTW_BUFFER_UNAVAILABLE_PERMANENT: crate::ctypes::c_int = 10;
pub const RTW_WPS_PBC_OVERLAP: crate::ctypes::c_int = 11;
pub const RTW_CONNECTION_LOST: crate::ctypes::c_int = 12;
pub const RTW_ERROR: crate::ctypes::c_int = -1;
pub const RTW_BADARG: crate::ctypes::c_int = -2;
pub const RTW_BADOPTION: crate::ctypes::c_int = -3;
pub const RTW_NOTUP: crate::ctypes::c_int = -4;
pub const RTW_NOTDOWN: crate::ctypes::c_int = -5;
pub const RTW_NOTAP: crate::ctypes::c_int = -6;
pub const RTW_NOTSTA: crate::ctypes::c_int = -7;
pub const RTW_BADKEYIDX: crate::ctypes::c_int = -8;
pub const RTW_RADIOOFF: crate::ctypes::c_int = -9;
pub const RTW_NOTBANDLOCKED: crate::ctypes::c_int = -10;
pub const RTW_NOCLK: crate::ctypes::c_int = -11;
pub const RTW_BADRATESET: crate::ctypes::c_int = -12;
pub const RTW_BADBAND: crate::ctypes::c_int = -13;
pub const RTW_BUFTOOSHORT: crate::ctypes::c_int = -14;
pub const RTW_BUFTOOLONG: crate::ctypes::c_int = -15;
pub const RTW_BUSY: crate::ctypes::c_int = -16;
pub const RTW_NOTASSOCIATED: crate::ctypes::c_int = -17;
pub const RTW_BADSSIDLEN: crate::ctypes::c_int = -18;
pub const RTW_OUTOFRANGECHAN: crate::ctypes::c_int = -19;
pub const RTW_BADCHAN: crate::ctypes::c_int = -20;
pub const RTW_BADADDR: crate::ctypes::c_int = -21;
pub const RTW_NORESOURCE: crate::ctypes::c_int = -22;
pub const RTW_UNSUPPORTED: crate::ctypes::c_int = -23;
pub const RTW_BADLEN: crate::ctypes::c_int = -24;
pub const RTW_NOTREADY: crate::ctypes::c_int = -25;
pub const RTW_EPERM: crate::ctypes::c_int = -26;
pub const RTW_NOMEM: crate::ctypes::c_int = -27;
pub const RTW_ASSOCIATED: crate::ctypes::c_int = -28;
pub const RTW_RANGE: crate::ctypes::c_int = -29;
pub const RTW_NOTFOUND: crate::ctypes::c_int = -30;
pub const RTW_WME_NOT_ENABLED: crate::ctypes::c_int = -31;
pub const RTW_TSPEC_NOTFOUND: crate::ctypes::c_int = -32;
pub const RTW_ACM_NOTSUPPORTED: crate::ctypes::c_int = -33;
pub const RTW_NOT_WME_ASSOCIATION: crate::ctypes::c_int = -34;
pub const RTW_SDIO_ERROR: crate::ctypes::c_int = -35;
pub const RTW_WLAN_DOWN: crate::ctypes::c_int = -36;
pub const RTW_BAD_VERSION: crate::ctypes::c_int = -37;
pub const RTW_TXFAIL: crate::ctypes::c_int = -38;
pub const RTW_RXFAIL: crate::ctypes::c_int = -39;
pub const RTW_NODEVICE: crate::ctypes::c_int = -40;
pub const RTW_UNFINISHED: crate::ctypes::c_int = -41;
pub const RTW_NONRESIDENT: crate::ctypes::c_int = -42;
pub const RTW_DISABLED: crate::ctypes::c_int = -43;
pub type _bindgen_ty_4 = crate::ctypes::c_int;
pub type rtw_result_t = crate::ctypes::c_long;
pub const RTW_SECURITY_OPEN: crate::ctypes::c_int = 0;
pub const RTW_SECURITY_WEP_PSK: crate::ctypes::c_int = 1;
pub const RTW_SECURITY_WEP_SHARED: crate::ctypes::c_int = 32769;
pub const RTW_SECURITY_WPA_TKIP_PSK: crate::ctypes::c_int = 2097154;
pub const RTW_SECURITY_WPA_AES_PSK: crate::ctypes::c_int = 2097156;
pub const RTW_SECURITY_WPA2_AES_PSK: crate::ctypes::c_int = 4194308;
pub const RTW_SECURITY_WPA2_TKIP_PSK: crate::ctypes::c_int = 4194306;
pub const RTW_SECURITY_WPA2_MIXED_PSK: crate::ctypes::c_int = 4194310;
pub const RTW_SECURITY_WPA_WPA2_MIXED: crate::ctypes::c_int = 6291456;
pub const RTW_SECURITY_WPA2_AES_CMAC: crate::ctypes::c_int = 4194320;
pub const RTW_SECURITY_WPA2_ENTERPRISE: crate::ctypes::c_int = 4194336;
pub const RTW_SECURITY_WPA_WPA2_ENTERPRISE: crate::ctypes::c_int = 6291488;
pub const RTW_SECURITY_WPS_OPEN: crate::ctypes::c_int = 268435456;
pub const RTW_SECURITY_WPS_SECURE: crate::ctypes::c_int = 268435460;
pub const RTW_SECURITY_WPA3_AES_PSK: crate::ctypes::c_int = 8388612;
pub const RTW_SECURITY_UNKNOWN: crate::ctypes::c_int = -1;
pub const RTW_SECURITY_FORCE_32_BIT: crate::ctypes::c_int = 2147483647;
pub type _bindgen_ty_5 = crate::ctypes::c_int;
pub type rtw_security_t = crate::ctypes::c_ulong;
pub const RTW_ENCRYPTION_UNKNOWN: crate::ctypes::c_uint = 0;
pub const RTW_ENCRYPTION_OPEN: crate::ctypes::c_uint = 1;
pub const RTW_ENCRYPTION_WEP40: crate::ctypes::c_uint = 2;
pub const RTW_ENCRYPTION_WPA_TKIP: crate::ctypes::c_uint = 3;
pub const RTW_ENCRYPTION_WPA_AES: crate::ctypes::c_uint = 4;
pub const RTW_ENCRYPTION_WPA2_TKIP: crate::ctypes::c_uint = 5;
pub const RTW_ENCRYPTION_WPA2_AES: crate::ctypes::c_uint = 6;
pub const RTW_ENCRYPTION_WPA2_MIXED: crate::ctypes::c_uint = 7;
pub const RTW_ENCRYPTION_WEP104: crate::ctypes::c_uint = 9;
pub const RTW_ENCRYPTION_UNDEF: crate::ctypes::c_uint = 255;
pub type _bindgen_ty_6 = crate::ctypes::c_uint;
pub type rtw_encryption_t = crate::ctypes::c_ulong;
pub const RTW_FALSE: crate::ctypes::c_uint = 0;
pub const RTW_TRUE: crate::ctypes::c_uint = 1;
pub type _bindgen_ty_7 = crate::ctypes::c_uint;
pub type rtw_bool_t = crate::ctypes::c_ulong;
pub const RTW_802_11_BAND_5GHZ: crate::ctypes::c_uint = 0;
pub const RTW_802_11_BAND_2_4GHZ: crate::ctypes::c_uint = 1;
pub type _bindgen_ty_8 = crate::ctypes::c_uint;
pub type rtw_802_11_band_t = crate::ctypes::c_ulong;
pub const RTW_COUNTRY_WORLD1: crate::ctypes::c_uint = 0;
pub const RTW_COUNTRY_ETSI1: crate::ctypes::c_uint = 1;
pub const RTW_COUNTRY_FCC1: crate::ctypes::c_uint = 2;
pub const RTW_COUNTRY_MKK1: crate::ctypes::c_uint = 3;
pub const RTW_COUNTRY_ETSI2: crate::ctypes::c_uint = 4;
pub const RTW_COUNTRY_FCC2: crate::ctypes::c_uint = 5;
pub const RTW_COUNTRY_WORLD2: crate::ctypes::c_uint = 6;
pub const RTW_COUNTRY_MKK2: crate::ctypes::c_uint = 7;
pub const RTW_COUNTRY_GLOBAL: crate::ctypes::c_uint = 8;
pub const RTW_COUNTRY_WORLD: crate::ctypes::c_uint = 9;
pub const RTW_COUNTRY_EU: crate::ctypes::c_uint = 10;
pub const RTW_COUNTRY_JP: crate::ctypes::c_uint = 11;
pub const RTW_COUNTRY_AS: crate::ctypes::c_uint = 12;
pub const RTW_COUNTRY_BM: crate::ctypes::c_uint = 13;
pub const RTW_COUNTRY_CA: crate::ctypes::c_uint = 14;
pub const RTW_COUNTRY_DM: crate::ctypes::c_uint = 15;
pub const RTW_COUNTRY_DO: crate::ctypes::c_uint = 16;
pub const RTW_COUNTRY_FM: crate::ctypes::c_uint = 17;
pub const RTW_COUNTRY_GD: crate::ctypes::c_uint = 18;
pub const RTW_COUNTRY_GT: crate::ctypes::c_uint = 19;
pub const RTW_COUNTRY_GU: crate::ctypes::c_uint = 20;
pub const RTW_COUNTRY_HT: crate::ctypes::c_uint = 21;
pub const RTW_COUNTRY_MH: crate::ctypes::c_uint = 22;
pub const RTW_COUNTRY_MP: crate::ctypes::c_uint = 23;
pub const RTW_COUNTRY_NI: crate::ctypes::c_uint = 24;
pub const RTW_COUNTRY_PA: crate::ctypes::c_uint = 25;
pub const RTW_COUNTRY_PR: crate::ctypes::c_uint = 26;
pub const RTW_COUNTRY_PW: crate::ctypes::c_uint = 27;
pub const RTW_COUNTRY_TW: crate::ctypes::c_uint = 28;
pub const RTW_COUNTRY_US: crate::ctypes::c_uint = 29;
pub const RTW_COUNTRY_VI: crate::ctypes::c_uint = 30;
pub const RTW_COUNTRY_AD: crate::ctypes::c_uint = 31;
pub const RTW_COUNTRY_AE: crate::ctypes::c_uint = 32;
pub const RTW_COUNTRY_AF: crate::ctypes::c_uint = 33;
pub const RTW_COUNTRY_AI: crate::ctypes::c_uint = 34;
pub const RTW_COUNTRY_AL: crate::ctypes::c_uint = 35;
pub const RTW_COUNTRY_AM: crate::ctypes::c_uint = 36;
pub const RTW_COUNTRY_AN: crate::ctypes::c_uint = 37;
pub const RTW_COUNTRY_AR: crate::ctypes::c_uint = 38;
pub const RTW_COUNTRY_AT: crate::ctypes::c_uint = 39;
pub const RTW_COUNTRY_AU: crate::ctypes::c_uint = 40;
pub const RTW_COUNTRY_AW: crate::ctypes::c_uint = 41;
pub const RTW_COUNTRY_AZ: crate::ctypes::c_uint = 42;
pub const RTW_COUNTRY_BA: crate::ctypes::c_uint = 43;
pub const RTW_COUNTRY_BB: crate::ctypes::c_uint = 44;
pub const RTW_COUNTRY_BD: crate::ctypes::c_uint = 45;
pub const RTW_COUNTRY_BE: crate::ctypes::c_uint = 46;
pub const RTW_COUNTRY_BF: crate::ctypes::c_uint = 47;
pub const RTW_COUNTRY_BG: crate::ctypes::c_uint = 48;
pub const RTW_COUNTRY_BH: crate::ctypes::c_uint = 49;
pub const RTW_COUNTRY_BL: crate::ctypes::c_uint = 50;
pub const RTW_COUNTRY_BN: crate::ctypes::c_uint = 51;
pub const RTW_COUNTRY_BO: crate::ctypes::c_uint = 52;
pub const RTW_COUNTRY_BR: crate::ctypes::c_uint = 53;
pub const RTW_COUNTRY_BS: crate::ctypes::c_uint = 54;
pub const RTW_COUNTRY_BT: crate::ctypes::c_uint = 55;
pub const RTW_COUNTRY_BY: crate::ctypes::c_uint = 56;
pub const RTW_COUNTRY_BZ: crate::ctypes::c_uint = 57;
pub const RTW_COUNTRY_CF: crate::ctypes::c_uint = 58;
pub const RTW_COUNTRY_CH: crate::ctypes::c_uint = 59;
pub const RTW_COUNTRY_CI: crate::ctypes::c_uint = 60;
pub const RTW_COUNTRY_CL: crate::ctypes::c_uint = 61;
pub const RTW_COUNTRY_CN: crate::ctypes::c_uint = 62;
pub const RTW_COUNTRY_CO: crate::ctypes::c_uint = 63;
pub const RTW_COUNTRY_CR: crate::ctypes::c_uint = 64;
pub const RTW_COUNTRY_CX: crate::ctypes::c_uint = 65;
pub const RTW_COUNTRY_CY: crate::ctypes::c_uint = 66;
pub const RTW_COUNTRY_CZ: crate::ctypes::c_uint = 67;
pub const RTW_COUNTRY_DE: crate::ctypes::c_uint = 68;
pub const RTW_COUNTRY_DK: crate::ctypes::c_uint = 69;
pub const RTW_COUNTRY_DZ: crate::ctypes::c_uint = 70;
pub const RTW_COUNTRY_EC: crate::ctypes::c_uint = 71;
pub const RTW_COUNTRY_EE: crate::ctypes::c_uint = 72;
pub const RTW_COUNTRY_EG: crate::ctypes::c_uint = 73;
pub const RTW_COUNTRY_ES: crate::ctypes::c_uint = 74;
pub const RTW_COUNTRY_ET: crate::ctypes::c_uint = 75;
pub const RTW_COUNTRY_FI: crate::ctypes::c_uint = 76;
pub const RTW_COUNTRY_FR: crate::ctypes::c_uint = 77;
pub const RTW_COUNTRY_GB: crate::ctypes::c_uint = 78;
pub const RTW_COUNTRY_GE: crate::ctypes::c_uint = 79;
pub const RTW_COUNTRY_GF: crate::ctypes::c_uint = 80;
pub const RTW_COUNTRY_GH: crate::ctypes::c_uint = 81;
pub const RTW_COUNTRY_GL: crate::ctypes::c_uint = 82;
pub const RTW_COUNTRY_GP: crate::ctypes::c_uint = 83;
pub const RTW_COUNTRY_GR: crate::ctypes::c_uint = 84;
pub const RTW_COUNTRY_GY: crate::ctypes::c_uint = 85;
pub const RTW_COUNTRY_HK: crate::ctypes::c_uint = 86;
pub const RTW_COUNTRY_HN: crate::ctypes::c_uint = 87;
pub const RTW_COUNTRY_HR: crate::ctypes::c_uint = 88;
pub const RTW_COUNTRY_HU: crate::ctypes::c_uint = 89;
pub const RTW_COUNTRY_ID: crate::ctypes::c_uint = 90;
pub const RTW_COUNTRY_IE: crate::ctypes::c_uint = 91;
pub const RTW_COUNTRY_IL: crate::ctypes::c_uint = 92;
pub const RTW_COUNTRY_IN: crate::ctypes::c_uint = 93;
pub const RTW_COUNTRY_IQ: crate::ctypes::c_uint = 94;
pub const RTW_COUNTRY_IR: crate::ctypes::c_uint = 95;
pub const RTW_COUNTRY_IS: crate::ctypes::c_uint = 96;
pub const RTW_COUNTRY_IT: crate::ctypes::c_uint = 97;
pub const RTW_COUNTRY_JM: crate::ctypes::c_uint = 98;
pub const RTW_COUNTRY_JO: crate::ctypes::c_uint = 99;
pub const RTW_COUNTRY_KE: crate::ctypes::c_uint = 100;
pub const RTW_COUNTRY_KH: crate::ctypes::c_uint = 101;
pub const RTW_COUNTRY_KN: crate::ctypes::c_uint = 102;
pub const RTW_COUNTRY_KP: crate::ctypes::c_uint = 103;
pub const RTW_COUNTRY_KR: crate::ctypes::c_uint = 104;
pub const RTW_COUNTRY_KW: crate::ctypes::c_uint = 105;
pub const RTW_COUNTRY_KY: crate::ctypes::c_uint = 106;
pub const RTW_COUNTRY_KZ: crate::ctypes::c_uint = 107;
pub const RTW_COUNTRY_LA: crate::ctypes::c_uint = 108;
pub const RTW_COUNTRY_LB: crate::ctypes::c_uint = 109;
pub const RTW_COUNTRY_LC: crate::ctypes::c_uint = 110;
pub const RTW_COUNTRY_LI: crate::ctypes::c_uint = 111;
pub const RTW_COUNTRY_LK: crate::ctypes::c_uint = 112;
pub const RTW_COUNTRY_LR: crate::ctypes::c_uint = 113;
pub const RTW_COUNTRY_LS: crate::ctypes::c_uint = 114;
pub const RTW_COUNTRY_LT: crate::ctypes::c_uint = 115;
pub const RTW_COUNTRY_LU: crate::ctypes::c_uint = 116;
pub const RTW_COUNTRY_LV: crate::ctypes::c_uint = 117;
pub const RTW_COUNTRY_MA: crate::ctypes::c_uint = 118;
pub const RTW_COUNTRY_MC: crate::ctypes::c_uint = 119;
pub const RTW_COUNTRY_MD: crate::ctypes::c_uint = 120;
pub const RTW_COUNTRY_ME: crate::ctypes::c_uint = 121;
pub const RTW_COUNTRY_MF: crate::ctypes::c_uint = 122;
pub const RTW_COUNTRY_MK: crate::ctypes::c_uint = 123;
pub const RTW_COUNTRY_MN: crate::ctypes::c_uint = 124;
pub const RTW_COUNTRY_MO: crate::ctypes::c_uint = 125;
pub const RTW_COUNTRY_MQ: crate::ctypes::c_uint = 126;
pub const RTW_COUNTRY_MR: crate::ctypes::c_uint = 127;
pub const RTW_COUNTRY_MT: crate::ctypes::c_uint = 128;
pub const RTW_COUNTRY_MU: crate::ctypes::c_uint = 129;
pub const RTW_COUNTRY_MV: crate::ctypes::c_uint = 130;
pub const RTW_COUNTRY_MW: crate::ctypes::c_uint = 131;
pub const RTW_COUNTRY_MX: crate::ctypes::c_uint = 132;
pub const RTW_COUNTRY_MY: crate::ctypes::c_uint = 133;
pub const RTW_COUNTRY_NG: crate::ctypes::c_uint = 134;
pub const RTW_COUNTRY_NL: crate::ctypes::c_uint = 135;
pub const RTW_COUNTRY_NO: crate::ctypes::c_uint = 136;
pub const RTW_COUNTRY_NP: crate::ctypes::c_uint = 137;
pub const RTW_COUNTRY_NZ: crate::ctypes::c_uint = 138;
pub const RTW_COUNTRY_OM: crate::ctypes::c_uint = 139;
pub const RTW_COUNTRY_PE: crate::ctypes::c_uint = 140;
pub const RTW_COUNTRY_PF: crate::ctypes::c_uint = 141;
pub const RTW_COUNTRY_PG: crate::ctypes::c_uint = 142;
pub const RTW_COUNTRY_PH: crate::ctypes::c_uint = 143;
pub const RTW_COUNTRY_PK: crate::ctypes::c_uint = 144;
pub const RTW_COUNTRY_PL: crate::ctypes::c_uint = 145;
pub const RTW_COUNTRY_PM: crate::ctypes::c_uint = 146;
pub const RTW_COUNTRY_PT: crate::ctypes::c_uint = 147;
pub const RTW_COUNTRY_PY: crate::ctypes::c_uint = 148;
pub const RTW_COUNTRY_QA: crate::ctypes::c_uint = 149;
pub const RTW_COUNTRY_RS: crate::ctypes::c_uint = 150;
pub const RTW_COUNTRY_RU: crate::ctypes::c_uint = 151;
pub const RTW_COUNTRY_RW: crate::ctypes::c_uint = 152;
pub const RTW_COUNTRY_SA: crate::ctypes::c_uint = 153;
pub const RTW_COUNTRY_SE: crate::ctypes::c_uint = 154;
pub const RTW_COUNTRY_SG: crate::ctypes::c_uint = 155;
pub const RTW_COUNTRY_SI: crate::ctypes::c_uint = 156;
pub const RTW_COUNTRY_SK: crate::ctypes::c_uint = 157;
pub const RTW_COUNTRY_SN: crate::ctypes::c_uint = 158;
pub const RTW_COUNTRY_SR: crate::ctypes::c_uint = 159;
pub const RTW_COUNTRY_SV: crate::ctypes::c_uint = 160;
pub const RTW_COUNTRY_SY: crate::ctypes::c_uint = 161;
pub const RTW_COUNTRY_TC: crate::ctypes::c_uint = 162;
pub const RTW_COUNTRY_TD: crate::ctypes::c_uint = 163;
pub const RTW_COUNTRY_TG: crate::ctypes::c_uint = 164;
pub const RTW_COUNTRY_TH: crate::ctypes::c_uint = 165;
pub const RTW_COUNTRY_TN: crate::ctypes::c_uint = 166;
pub const RTW_COUNTRY_TR: crate::ctypes::c_uint = 167;
pub const RTW_COUNTRY_TT: crate::ctypes::c_uint = 168;
pub const RTW_COUNTRY_TZ: crate::ctypes::c_uint = 169;
pub const RTW_COUNTRY_UA: crate::ctypes::c_uint = 170;
pub const RTW_COUNTRY_UG: crate::ctypes::c_uint = 171;
pub const RTW_COUNTRY_UY: crate::ctypes::c_uint = 172;
pub const RTW_COUNTRY_UZ: crate::ctypes::c_uint = 173;
pub const RTW_COUNTRY_VC: crate::ctypes::c_uint = 174;
pub const RTW_COUNTRY_VE: crate::ctypes::c_uint = 175;
pub const RTW_COUNTRY_VN: crate::ctypes::c_uint = 176;
pub const RTW_COUNTRY_VU: crate::ctypes::c_uint = 177;
pub const RTW_COUNTRY_WF: crate::ctypes::c_uint = 178;
pub const RTW_COUNTRY_WS: crate::ctypes::c_uint = 179;
pub const RTW_COUNTRY_YE: crate::ctypes::c_uint = 180;
pub const RTW_COUNTRY_YT: crate::ctypes::c_uint = 181;
pub const RTW_COUNTRY_ZA: crate::ctypes::c_uint = 182;
pub const RTW_COUNTRY_ZW: crate::ctypes::c_uint = 183;
pub const RTW_COUNTRY_MAX: crate::ctypes::c_uint = 184;
pub type _bindgen_ty_9 = crate::ctypes::c_uint;
pub type rtw_country_code_t = crate::ctypes::c_ulong;
pub const RTW_ADAPTIVITY_DISABLE: crate::ctypes::c_uint = 0;
pub const RTW_ADAPTIVITY_NORMAL: crate::ctypes::c_uint = 1;
pub const RTW_ADAPTIVITY_CARRIER_SENSE: crate::ctypes::c_uint = 2;
pub type _bindgen_ty_10 = crate::ctypes::c_uint;
pub type rtw_adaptivity_mode_t = crate::ctypes::c_ulong;
pub const RTW_MODE_NONE: crate::ctypes::c_uint = 0;
pub const RTW_MODE_STA: crate::ctypes::c_uint = 1;
pub const RTW_MODE_AP: crate::ctypes::c_uint = 2;
pub const RTW_MODE_STA_AP: crate::ctypes::c_uint = 3;
pub const RTW_MODE_PROMISC: crate::ctypes::c_uint = 4;
pub const RTW_MODE_P2P: crate::ctypes::c_uint = 5;
pub type _bindgen_ty_11 = crate::ctypes::c_uint;
pub type rtw_mode_t = crate::ctypes::c_ulong;
pub const RTW_SCAN_FULL: crate::ctypes::c_uint = 0;
pub const RTW_SCAN_SOCIAL: crate::ctypes::c_uint = 1;
pub const RTW_SCAN_ONE: crate::ctypes::c_uint = 2;
pub type _bindgen_ty_12 = crate::ctypes::c_uint;
pub type rtw_scan_mode_t = crate::ctypes::c_ulong;
pub const RTW_AUTORECONNECT_DISABLE: rtw_autoreconnect_mode_t = 0;
pub const RTW_AUTORECONNECT_FINITE: rtw_autoreconnect_mode_t = 1;
pub const RTW_AUTORECONNECT_INFINITE: rtw_autoreconnect_mode_t = 2;
pub type rtw_autoreconnect_mode_t = crate::ctypes::c_uint;
pub const RTW_LINK_DISCONNECTED: crate::ctypes::c_uint = 0;
pub const RTW_LINK_CONNECTED: crate::ctypes::c_uint = 1;
pub type _bindgen_ty_13 = crate::ctypes::c_uint;
pub type rtw_link_status_t = crate::ctypes::c_ulong;
pub const RTW_SCAN_TYPE_ACTIVE: crate::ctypes::c_uint = 0;
pub const RTW_SCAN_TYPE_PASSIVE: crate::ctypes::c_uint = 1;
pub type _bindgen_ty_14 = crate::ctypes::c_uint;
pub type rtw_scan_type_t = crate::ctypes::c_ulong;
pub const RTW_BSS_TYPE_INFRASTRUCTURE: crate::ctypes::c_int = 0;
pub const RTW_BSS_TYPE_ADHOC: crate::ctypes::c_int = 1;
pub const RTW_BSS_TYPE_ANY: crate::ctypes::c_int = 2;
pub const RTW_BSS_TYPE_UNKNOWN: crate::ctypes::c_int = -1;
pub type _bindgen_ty_15 = crate::ctypes::c_int;
pub type rtw_bss_type_t = crate::ctypes::c_ulong;
pub const RTW_SCAN_COMMAMD: crate::ctypes::c_uint = 1;
pub type _bindgen_ty_16 = crate::ctypes::c_uint;
pub type rtw_scan_command_t = crate::ctypes::c_ulong;
pub type rtw_command_type = crate::ctypes::c_ulong;
pub const RTW_WPS_TYPE_DEFAULT: crate::ctypes::c_uint = 0;
pub const RTW_WPS_TYPE_USER_SPECIFIED: crate::ctypes::c_uint = 1;
pub const RTW_WPS_TYPE_MACHINE_SPECIFIED: crate::ctypes::c_uint = 2;
pub const RTW_WPS_TYPE_REKEY: crate::ctypes::c_uint = 3;
pub const RTW_WPS_TYPE_PUSHBUTTON: crate::ctypes::c_uint = 4;
pub const RTW_WPS_TYPE_REGISTRAR_SPECIFIED: crate::ctypes::c_uint = 5;
pub const RTW_WPS_TYPE_NONE: crate::ctypes::c_uint = 6;
pub const RTW_WPS_TYPE_WSC: crate::ctypes::c_uint = 7;
pub type _bindgen_ty_18 = crate::ctypes::c_uint;
pub type rtw_wps_type_t = crate::ctypes::c_ulong;
pub const RTW_NETWORK_B: crate::ctypes::c_uint = 1;
pub const RTW_NETWORK_BG: crate::ctypes::c_uint = 3;
pub const RTW_NETWORK_BGN: crate::ctypes::c_uint = 11;
pub type _bindgen_ty_19 = crate::ctypes::c_uint;
pub type rtw_network_mode_t = crate::ctypes::c_ulong;
pub const RTW_STA_INTERFACE: crate::ctypes::c_uint = 0;
pub const RTW_AP_INTERFACE: crate::ctypes::c_uint = 1;
pub type _bindgen_ty_20 = crate::ctypes::c_uint;
pub type rtw_interface_t = crate::ctypes::c_ulong;
pub const RTW_POSITIVE_MATCHING: crate::ctypes::c_uint = 0;
pub const RTW_NEGATIVE_MATCHING: crate::ctypes::c_uint = 1;
pub type _bindgen_ty_21 = crate::ctypes::c_uint;
pub type rtw_packet_filter_rule_t = crate::ctypes::c_ulong;
pub const RTW_PROMISC_DISABLE: crate::ctypes::c_uint = 0;
pub const RTW_PROMISC_ENABLE: crate::ctypes::c_uint = 1;
pub const RTW_PROMISC_ENABLE_1: crate::ctypes::c_uint = 2;
pub const RTW_PROMISC_ENABLE_2: crate::ctypes::c_uint = 3;
pub const RTW_PROMISC_ENABLE_3: crate::ctypes::c_uint = 4;
pub const RTW_PROMISC_ENABLE_4: crate::ctypes::c_uint = 5;
pub type _bindgen_ty_22 = crate::ctypes::c_uint;
pub type rtw_rcr_level_t = crate::ctypes::c_ulong;
pub const RTW_NO_ERROR: crate::ctypes::c_uint = 0;
pub const RTW_NONE_NETWORK: crate::ctypes::c_uint = 1;
pub const RTW_CONNECT_FAIL: crate::ctypes::c_uint = 2;
pub const RTW_WRONG_PASSWORD: crate::ctypes::c_uint = 3;
pub const RTW_4WAY_HANDSHAKE_TIMEOUT: crate::ctypes::c_uint = 4;
pub const RTW_DHCP_FAIL: crate::ctypes::c_uint = 5;
pub const RTW_UNKNOWN: crate::ctypes::c_uint = 6;
pub type _bindgen_ty_23 = crate::ctypes::c_uint;
pub type rtw_connect_error_flag_t = crate::ctypes::c_ulong;
pub const RTW_TX_PWR_PERCENTAGE_100: crate::ctypes::c_uint = 0;
pub const RTW_TX_PWR_PERCENTAGE_75: crate::ctypes::c_uint = 1;
pub const RTW_TX_PWR_PERCENTAGE_50: crate::ctypes::c_uint = 2;
pub const RTW_TX_PWR_PERCENTAGE_25: crate::ctypes::c_uint = 3;
pub const RTW_TX_PWR_PERCENTAGE_12_5: crate::ctypes::c_uint = 4;
pub type _bindgen_ty_24 = crate::ctypes::c_uint;
pub type rtw_tx_pwr_percentage_t = crate::ctypes::c_ulong;
pub type rtw_event_indicate_t = crate::ctypes::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rtw_ssid {
    pub len: crate::ctypes::c_uchar,
    pub val: [crate::ctypes::c_uchar; 33usize],
}
impl Default for rtw_ssid {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtw_ssid {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtw_ssid {{ len: {:?}, val: [...] }}", self.len)
    }
}
pub type rtw_ssid_t = rtw_ssid;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtw_mac {
    pub octet: [crate::ctypes::c_uchar; 6usize],
}
pub type rtw_mac_t = rtw_mac;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rtw_ap_info {
    pub ssid: rtw_ssid_t,
    pub security_type: rtw_security_t,
    pub password: *mut crate::ctypes::c_uchar,
    pub password_len: crate::ctypes::c_int,
    pub channel: crate::ctypes::c_int,
}
impl Default for rtw_ap_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtw_ap_info {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "rtw_ap_info {{ ssid: {:?}, security_type: {:?}, password: {:?}, password_len: {:?}, channel: {:?} }}" , self . ssid , self . security_type , self . password , self . password_len , self . channel)
    }
}
pub type rtw_ap_info_t = rtw_ap_info;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rtw_network_info {
    pub ssid: rtw_ssid_t,
    pub bssid: rtw_mac_t,
    pub security_type: rtw_security_t,
    pub password: *mut crate::ctypes::c_uchar,
    pub password_len: crate::ctypes::c_int,
    pub key_id: crate::ctypes::c_int,
}
impl Default for rtw_network_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtw_network_info {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "rtw_network_info {{ ssid: {:?}, bssid: {:?}, security_type: {:?}, password: {:?}, password_len: {:?}, key_id: {:?} }}" , self . ssid , self . bssid , self . security_type , self . password , self . password_len , self . key_id)
    }
}
pub type rtw_network_info_t = rtw_network_info;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rtw_scan_result {
    pub SSID: rtw_ssid_t,
    pub BSSID: rtw_mac_t,
    pub signal_strength: crate::ctypes::c_short,
    pub bss_type: rtw_bss_type_t,
    pub security: rtw_security_t,
    pub wps_type: rtw_wps_type_t,
    pub channel: crate::ctypes::c_uint,
    pub band: rtw_802_11_band_t,
}
impl Default for rtw_scan_result {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtw_scan_result {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "rtw_scan_result {{ SSID: {:?}, BSSID: {:?}, signal_strength: {:?}, bss_type: {:?}, security: {:?}, wps_type: {:?}, channel: {:?}, band: {:?} }}" , self . SSID , self . BSSID , self . signal_strength , self . bss_type , self . security , self . wps_type , self . channel , self . band)
    }
}
pub type rtw_scan_result_t = rtw_scan_result;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rtw_scan_handler_result {
    pub ap_details: rtw_scan_result_t,
    pub scan_complete: rtw_bool_t,
    pub user_data: *mut crate::ctypes::c_void,
}
impl Default for rtw_scan_handler_result {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtw_scan_handler_result {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "rtw_scan_handler_result {{ ap_details: {:?}, scan_complete: {:?}, user_data: {:?} }}",
            self.ap_details, self.scan_complete, self.user_data
        )
    }
}
pub type rtw_scan_handler_result_t = rtw_scan_handler_result;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rtw_wifi_setting {
    pub mode: rtw_mode_t,
    pub ssid: [crate::ctypes::c_uchar; 33usize],
    pub channel: crate::ctypes::c_uchar,
    pub security_type: rtw_security_t,
    pub password: [crate::ctypes::c_uchar; 65usize],
    pub key_idx: crate::ctypes::c_uchar,
}
impl Default for rtw_wifi_setting {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtw_wifi_setting {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "rtw_wifi_setting {{ mode: {:?}, ssid: [...], channel: {:?}, security_type: {:?}, password: [...], key_idx: {:?} }}" , self . mode , self . channel , self . security_type , self . key_idx)
    }
}
pub type rtw_wifi_setting_t = rtw_wifi_setting;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rtw_wifi_config {
    pub boot_mode: crate::ctypes::c_uint,
    pub ssid: [crate::ctypes::c_uchar; 32usize],
    pub ssid_len: crate::ctypes::c_uchar,
    pub security_type: crate::ctypes::c_uchar,
    pub password: [crate::ctypes::c_uchar; 65usize],
    pub password_len: crate::ctypes::c_uchar,
    pub channel: crate::ctypes::c_uchar,
}
impl Default for rtw_wifi_config {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtw_wifi_config {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "rtw_wifi_config {{ boot_mode: {:?}, ssid: [...], ssid_len: {:?}, security_type: {:?}, password: [...], password_len: {:?}, channel: {:?} }}" , self . boot_mode , self . ssid_len , self . security_type , self . password_len , self . channel)
    }
}
pub type rtw_wifi_config_t = rtw_wifi_config;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtw_maclist_t {
    pub count: crate::ctypes::c_uint,
    pub mac_list: [rtw_mac_t; 1usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtw_bss_info_t {
    pub version: crate::ctypes::c_uint,
    pub length: crate::ctypes::c_uint,
    pub BSSID: rtw_mac_t,
    pub beacon_period: crate::ctypes::c_ushort,
    pub capability: crate::ctypes::c_ushort,
    pub SSID_len: crate::ctypes::c_uchar,
    pub SSID: [crate::ctypes::c_uchar; 32usize],
    pub channel: crate::ctypes::c_uchar,
    pub atim_window: crate::ctypes::c_ushort,
    pub dtim_period: crate::ctypes::c_uchar,
    pub RSSI: crate::ctypes::c_short,
    pub n_cap: crate::ctypes::c_uchar,
    pub nbss_cap: crate::ctypes::c_uint,
    pub basic_mcs: [crate::ctypes::c_uchar; 16usize],
    pub ie_offset: crate::ctypes::c_ushort,
    pub ie_length: crate::ctypes::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rtw_packet_filter_pattern_t {
    pub offset: crate::ctypes::c_ushort,
    pub mask_size: crate::ctypes::c_ushort,
    pub mask: *mut crate::ctypes::c_uchar,
    pub pattern: *mut crate::ctypes::c_uchar,
}
impl Default for rtw_packet_filter_pattern_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rtw_packet_filter_info_t {
    pub filter_id: crate::ctypes::c_char,
    pub patt: rtw_packet_filter_pattern_t,
    pub rule: rtw_packet_filter_rule_t,
    pub enable: crate::ctypes::c_uchar,
}
impl Default for rtw_packet_filter_info_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rtw_mac_filter_list {
    pub node: list_head,
    pub mac_addr: [crate::ctypes::c_uchar; 6usize],
}
impl Default for rtw_mac_filter_list {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type rtw_mac_filter_list_t = rtw_mac_filter_list;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct wowlan_pattern {
    pub eth_da: [crate::ctypes::c_uchar; 6usize],
    pub eth_sa: [crate::ctypes::c_uchar; 6usize],
    pub eth_proto_type: [crate::ctypes::c_uchar; 2usize],
    pub header_len: [crate::ctypes::c_uchar; 1usize],
    pub ip_proto: [crate::ctypes::c_uchar; 1usize],
    pub ip_sa: [crate::ctypes::c_uchar; 4usize],
    pub ip_da: [crate::ctypes::c_uchar; 4usize],
    pub src_port: [crate::ctypes::c_uchar; 2usize],
    pub dest_port: [crate::ctypes::c_uchar; 2usize],
    pub mask: [crate::ctypes::c_uchar; 5usize],
}
pub type wowlan_pattern_t = wowlan_pattern;
pub type __u8 = crate::ctypes::c_uchar;
pub type __u16 = crate::ctypes::c_ushort;
pub type __s16 = crate::ctypes::c_short;
pub type __u32 = crate::ctypes::c_uint;
pub type __s32 = crate::ctypes::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sockaddr_t {
    pub sa_len: __u8,
    pub sa_family: __u8,
    pub sa_data: [crate::ctypes::c_char; 14usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct iw_param {
    pub value: __s32,
    pub fixed: __u8,
    pub disabled: __u8,
    pub flags: __u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iw_point {
    pub pointer: *mut crate::ctypes::c_void,
    pub length: __u16,
    pub flags: __u16,
}
impl Default for iw_point {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct iw_freq {
    pub m: __s32,
    pub e: __s16,
    pub i: __u8,
    pub flags: __u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct iw_quality {
    pub qual: __u8,
    pub level: __u8,
    pub noise: __u8,
    pub updated: __u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iwreq_data {
    pub name: [crate::ctypes::c_char; 16usize],
    pub essid: iw_point,
    pub nwid: iw_param,
    pub freq: iw_freq,
    pub sens: iw_param,
    pub snr: iw_param,
    pub bitrate: iw_param,
    pub txpower: iw_param,
    pub rts: iw_param,
    pub frag: iw_param,
    pub mode: __u32,
    pub retry: iw_param,
    pub encoding: iw_point,
    pub power: iw_param,
    pub qual: iw_quality,
    pub ap_addr: sockaddr_t,
    pub addr: sockaddr_t,
    pub param: iw_param,
    pub data: iw_point,
    pub passphrase: iw_point,
    _bindgen_union_align: [u64; 2usize],
}
impl Default for iwreq_data {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for iwreq_data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "iwreq_data {{ union }}")
    }
}
extern "C" {
    pub fn rltk_wlan_init(idx_wlan: crate::ctypes::c_int, mode: rtw_mode_t)
        -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rltk_wlan_deinit();
}
extern "C" {
    pub fn rltk_wlan_deinit_fastly();
}
extern "C" {
    pub fn rltk_wlan_start(idx_wlan: crate::ctypes::c_int) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rltk_wlan_statistic(idx: crate::ctypes::c_uchar);
}
extern "C" {
    pub fn rltk_wlan_running(idx: crate::ctypes::c_uchar) -> crate::ctypes::c_uchar;
}
extern "C" {
    pub fn rltk_wlan_control(
        cmd: crate::ctypes::c_ulong,
        data: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rltk_wlan_handshake_done() -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rltk_wlan_rf_on() -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rltk_wlan_rf_off() -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rltk_wlan_check_bus() -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rltk_wlan_wireless_mode(mode: crate::ctypes::c_uchar) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rltk_wlan_get_wireless_mode(pmode: *mut crate::ctypes::c_uchar) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rltk_wlan_set_wps_phase(is_trigger_wps: crate::ctypes::c_uchar) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rltk_wlan_is_connected_to_ap() -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rltk_wlan_btcoex_set_bt_state(state: crate::ctypes::c_uchar);
}
extern "C" {
    pub fn rltk_wlan_set_scan_chan_interval(interval_ms: crate::ctypes::c_ushort);
}
extern "C" {
    pub fn rltk_wlan_change_channel_plan(
        channel_plan: crate::ctypes::c_uchar,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rltk_wlan_enable_adaptivity(enable: crate::ctypes::c_uchar);
}
extern "C" {
    pub fn rltk_wlan_set_adaptivity_mode(mode: crate::ctypes::c_uchar);
}
extern "C" {
    pub fn rltk_wlan_enable_trp_tis_cert(enable: crate::ctypes::c_uchar);
}
extern "C" {
    pub fn rltk_wlan_set_tx_pwr_lmt(value: crate::ctypes::c_uchar);
}
extern "C" {
    pub fn rltk_wlan_set_tx_pwr_by_rate(value: crate::ctypes::c_uchar);
}
extern "C" {
    pub fn rltk_wlan_enable_powersave(enable: crate::ctypes::c_uchar);
}
extern "C" {
    pub fn rltk_psk_essid_set(index: crate::ctypes::c_uchar, value: crate::ctypes::c_int);
}
extern "C" {
    pub fn rltk_psk_essid_strncpy_to(
        index: crate::ctypes::c_uchar,
        src: *const crate::ctypes::c_char,
        length: crate::ctypes::c_uint,
    );
}
extern "C" {
    pub fn rltk_psk_essid_memcpy_to(
        index: crate::ctypes::c_uchar,
        src: *mut crate::ctypes::c_uchar,
    );
}
extern "C" {
    pub fn rltk_psk_essid_memcpy_from(
        index: crate::ctypes::c_uchar,
        dst: *mut crate::ctypes::c_uchar,
        length: crate::ctypes::c_uint,
    );
}
extern "C" {
    pub fn rltk_psk_essid_strcpy(index: crate::ctypes::c_uchar, dst: *mut crate::ctypes::c_uchar);
}
extern "C" {
    pub fn rltk_psk_essid_strlen() -> crate::ctypes::c_uint;
}
extern "C" {
    pub fn rltk_psk_passphrase_set(index: crate::ctypes::c_uchar, value: crate::ctypes::c_int);
}
extern "C" {
    pub fn rltk_psk_passphrase_memcpy_to(
        index: crate::ctypes::c_uchar,
        src: *mut crate::ctypes::c_uchar,
    );
}
extern "C" {
    pub fn rltk_psk_passphrase_memcpy_from(
        index: crate::ctypes::c_uchar,
        dst: *mut crate::ctypes::c_uchar,
        length: crate::ctypes::c_uint,
    );
}
extern "C" {
    pub fn rltk_psk_passphrase_get() -> *mut crate::ctypes::c_uchar;
}
extern "C" {
    pub fn rltk_psk_passphrase_strlen() -> crate::ctypes::c_uint;
}
extern "C" {
    pub fn rltk_wpa_global_PSK_set(index: crate::ctypes::c_uchar, value: crate::ctypes::c_int);
}
extern "C" {
    pub fn rltk_psk_passphrase64_memcpy_from(
        dst: *mut crate::ctypes::c_uchar,
        length: crate::ctypes::c_uint,
    );
}
extern "C" {
    pub fn rltk_psk_passphrase64_strlen() -> crate::ctypes::c_uint;
}
extern "C" {
    pub fn rltk_wpa_global_PSK_memcpy_from(
        index: crate::ctypes::c_uchar,
        dst: *mut crate::ctypes::c_uchar,
        length: crate::ctypes::c_uint,
    );
}
extern "C" {
    pub fn rltk_wpa_global_PSK_memcpy_to(
        index: crate::ctypes::c_uchar,
        src: *mut crate::ctypes::c_uchar,
    );
}
extern "C" {
    pub fn wext_get_ssid(
        ifname: *const crate::ctypes::c_char,
        ssid: *mut __u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_ssid(
        ifname: *const crate::ctypes::c_char,
        ssid: *const __u8,
        ssid_len: __u16,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_bssid(
        ifname: *const crate::ctypes::c_char,
        bssid: *const __u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_get_bssid(
        ifname: *const crate::ctypes::c_char,
        bssid: *mut __u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_auth_param(
        ifname: *const crate::ctypes::c_char,
        idx: __u16,
        value: __u32,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_mfp_support(
        ifname: *const crate::ctypes::c_char,
        value: __u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_key_ext(
        ifname: *const crate::ctypes::c_char,
        alg: __u16,
        addr: *const __u8,
        key_idx: crate::ctypes::c_int,
        set_tx: crate::ctypes::c_int,
        seq: *const __u8,
        seq_len: __u16,
        key: *mut __u8,
        key_len: __u16,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_get_enc_ext(
        ifname: *const crate::ctypes::c_char,
        alg: *mut __u16,
        key_idx: *mut __u8,
        passphrase: *mut __u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_passphrase(
        ifname: *const crate::ctypes::c_char,
        passphrase: *const __u8,
        passphrase_len: __u16,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_get_passphrase(
        ifname: *const crate::ctypes::c_char,
        passphrase: *mut __u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_mode(
        ifname: *const crate::ctypes::c_char,
        mode: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_get_mode(
        ifname: *const crate::ctypes::c_char,
        mode: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_ap_ssid(
        ifname: *const crate::ctypes::c_char,
        ssid: *const __u8,
        ssid_len: __u16,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_country(
        ifname: *const crate::ctypes::c_char,
        country_code: rtw_country_code_t,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_get_rssi(
        ifname: *const crate::ctypes::c_char,
        rssi: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_get_snr(
        ifname: *const crate::ctypes::c_char,
        snr: *mut crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_channel(ifname: *const crate::ctypes::c_char, ch: __u8)
        -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_get_channel(
        ifname: *const crate::ctypes::c_char,
        ch: *mut __u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_register_multicast_address(
        ifname: *const crate::ctypes::c_char,
        mac: *mut rtw_mac_t,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_unregister_multicast_address(
        ifname: *const crate::ctypes::c_char,
        mac: *mut rtw_mac_t,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_scan(
        ifname: *const crate::ctypes::c_char,
        buf: *mut crate::ctypes::c_char,
        buf_len: __u16,
        flags: __u16,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_get_scan(
        ifname: *const crate::ctypes::c_char,
        buf: *mut crate::ctypes::c_char,
        buf_len: __u16,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_mac_address(
        ifname: *const crate::ctypes::c_char,
        mac: *mut crate::ctypes::c_char,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_get_mac_address(
        ifname: *const crate::ctypes::c_char,
        mac: *mut crate::ctypes::c_char,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_enable_powersave(
        ifname: *const crate::ctypes::c_char,
        lps_mode: __u8,
        ips_mode: __u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_resume_powersave(ifname: *const crate::ctypes::c_char) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_disable_powersave(ifname: *const crate::ctypes::c_char) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_tdma_param(
        ifname: *const crate::ctypes::c_char,
        slot_period: __u8,
        rfon_period_len_1: __u8,
        rfon_period_len_2: __u8,
        rfon_period_len_3: __u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_lps_dtim(
        ifname: *const crate::ctypes::c_char,
        lps_dtim: __u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_get_lps_dtim(
        ifname: *const crate::ctypes::c_char,
        lps_dtim: *mut __u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_lps_thresh(
        ifname: *const crate::ctypes::c_char,
        low_thresh: __u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_beacon_mode(
        ifname: *const crate::ctypes::c_char,
        mode: __u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_lps_level(
        ifname: *const crate::ctypes::c_char,
        lps_level: __u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_get_tx_power(
        ifname: *const crate::ctypes::c_char,
        poweridx: *mut __u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_txpower(
        ifname: *const crate::ctypes::c_char,
        poweridx: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_get_associated_client_list(
        ifname: *const crate::ctypes::c_char,
        client_list_buffer: *mut crate::ctypes::c_void,
        buffer_length: __u16,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_get_ap_info(
        ifname: *const crate::ctypes::c_char,
        ap_info: *mut rtw_bss_info_t,
        security: *mut rtw_security_t,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_mp_command(
        ifname: *const crate::ctypes::c_char,
        cmd: *mut crate::ctypes::c_char,
        show_msg: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_private_command(
        ifname: *const crate::ctypes::c_char,
        cmd: *mut crate::ctypes::c_char,
        show_msg: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_private_command_with_retval(
        ifname: *const crate::ctypes::c_char,
        cmd: *mut crate::ctypes::c_char,
        ret_buf: *mut crate::ctypes::c_char,
        ret_len: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_wlan_indicate(
        cmd: crate::ctypes::c_uint,
        wrqu: *mut iwreq_data,
        extra: *mut crate::ctypes::c_char,
    );
}
extern "C" {
    pub fn wext_set_pscan_channel(
        ifname: *const crate::ctypes::c_char,
        ch: *mut __u8,
        pscan_config: *mut __u8,
        length: __u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_autoreconnect(
        ifname: *const crate::ctypes::c_char,
        mode: __u8,
        retry_times: __u8,
        timeout: __u16,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_get_autoreconnect(
        ifname: *const crate::ctypes::c_char,
        mode: *mut __u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_adaptivity(adaptivity_mode: rtw_adaptivity_mode_t) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_adaptivity_th_l2h_ini(l2h_threshold: __u8) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_trp_tis(enable: __u8) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_support_wpa3(enable: __u8) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_get_auto_chl(
        ifname: *const crate::ctypes::c_char,
        channel_set: *mut crate::ctypes::c_uchar,
        channel_num: crate::ctypes::c_uchar,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_sta_num(ap_sta_num: crate::ctypes::c_uchar) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_del_station(
        ifname: *const crate::ctypes::c_char,
        hwaddr: *mut crate::ctypes::c_uchar,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_init_mac_filter() -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_deinit_mac_filter() -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_add_mac_filter(hwaddr: *mut crate::ctypes::c_uchar) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_del_mac_filter(hwaddr: *mut crate::ctypes::c_uchar) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_indicate_mgnt(enable: crate::ctypes::c_int);
}
extern "C" {
    pub fn wext_add_custom_ie(
        ifname: *const crate::ctypes::c_char,
        cus_ie: *mut crate::ctypes::c_void,
        ie_num: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_update_custom_ie(
        ifname: *const crate::ctypes::c_char,
        cus_ie: *mut crate::ctypes::c_void,
        ie_index: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_del_custom_ie(ifname: *const crate::ctypes::c_char) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_send_mgnt(
        ifname: *const crate::ctypes::c_char,
        buf: *mut crate::ctypes::c_char,
        buf_len: __u16,
        flags: __u16,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_send_eapol(
        ifname: *const crate::ctypes::c_char,
        buf: *mut crate::ctypes::c_char,
        buf_len: __u16,
        flags: __u16,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_gen_ie(
        ifname: *const crate::ctypes::c_char,
        buf: *mut crate::ctypes::c_char,
        buf_len: __u16,
        flags: __u16,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_get_drv_ability(
        ifname: *const crate::ctypes::c_char,
        ability: *mut __u32,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_enable_forwarding(ifname: *const crate::ctypes::c_char) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_disable_forwarding(ifname: *const crate::ctypes::c_char) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_ch_deauth(
        ifname: *const crate::ctypes::c_char,
        enable: __u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_wowlan_ctrl(
        ifname: *const crate::ctypes::c_char,
        enable: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_wowlan_set_pattern(
        ifname: *const crate::ctypes::c_char,
        pattern: wowlan_pattern_t,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wext_wlan_redl_fw(ifname: *const crate::ctypes::c_char) -> crate::ctypes::c_int;
}
pub type rtw_event_handler_t = ::core::option::Option<
    unsafe extern "C" fn(
        buf: *mut crate::ctypes::c_char,
        buf_len: crate::ctypes::c_int,
        flags: crate::ctypes::c_int,
        handler_user_data: *mut crate::ctypes::c_void,
    ),
>;
extern "C" {
    pub fn init_event_callback_list();
}
extern "C" {
    pub fn wifi_indication(
        event: rtw_event_indicate_t,
        buf: *mut crate::ctypes::c_char,
        buf_len: crate::ctypes::c_int,
        flags: crate::ctypes::c_int,
    );
}
extern "C" {
    pub fn wifi_reg_event_handler(
        event_cmds: crate::ctypes::c_uint,
        handler_func: rtw_event_handler_t,
        handler_user_data: *mut crate::ctypes::c_void,
    );
}
extern "C" {
    pub fn wifi_unreg_event_handler(
        event_cmds: crate::ctypes::c_uint,
        handler_func: rtw_event_handler_t,
    );
}
pub const WL_BAND_2_4G: _WL_BAND_TYPE = 0;
pub const WL_BAND_5G: _WL_BAND_TYPE = 1;
pub const WL_BAND_2_4G_5G_BOTH: _WL_BAND_TYPE = 2;
pub const WL_BANDMAX: _WL_BAND_TYPE = 3;
pub type _WL_BAND_TYPE = crate::ctypes::c_uint;
pub use self::_WL_BAND_TYPE as WL_BAND_TYPE;
pub type rtw_scan_result_callback_t = ::core::option::Option<
    unsafe extern "C" fn(
        result_ptr: *mut *mut rtw_scan_result_t,
        user_data: *mut crate::ctypes::c_void,
    ),
>;
pub type rtw_scan_result_handler_t = ::core::option::Option<
    unsafe extern "C" fn(malloced_scan_result: *mut rtw_scan_handler_result_t) -> rtw_result_t,
>;
extern "C" {
    pub fn wifi_manager_init() -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_connect(
        ssid: *mut crate::ctypes::c_char,
        security_type: rtw_security_t,
        password: *mut crate::ctypes::c_char,
        ssid_len: crate::ctypes::c_int,
        password_len: crate::ctypes::c_int,
        key_id: crate::ctypes::c_int,
        semaphore: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_connect_bssid(
        bssid: *mut crate::ctypes::c_uchar,
        ssid: *mut crate::ctypes::c_char,
        security_type: rtw_security_t,
        password: *mut crate::ctypes::c_char,
        bssid_len: crate::ctypes::c_int,
        ssid_len: crate::ctypes::c_int,
        password_len: crate::ctypes::c_int,
        key_id: crate::ctypes::c_int,
        semaphore: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_disconnect() -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_is_connected_to_ap() -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_is_up(interface: rtw_interface_t) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_is_ready_to_transceive(interface: rtw_interface_t) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_set_mac_address(mac: *mut crate::ctypes::c_char) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_get_mac_address(mac: *mut crate::ctypes::c_char) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_enable_powersave() -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_resume_powersave() -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_disable_powersave() -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_get_txpower(poweridx: *mut crate::ctypes::c_int) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_set_txpower(poweridx: crate::ctypes::c_int) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_get_associated_client_list(
        client_list_buffer: *mut crate::ctypes::c_void,
        buffer_length: crate::ctypes::c_ushort,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_get_ap_bssid(bssid: *mut crate::ctypes::c_uchar) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_get_ap_info(
        ap_info: *mut rtw_bss_info_t,
        security: *mut rtw_security_t,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_set_country(country_code: rtw_country_code_t) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_get_sta_max_data_rate(inidata_rate: *mut __u8) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_get_rssi(pRSSI: *mut crate::ctypes::c_int) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_get_snr(pSNR: *mut crate::ctypes::c_int) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_set_channel(channel: crate::ctypes::c_int) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_get_channel(channel: *mut crate::ctypes::c_int) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_change_channel_plan(channel_plan: u8) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_register_multicast_address(mac: *mut rtw_mac_t) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_unregister_multicast_address(mac: *mut rtw_mac_t) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_set_mib();
}
extern "C" {
    pub fn wifi_set_country_code();
}
extern "C" {
    pub fn wifi_rf_on() -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_rf_off() -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_on(mode: rtw_mode_t) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_off() -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_set_mode(mode: rtw_mode_t) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_off_fastly() -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_set_power_mode(
        ips_mode: crate::ctypes::c_uchar,
        lps_mode: crate::ctypes::c_uchar,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_set_tdma_param(
        slot_period: crate::ctypes::c_uchar,
        rfon_period_len_1: crate::ctypes::c_uchar,
        rfon_period_len_2: crate::ctypes::c_uchar,
        rfon_period_len_3: crate::ctypes::c_uchar,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_set_lps_dtim(dtim: crate::ctypes::c_uchar) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_get_lps_dtim(dtim: *mut crate::ctypes::c_uchar) -> crate::ctypes::c_int;
}
pub type rtw_lps_thresh_t = crate::ctypes::c_uchar;
extern "C" {
    pub fn wifi_set_lps_thresh(mode: rtw_lps_thresh_t) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_set_lps_level(lps_level: crate::ctypes::c_uchar) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_set_mfp_support(value: crate::ctypes::c_uchar) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_start_ap(
        ssid: *mut crate::ctypes::c_char,
        security_type: rtw_security_t,
        password: *mut crate::ctypes::c_char,
        ssid_len: crate::ctypes::c_int,
        password_len: crate::ctypes::c_int,
        channel: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_start_ap_with_hidden_ssid(
        ssid: *mut crate::ctypes::c_char,
        security_type: rtw_security_t,
        password: *mut crate::ctypes::c_char,
        ssid_len: crate::ctypes::c_int,
        password_len: crate::ctypes::c_int,
        channel: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_scan(
        scan_type: rtw_scan_type_t,
        bss_type: rtw_bss_type_t,
        result_ptr: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_scan_networks(
        results_handler: rtw_scan_result_handler_t,
        user_data: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_scan_networks_mcc(
        results_handler: rtw_scan_result_handler_t,
        user_data: *mut crate::ctypes::c_void,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_scan_networks_with_ssid(
        results_handler: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::ctypes::c_char,
                arg2: crate::ctypes::c_int,
                arg3: *mut crate::ctypes::c_char,
                arg4: *mut crate::ctypes::c_void,
            ) -> crate::ctypes::c_int,
        >,
        user_data: *mut crate::ctypes::c_void,
        scan_buflen: crate::ctypes::c_int,
        ssid: *mut crate::ctypes::c_char,
        ssid_len: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_set_pscan_chan(
        channel_list: *mut __u8,
        pscan_config: *mut __u8,
        length: __u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_get_setting(
        ifname: *const crate::ctypes::c_char,
        pSetting: *mut rtw_wifi_setting_t,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_show_setting(
        ifname: *const crate::ctypes::c_char,
        pSetting: *mut rtw_wifi_setting_t,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_set_network_mode(mode: rtw_network_mode_t) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_get_network_mode(pmode: *mut rtw_network_mode_t) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_set_promisc(
        enabled: rtw_rcr_level_t,
        callback: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::ctypes::c_uchar,
                arg2: crate::ctypes::c_uint,
                arg3: *mut crate::ctypes::c_void,
            ),
        >,
        len_used: crate::ctypes::c_uchar,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_enter_promisc_mode();
}
extern "C" {
    pub fn wifi_set_wps_phase(is_trigger_wps: crate::ctypes::c_uchar) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_restart_ap(
        ssid: *mut crate::ctypes::c_uchar,
        security_type: rtw_security_t,
        password: *mut crate::ctypes::c_uchar,
        ssid_len: crate::ctypes::c_int,
        password_len: crate::ctypes::c_int,
        channel: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_config_autoreconnect(
        mode: __u8,
        retry_times: __u8,
        timeout: __u16,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_set_autoreconnect(mode: __u8) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_get_autoreconnect(mode: *mut __u8) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_get_last_error() -> crate::ctypes::c_int;
}
pub type rtw_custom_ie_type_t = __u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cus_ie {
    pub ie: *mut __u8,
    pub type_: __u8,
}
impl Default for _cus_ie {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type rtw_custom_ie_t = _cus_ie;
extern "C" {
    pub fn wifi_add_custom_ie(
        cus_ie: *mut crate::ctypes::c_void,
        ie_num: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_update_custom_ie(
        cus_ie: *mut crate::ctypes::c_void,
        ie_index: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_del_custom_ie() -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_init_packet_filter();
}
extern "C" {
    pub fn wifi_add_packet_filter(
        filter_id: crate::ctypes::c_uchar,
        patt: *mut rtw_packet_filter_pattern_t,
        rule: rtw_packet_filter_rule_t,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_enable_packet_filter(filter_id: crate::ctypes::c_uchar) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_disable_packet_filter(filter_id: crate::ctypes::c_uchar) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_remove_packet_filter(filter_id: crate::ctypes::c_uchar) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_retransmit_packet_filter(
        enable: u8,
        filter_interval_ms: u8,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_filter_by_ap_and_phone_mac(
        enable: u8,
        ap_mac: *mut crate::ctypes::c_void,
        phone_mac: *mut crate::ctypes::c_void,
    );
}
extern "C" {
    pub fn wifi_promisc_ctrl_packet_rpt(enable: u8) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_get_antenna_info(antenna: *mut crate::ctypes::c_uchar) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_set_indicate_mgnt(enable: crate::ctypes::c_int);
}
extern "C" {
    pub fn wifi_get_drv_ability(ability: *mut u32) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_set_channel_plan(channel_plan: u8) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_get_channel_plan(channel_plan: *mut u8) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_enable_forwarding() -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_disable_forwarding() -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_set_ch_deauth(enable: __u8) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_set_ap_polling_sta(enabled: __u8);
}
extern "C" {
    pub fn wifi_wowlan_ctrl(enable: crate::ctypes::c_int) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_wowlan_set_pattern(pattern: wowlan_pattern_t) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn wifi_get_band_type() -> WL_BAND_TYPE;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_buff_head {
    pub next: *mut list_head,
    pub prev: *mut list_head,
    pub qlen: crate::ctypes::c_uint,
}
impl Default for sk_buff_head {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sk_buff {
    pub next: *mut sk_buff,
    pub prev: *mut sk_buff,
    pub list: *mut sk_buff_head,
    pub head: *mut crate::ctypes::c_uchar,
    pub data: *mut crate::ctypes::c_uchar,
    pub tail: *mut crate::ctypes::c_uchar,
    pub end: *mut crate::ctypes::c_uchar,
    pub dev: *mut crate::ctypes::c_void,
    pub len: crate::ctypes::c_uint,
    pub dyalloc_flag: crate::ctypes::c_int,
}
impl Default for sk_buff {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn init_skb_pool();
}
extern "C" {
    pub fn init_skb_data_pool();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct eth_drv_sg {
    pub buf: crate::ctypes::c_uint,
    pub len: crate::ctypes::c_uint,
}
extern "C" {
    pub fn rltk_wlan_check_isup(idx: crate::ctypes::c_int) -> crate::ctypes::c_uchar;
}
extern "C" {
    pub fn rltk_wlan_tx_inc(idx: crate::ctypes::c_int);
}
extern "C" {
    pub fn rltk_wlan_tx_dec(idx: crate::ctypes::c_int);
}
extern "C" {
    pub fn rltk_wlan_get_recv_skb(idx: crate::ctypes::c_int) -> *mut sk_buff;
}
extern "C" {
    pub fn rltk_wlan_alloc_skb(total_len: crate::ctypes::c_uint) -> *mut sk_buff;
}
extern "C" {
    pub fn rltk_wlan_set_netif_info(
        idx_wlan: crate::ctypes::c_int,
        dev: *mut crate::ctypes::c_void,
        dev_addr: *mut crate::ctypes::c_uchar,
    );
}
extern "C" {
    pub fn rltk_wlan_send_skb(idx: crate::ctypes::c_int, skb: *mut sk_buff);
}
extern "C" {
    pub fn rltk_wlan_send(
        idx: crate::ctypes::c_int,
        sg_list: *mut eth_drv_sg,
        sg_len: crate::ctypes::c_int,
        total_len: crate::ctypes::c_int,
    ) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn rltk_wlan_recv(
        idx: crate::ctypes::c_int,
        sg_list: *mut eth_drv_sg,
        sg_len: crate::ctypes::c_int,
    );
}
extern "C" {
    pub fn rltk_wlan_get_ip(idx: crate::ctypes::c_int) -> *mut crate::ctypes::c_uchar;
}
extern "C" {
    pub fn sys_now() -> crate::ctypes::c_uint;
}
pub type u8_t = crate::ctypes::c_uchar;
pub type s8_t = crate::ctypes::c_schar;
pub type u16_t = crate::ctypes::c_ushort;
pub type u32_t = crate::ctypes::c_uint;
pub type sys_prot_t = crate::ctypes::c_int;
pub type err_t = s8_t;
pub type sys_sem_t = SemaphoreHandle_t;
pub type sys_mbox_t = QueueHandle_t;
pub type sys_thread_t = TaskHandle_t;
pub type lwip_thread_fn =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut crate::ctypes::c_void)>;
extern "C" {
    pub fn sys_sem_new(sem: *mut sys_sem_t, count: u8_t) -> err_t;
}
extern "C" {
    pub fn sys_sem_signal(sem: *mut sys_sem_t);
}
extern "C" {
    pub fn sys_arch_sem_wait(sem: *mut sys_sem_t, timeout: u32_t) -> u32_t;
}
extern "C" {
    pub fn sys_sem_free(sem: *mut sys_sem_t);
}
extern "C" {
    pub fn sys_sem_valid(sem: *mut sys_sem_t) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sys_sem_set_invalid(sem: *mut sys_sem_t);
}
extern "C" {
    pub fn sys_msleep(ms: u32_t);
}
extern "C" {
    pub fn sys_mbox_new(mbox: *mut sys_mbox_t, size: crate::ctypes::c_int) -> err_t;
}
extern "C" {
    pub fn sys_mbox_post(mbox: *mut sys_mbox_t, msg: *mut crate::ctypes::c_void);
}
extern "C" {
    pub fn sys_mbox_trypost(mbox: *mut sys_mbox_t, msg: *mut crate::ctypes::c_void) -> err_t;
}
extern "C" {
    pub fn sys_arch_mbox_fetch(
        mbox: *mut sys_mbox_t,
        msg: *mut *mut crate::ctypes::c_void,
        timeout: u32_t,
    ) -> u32_t;
}
extern "C" {
    pub fn sys_arch_mbox_tryfetch(
        mbox: *mut sys_mbox_t,
        msg: *mut *mut crate::ctypes::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn sys_mbox_free(mbox: *mut sys_mbox_t);
}
extern "C" {
    pub fn sys_mbox_valid(mbox: *mut sys_mbox_t) -> crate::ctypes::c_int;
}
extern "C" {
    pub fn sys_mbox_set_invalid(mbox: *mut sys_mbox_t);
}
extern "C" {
    pub fn sys_thread_new(
        name: *const crate::ctypes::c_char,
        thread: lwip_thread_fn,
        arg: *mut crate::ctypes::c_void,
        stacksize: crate::ctypes::c_int,
        prio: crate::ctypes::c_int,
    ) -> sys_thread_t;
}
extern "C" {
    pub fn sys_thread_new_tcm(
        name: *const crate::ctypes::c_char,
        thread: lwip_thread_fn,
        arg: *mut crate::ctypes::c_void,
        stacksize: crate::ctypes::c_int,
        prio: crate::ctypes::c_int,
    ) -> sys_thread_t;
}
extern "C" {
    pub fn sys_init();
}
extern "C" {
    pub fn sys_jiffies() -> u32_t;
}
extern "C" {
    pub fn sys_arch_protect() -> sys_prot_t;
}
extern "C" {
    pub fn sys_arch_unprotect(pval: sys_prot_t);
}
pub type sys_timeout_handler =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut crate::ctypes::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sys_timeo {
    pub next: *mut sys_timeo,
    pub time: u32_t,
    pub h: sys_timeout_handler,
    pub arg: *mut crate::ctypes::c_void,
}
impl Default for sys_timeo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn sys_timeouts_init();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sys_timeouts {
    pub next: *mut sys_timeo,
}
impl Default for sys_timeouts {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn sys_arch_timeouts() -> *mut sys_timeouts;
}
extern "C" {
    pub fn sys_timeout(msecs: u32_t, handler: sys_timeout_handler, arg: *mut crate::ctypes::c_void);
}
extern "C" {
    pub fn sys_untimeout(handler: sys_timeout_handler, arg: *mut crate::ctypes::c_void);
}
extern "C" {
    pub fn sys_restart_timeouts();
}
extern "C" {
    pub fn sys_timeouts_mbox_fetch(mbox: *mut sys_mbox_t, msg: *mut *mut crate::ctypes::c_void);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ip4_addr {
    pub addr: u32_t,
}
pub type ip4_addr_t = ip4_addr;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ip4_addr2 {
    pub addrw: [u16_t; 2usize],
}
extern "C" {
    pub fn wifi_rx_beacon_hdl(
        buf: *mut crate::ctypes::c_char,
        buf_len: crate::ctypes::c_int,
        flags: crate::ctypes::c_int,
        userdata: *mut crate::ctypes::c_void,
    );
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ip4_addr_packed {
    pub addr: u32_t,
}
pub type ip4_addr_p_t = ip4_addr_packed;
