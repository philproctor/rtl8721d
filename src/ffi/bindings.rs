/* automatically generated by rust-bindgen 0.57.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const CONFIG_RTL8721D: u32 = 1;
pub const ARM_CORE_CM4: u32 = 1;
pub const CONFIG_CHIP_A_CUT: u32 = 1;
pub const CONFIG_CPU_CLK: u32 = 1;
pub const CONFIG_CPU_200MHZ: u32 = 1;
pub const PLATFORM_CLOCK: u32 = 200000000;
pub const CPU_CLOCK_SEL_VALUE: u32 = 0;
pub const CONFIG_KERNEL: u32 = 1;
pub const PLATFORM_FREERTOS: u32 = 1;
pub const TASK_SCHEDULER_DISABLED: u32 = 0;
pub const CONFIG_SOC_PS_EN: u32 = 1;
pub const CONFIG_SOC_PS_MODULE: u32 = 1;
pub const CONFIG_SDIO_DEVICE_EN: u32 = 1;
pub const CONFIG_SDIO_DEVICE_NORMAL: u32 = 1;
pub const CONFIG_SDIO_DEVICE_MODULE: u32 = 1;
pub const CONFIG_MBED_API_EN: u32 = 1;
pub const CONFIG_WIFI_EN: u32 = 1;
pub const CONFIG_WIFI_NORMAL: u32 = 1;
pub const CONFIG_WIFI_MODULE: u32 = 1;
pub const CONFIG_NETWORK: u32 = 1;
pub const CONFIG_USE_MBEDTLS_ROM: u32 = 1;
pub const CONFIG_MBED_TLS_ENABLED: u32 = 1;
pub const CONFIG_DEBUG_LOG: u32 = 1;
pub const CONFIG_TOOLCHAIN_ASDK: u32 = 1;
pub const CONFIG_LINK_ROM_SYMB: u32 = 1;
pub const SUPPORT_LOG_SERVICE: u32 = 1;
pub const LOG_SERVICE_BUFLEN: u32 = 100;
pub const CONFIG_LOG_HISTORY: u32 = 0;
pub const CONFIG_ATCMD_MP: u32 = 1;
pub const SUPPORT_INTERACTIVE_MODE: u32 = 0;
pub const CONFIG_LOG_SERVICE_LOCK: u32 = 0;
pub const CONFIG_INTERACTIVE_MODE: u32 = 0;
pub const CONFIG_INTERACTIVE_EXT: u32 = 0;
pub const FREERTOS_PMU_TICKLESS_SUSPEND_SDRAM: u32 = 1;
pub const AP_SETTING_SECTOR: u32 = 1040384;
pub const UART_SETTING_SECTOR: u32 = 1032192;
pub const SPI_SETTING_SECTOR: u32 = 1032192;
pub const FAST_RECONNECT_DATA: u32 = 1069056;
pub const CONFIG_ENABLE_RDP: u32 = 0;
pub const CONFIG_WLAN: u32 = 1;
pub const CONFIG_LWIP_LAYER: u32 = 1;
pub const CONFIG_INIT_NET: u32 = 1;
pub const CONFIG_WIFI_IND_USE_THREAD: u32 = 1;
pub const CONFIG_SSL_CLIENT: u32 = 0;
pub const CONFIG_WEBSERVER: u32 = 0;
pub const CONFIG_OTA_UPDATE: u32 = 0;
pub const CONFIG_BSD_TCP: u32 = 1;
pub const CONFIG_AIRKISS: u32 = 0;
pub const CONFIG_UART_SOCKET: u32 = 0;
pub const CONFIG_JOYLINK: u32 = 0;
pub const CONFIG_QQ_LINK: u32 = 0;
pub const CONFIG_UART_XMODEM: u32 = 0;
pub const CONFIG_GOOGLE_NEST: u32 = 0;
pub const CONFIG_TRANSPORT: u32 = 0;
pub const CONFIG_ALINK: u32 = 0;
pub const CONFIG_HILINK: u32 = 0;
pub const CONFIG_DMIC_SEL: u32 = 0;
pub const CONFIG_ENABLE_WPS: u32 = 1;
pub const CONFIG_ENABLE_P2P: u32 = 0;
pub const CONFIG_ENABLE_WPS_DISCOVERY: u32 = 0;
pub const CONFIG_USE_POLARSSL: u32 = 0;
pub const CONFIG_USE_MBEDTLS: u32 = 1;
pub const CONFIG_SSL_CLIENT_PRIVATE_IN_TZ: u32 = 0;
pub const CONFIG_INCLUDE_SIMPLE_CONFIG: u32 = 1;
pub const CONFIG_EXAMPLE_WLAN_FAST_CONNECT: u32 = 0;
pub const CONFIG_WOWLAN_SERVICE: u32 = 0;
pub const CONFIG_GAGENT: u32 = 0;
pub const CONFIG_JOINLINK: u32 = 0;
pub const CONFIG_ETHERNET: u32 = 0;
pub const CONFIG_DYNAMIC_TICKLESS: u32 = 1;
pub const CONFIG_EXAMPLE_AMAZON_FREERTOS: u32 = 0;
pub const CONFIG_EXAMPLE_AJ_BASIC: u32 = 0;
pub const CONFIG_EXAMPLE_AJ_AMEBA_LED: u32 = 0;
pub const CONFIG_EXAMPLE_GET_BEACON_FRAME: u32 = 0;
pub const CONFIG_EXAMPLE_WIFI_MAC_MONITOR: u32 = 0;
pub const CONFIG_EXAMPLE_HTTP_CLIENT: u32 = 0;
pub const CONFIG_EXAMPLE_MQTT: u32 = 0;
pub const CONFIG_EXAMPLE_WIGADGET: u32 = 0;
pub const CONFIG_EXAMPLE_GOOGLE_NEST: u32 = 0;
pub const CONFIG_EXAMPLE_MDNS: u32 = 0;
pub const CONFIG_EXAMPLE_MCAST: u32 = 0;
pub const CONFIG_EXAMPLE_XML: u32 = 0;
pub const CONFIG_EXAMPLE_SOCKET_SELECT: u32 = 0;
pub const CONFIG_EXAMPLE_NONBLOCK_CONNECT: u32 = 0;
pub const CONFIG_EXAMPLE_SOCKET_TCP_TRX: u32 = 0;
pub const CONFIG_EXAMPLE_SSL_DOWNLOAD: u32 = 0;
pub const CONFIG_EXAMPLE_HTTP_DOWNLOAD: u32 = 0;
pub const CONFIG_EXAMPLE_OTA_HTTP: u32 = 0;
pub const CONFIG_EXAMPLE_OTA_HTTPS: u32 = 0;
pub const CONFIG_EXAMPLE_TCP_KEEPALIVE: u32 = 0;
pub const CONFIG_EXAMPLE_OTA_SDCARD: u32 = 0;
pub const CONFIG_EXAMPLE_SNTP_SHOWTIME: u32 = 0;
pub const CONFIG_EXAMPLE_PPPOE: u32 = 0;
pub const CONFIG_EXAMPLE_WEBSOCKET: u32 = 0;
pub const CONFIG_EXAMPLE_PROMISC_SOFTAP_CONFIG: u32 = 0;
pub const CONFIG_EXAMPLE_WIFI_ROAMING_PLUS: u32 = 0;
pub const CONFIG_EXAMPLE_AUDIO: u32 = 0;
pub const CONFIG_EXAMPLE_DCT: u32 = 0;
pub const CONFIG_EXAMPLE_AUDIO_MP3: u32 = 0;
pub const CONFIG_EXAMPLE_AUDIO_AMR: u32 = 0;
pub const CONFIG_EXAMPLE_AUDIO_AMR_FLASH: u32 = 0;
pub const CONFIG_EXAMPLE_AUDIO_AC3: u32 = 0;
pub const FATFS_DISK_SD: u32 = 1;
pub const CONFIG_EXAMPLE_AUDIO_HELIX_AAC: u32 = 0;
pub const CONFIG_EXAMPLE_AUDIO_HELIX_MP3: u32 = 0;
pub const CONFIG_EXAMPLE_AUDIO_PCM_UPLOAD: u32 = 0;
pub const CONFIG_EXAMPLE_AUDIO_HLS: u32 = 0;
pub const CONFIG_EXAMPLE_AUDIO_RECORDER: u32 = 0;
pub const CONFIG_EXAMPLE_AUDIO_M4A_SELFPARSE: u32 = 0;
pub const CONFIG_EXAMPLE_AUDIO_M4A: u32 = 0;
pub const CONFIG_EXAMPLE_AUDIO_FLAC: u32 = 0;
pub const AUDIO_SIGNAL_GENERATE: u32 = 0;
pub const CONFIG_EXAMPLE_EKHO: u32 = 0;
pub const CONFIG_EXAMPLE_AUDIO_TTS: u32 = 0;
pub const CONFIG_EXAMPLE_TTS_CYBERON: u32 = 0;
pub const CONFIG_EXAMPLE_AUDIO_OPUS_DECODE: u32 = 0;
pub const CONFIG_EXAMPLE_AUDIO_OPUS_ENCODE: u32 = 0;
pub const CONFIG_EXAMPLE_UART_ATCMD: u32 = 0;
pub const CONFIG_EXAMPLE_SPI_ATCMD: u32 = 0;
pub const CONFIG_EXAMPLE_MEDIA_FRAMEWORK: u32 = 0;
pub const CONFIG_EXAMPLE_MEDIA_SS: u32 = 0;
pub const CONFIG_EXAMPLE_MEDIA_MS: u32 = 0;
pub const CONFIG_EXAMPLE_MEDIA_GEO_RTP: u32 = 0;
pub const CONFIG_EXAMPLE_MJPEG_CAPTURE: u32 = 0;
pub const CONFIG_EXAMPLE_EAP: u32 = 0;
pub const CONFIG_ENABLE_PEAP: u32 = 0;
pub const CONFIG_ENABLE_TLS: u32 = 0;
pub const CONFIG_ENABLE_TTLS: u32 = 0;
pub const ENABLE_EAP_SSL_VERIFY_SERVER: u32 = 0;
pub const ENABLE_EAP_SSL_VERIFY_CLIENT: u32 = 0;
pub const CONFIG_EXAMPLE_USB_MASS_STORAGE: u32 = 0;
pub const CONFIG_EXAMPLE_USB_ISOC_DEVICE: u32 = 0;
pub const CONFIG_EXAMPLE_USB_VENDOR_SPECIFIC: u32 = 0;
pub const CONFIG_EXAMPLE_FATFS: u32 = 0;
pub const CONFIG_UART_UPDATE: u32 = 0;
pub const CONFIG_EXAMPLE_ARDUINO_WIFI: u32 = 0;
pub const CONFIG_EXAMPLE_UART_ADAPTER: u32 = 0;
pub const CONFIG_EXAMPLE_WLAN_SCENARIO: u32 = 0;
pub const CONFIG_EXAMPLE_BCAST: u32 = 0;
pub const CONFIG_EXAMPLE_HIGH_LOAD_MEMORY_USE: u32 = 0;
pub const CONFIG_EXAMPLE_RARP: u32 = 0;
pub const CONFIG_EXAMPLE_SSL_SERVER: u32 = 0;
pub const WPS_CONNECT_RETRY_COUNT: u32 = 4;
pub const WPS_CONNECT_RETRY_INTERVAL: u32 = 5000;
pub const AUTO_RECONNECT_COUNT: u32 = 8;
pub const AUTO_RECONNECT_INTERVAL: u32 = 5;
pub const CONFIG_FAST_DHCP: u32 = 0;
pub const _NEWLIB_VERSION_H__: u32 = 1;
pub const _NEWLIB_VERSION: &'static [u8; 6usize] = b"2.5.0\0";
pub const __NEWLIB__: u32 = 2;
pub const __NEWLIB_MINOR__: u32 = 5;
pub const __NEWLIB_PATCHLEVEL__: u32 = 0;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __ATFILE_VISIBLE: u32 = 1;
pub const __BSD_VISIBLE: u32 = 1;
pub const __GNU_VISIBLE: u32 = 0;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __LARGEFILE_VISIBLE: u32 = 0;
pub const __MISC_VISIBLE: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __SVID_VISIBLE: u32 = 1;
pub const __XSI_VISIBLE: u32 = 0;
pub const __have_longlong64: u32 = 1;
pub const __have_long64: u32 = 1;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const ___int_least8_t_defined: u32 = 1;
pub const ___int_least16_t_defined: u32 = 1;
pub const ___int_least32_t_defined: u32 = 1;
pub const ___int_least64_t_defined: u32 = 1;
pub const __int20: u32 = 2;
pub const __INT8: &'static [u8; 3usize] = b"hh\0";
pub const __INT16: &'static [u8; 2usize] = b"h\0";
pub const __INT64: &'static [u8; 2usize] = b"l\0";
pub const __FAST8: &'static [u8; 3usize] = b"hh\0";
pub const __FAST16: &'static [u8; 2usize] = b"h\0";
pub const __FAST64: &'static [u8; 2usize] = b"l\0";
pub const __LEAST8: &'static [u8; 3usize] = b"hh\0";
pub const __LEAST16: &'static [u8; 2usize] = b"h\0";
pub const __LEAST64: &'static [u8; 2usize] = b"l\0";
pub const __int8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const __int_least8_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const WINT_MIN: u32 = 0;
pub const __IASMARM__: u32 = 0;
pub const configENABLE_MPU: u32 = 0;
pub const configENABLE_FPU: u32 = 1;
pub const configENABLE_TRUSTZONE: u32 = 0;
pub const configRUN_FREERTOS_SECURE_ONLY: u32 = 0;
pub const configUSE_PORT_OPTIMISED_TASK_SELECTION: u32 = 0;
pub const configUSE_PREEMPTION: u32 = 1;
pub const configUSE_TIME_SLICING: u32 = 1;
pub const configMAX_PRIORITIES: u32 = 11;
pub const configIDLE_SHOULD_YIELD: u32 = 0;
pub const configUSE_16_BIT_TICKS: u32 = 0;
pub const configMINIMAL_SECURE_STACK_SIZE: u32 = 1024;
pub const configMAX_TASK_NAME_LEN: u32 = 10;
pub const configUSE_MUTEXES: u32 = 1;
pub const configUSE_APPLICATION_TASK_TAG: u32 = 0;
pub const configUSE_NEWLIB_REENTRANT: u32 = 0;
pub const configUSE_CO_ROUTINES: u32 = 1;
pub const configMAX_CO_ROUTINE_PRIORITIES: u32 = 2;
pub const configUSE_COUNTING_SEMAPHORES: u32 = 1;
pub const configUSE_RECURSIVE_MUTEXES: u32 = 1;
pub const configUSE_QUEUE_SETS: u32 = 1;
pub const configUSE_TASK_NOTIFICATIONS: u32 = 1;
pub const configUSE_TRACE_FACILITY: u32 = 1;
pub const configUSE_IDLE_HOOK: u32 = 0;
pub const configUSE_TICK_HOOK: u32 = 0;
pub const configUSE_MALLOC_FAILED_HOOK: u32 = 1;
pub const configCHECK_FOR_STACK_OVERFLOW: u32 = 2;
pub const configQUEUE_REGISTRY_SIZE: u32 = 0;
pub const configRECORD_STACK_HIGH_ADDRESS: u32 = 1;
pub const configUSE_TIMERS: u32 = 0;
pub const configTIMER_TASK_PRIORITY: u32 = 1;
pub const configTIMER_QUEUE_LENGTH: u32 = 10;
pub const configTIMER_TASK_STACK_DEPTH: u32 = 512;
pub const INCLUDE_vTaskPrioritySet: u32 = 1;
pub const INCLUDE_uxTaskPriorityGet: u32 = 1;
pub const INCLUDE_vTaskDelete: u32 = 1;
pub const INCLUDE_vTaskCleanUpResources: u32 = 0;
pub const INCLUDE_vTaskSuspend: u32 = 1;
pub const INCLUDE_vTaskDelayUntil: u32 = 1;
pub const INCLUDE_vTaskDelay: u32 = 1;
pub const INCLUDE_pcTaskGetTaskName: u32 = 1;
pub const INCLUDE_uxTaskGetStackHighWaterMark: u32 = 0;
pub const INCLUDE_xTaskGetIdleTaskHandle: u32 = 0;
pub const INCLUDE_eTaskGetState: u32 = 1;
pub const INCLUDE_xTaskResumeFromISR: u32 = 0;
pub const INCLUDE_xTaskGetCurrentTaskHandle: u32 = 1;
pub const INCLUDE_xTaskGetSchedulerState: u32 = 0;
pub const INCLUDE_xSemaphoreGetMutexHolder: u32 = 0;
pub const INCLUDE_xTimerPendFunctionCall: u32 = 1;
pub const configUSE_STATS_FORMATTING_FUNCTIONS: u32 = 1;
pub const configCOMMAND_INT_MAX_OUTPUT_SIZE: u32 = 2048;
pub const configPRIO_BITS: u32 = 3;
pub const configLIBRARY_LOWEST_INTERRUPT_PRIORITY: u32 = 7;
pub const configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY: u32 = 5;
pub const configKERNEL_INTERRUPT_PRIORITY: u32 = 224;
pub const configMAX_SYSCALL_INTERRUPT_PRIORITY: u32 = 160;
pub const configGENERATE_RUN_TIME_STATS: u32 = 0;
pub const PRIORITIE_OFFSET: u32 = 4;
pub const configUSE_TICKLESS_IDLE: u32 = 1;
pub const configEXPECTED_IDLE_TIME_BEFORE_SLEEP: u32 = 2;
pub const configUSE_WAKELOCK_PMU: u32 = 1;
pub const errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY: i32 = -1;
pub const errQUEUE_BLOCKED: i32 = -4;
pub const errQUEUE_YIELD: i32 = -5;
pub const configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES: u32 = 0;
pub const pdINTEGRITY_CHECK_VALUE: u32 = 1515870810;
pub const pdFREERTOS_ERRNO_NONE: u32 = 0;
pub const pdFREERTOS_ERRNO_ENOENT: u32 = 2;
pub const pdFREERTOS_ERRNO_EINTR: u32 = 4;
pub const pdFREERTOS_ERRNO_EIO: u32 = 5;
pub const pdFREERTOS_ERRNO_ENXIO: u32 = 6;
pub const pdFREERTOS_ERRNO_EBADF: u32 = 9;
pub const pdFREERTOS_ERRNO_EAGAIN: u32 = 11;
pub const pdFREERTOS_ERRNO_EWOULDBLOCK: u32 = 11;
pub const pdFREERTOS_ERRNO_ENOMEM: u32 = 12;
pub const pdFREERTOS_ERRNO_EACCES: u32 = 13;
pub const pdFREERTOS_ERRNO_EFAULT: u32 = 14;
pub const pdFREERTOS_ERRNO_EBUSY: u32 = 16;
pub const pdFREERTOS_ERRNO_EEXIST: u32 = 17;
pub const pdFREERTOS_ERRNO_EXDEV: u32 = 18;
pub const pdFREERTOS_ERRNO_ENODEV: u32 = 19;
pub const pdFREERTOS_ERRNO_ENOTDIR: u32 = 20;
pub const pdFREERTOS_ERRNO_EISDIR: u32 = 21;
pub const pdFREERTOS_ERRNO_EINVAL: u32 = 22;
pub const pdFREERTOS_ERRNO_ENOSPC: u32 = 28;
pub const pdFREERTOS_ERRNO_ESPIPE: u32 = 29;
pub const pdFREERTOS_ERRNO_EROFS: u32 = 30;
pub const pdFREERTOS_ERRNO_EUNATCH: u32 = 42;
pub const pdFREERTOS_ERRNO_EBADE: u32 = 50;
pub const pdFREERTOS_ERRNO_EFTYPE: u32 = 79;
pub const pdFREERTOS_ERRNO_ENMFILE: u32 = 89;
pub const pdFREERTOS_ERRNO_ENOTEMPTY: u32 = 90;
pub const pdFREERTOS_ERRNO_ENAMETOOLONG: u32 = 91;
pub const pdFREERTOS_ERRNO_EOPNOTSUPP: u32 = 95;
pub const pdFREERTOS_ERRNO_ENOBUFS: u32 = 105;
pub const pdFREERTOS_ERRNO_ENOPROTOOPT: u32 = 109;
pub const pdFREERTOS_ERRNO_EADDRINUSE: u32 = 112;
pub const pdFREERTOS_ERRNO_ETIMEDOUT: u32 = 116;
pub const pdFREERTOS_ERRNO_EINPROGRESS: u32 = 119;
pub const pdFREERTOS_ERRNO_EALREADY: u32 = 120;
pub const pdFREERTOS_ERRNO_EADDRNOTAVAIL: u32 = 125;
pub const pdFREERTOS_ERRNO_EISCONN: u32 = 127;
pub const pdFREERTOS_ERRNO_ENOTCONN: u32 = 128;
pub const pdFREERTOS_ERRNO_ENOMEDIUM: u32 = 135;
pub const pdFREERTOS_ERRNO_EILSEQ: u32 = 138;
pub const pdFREERTOS_ERRNO_ECANCELED: u32 = 140;
pub const pdFREERTOS_LITTLE_ENDIAN: u32 = 0;
pub const pdFREERTOS_BIG_ENDIAN: u32 = 1;
pub const pdLITTLE_ENDIAN: u32 = 0;
pub const pdBIG_ENDIAN: u32 = 1;
pub const portTICK_TYPE_IS_ATOMIC: u32 = 1;
pub const portSTACK_GROWTH: i32 = -1;
pub const portBYTE_ALIGNMENT: u32 = 8;
pub const portHAS_STACK_OVERFLOW_CHECKING: u32 = 1;
pub const portPRIVILEGE_BIT: u32 = 0;
pub const portPRIVILEGED_FLASH_REGION: u32 = 0;
pub const portUNPRIVILEGED_FLASH_REGION: u32 = 1;
pub const portPRIVILEGED_RAM_REGION: u32 = 2;
pub const portUNPRIVILEGED_DEVICE_REGION: u32 = 3;
pub const portSTACK_REGION: u32 = 4;
pub const portFIRST_CONFIGURABLE_REGION: u32 = 5;
pub const portLAST_CONFIGURABLE_REGION: u32 = 7;
pub const portNUM_CONFIGURABLE_REGIONS: u32 = 3;
pub const portTOTAL_NUM_REGIONS: u32 = 4;
pub const portDEVICE_REGION_START_ADDRESS: u32 = 1342177280;
pub const portDEVICE_REGION_END_ADDRESS: u32 = 1610612735;
pub const portMPU_DEVICE_MEMORY_nGnRnE: u32 = 0;
pub const portMPU_DEVICE_MEMORY_nGnRE: u32 = 4;
pub const portMPU_DEVICE_MEMORY_nGRE: u32 = 8;
pub const portMPU_DEVICE_MEMORY_GRE: u32 = 12;
pub const portMPU_NORMAL_MEMORY_NON_CACHEABLE: u32 = 68;
pub const portMPU_NORMAL_MEMORY_BUFFERABLE_CACHEABLE: u32 = 255;
pub const portMPU_REGION_NON_SHAREABLE: u32 = 0;
pub const portMPU_REGION_INNER_SHAREABLE: u32 = 8;
pub const portMPU_REGION_OUTER_SHAREABLE: u32 = 16;
pub const portMPU_REGION_PRIVILEGED_READ_WRITE: u32 = 0;
pub const portMPU_REGION_READ_WRITE: u32 = 2;
pub const portMPU_REGION_PRIVILEGED_READ_ONLY: u32 = 4;
pub const portMPU_REGION_READ_ONLY: u32 = 6;
pub const portMPU_REGION_EXECUTE_NEVER: u32 = 1;
pub const portSVC_ALLOCATE_SECURE_CONTEXT: u32 = 0;
pub const portSVC_FREE_SECURE_CONTEXT: u32 = 1;
pub const portSVC_START_SCHEDULER: u32 = 2;
pub const portSVC_RAISE_PRIVILEGE: u32 = 3;
pub const portNVIC_PENDSVSET_BIT: u32 = 268435456;
pub const portBYTE_ALIGNMENT_MASK: u32 = 7;
pub const portUSING_MPU_WRAPPERS: u32 = 0;
pub const INCLUDE_xTaskAbortDelay: u32 = 0;
pub const INCLUDE_xQueueGetMutexHolder: u32 = 0;
pub const INCLUDE_xTaskGetHandle: u32 = 0;
pub const INCLUDE_uxTaskGetStackHighWaterMark2: u32 = 0;
pub const configUSE_DAEMON_TASK_STARTUP_HOOK: u32 = 0;
pub const configNUM_THREAD_LOCAL_STORAGE_POINTERS: u32 = 0;
pub const configUSE_ALTERNATIVE_API: u32 = 0;
pub const portCRITICAL_NESTING_IN_TCB: u32 = 0;
pub const configASSERT_DEFINED: u32 = 0;
pub const configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H: u32 = 0;
pub const configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS: u32 = 0;
pub const configAPPLICATION_ALLOCATED_HEAP: u32 = 0;
pub const configUSE_POSIX_ERRNO: u32 = 0;
pub const configSUPPORT_STATIC_ALLOCATION: u32 = 0;
pub const configSUPPORT_DYNAMIC_ALLOCATION: u32 = 1;
pub const configINITIAL_TICK_COUNT: u32 = 0;
pub const configENABLE_BACKWARD_COMPATIBILITY: u32 = 1;
pub const configUSE_TASK_FPU_SUPPORT: u32 = 1;
pub const DEVICE_PORTIN: u32 = 1;
pub const DEVICE_PORTOUT: u32 = 1;
pub const DEVICE_PORTINOUT: u32 = 1;
pub const DEVICE_INTERRUPTIN: u32 = 1;
pub const DEVICE_ANALOGIN: u32 = 1;
pub const DEVICE_ANALOGOUT: u32 = 0;
pub const DEVICE_SERIAL: u32 = 1;
pub const DEVICE_I2C: u32 = 1;
pub const DEVICE_I2CSLAVE: u32 = 1;
pub const DEVICE_SPI: u32 = 1;
pub const DEVICE_SPISLAVE: u32 = 1;
pub const DEVICE_CAN: u32 = 0;
pub const DEVICE_RTC: u32 = 1;
pub const DEVICE_ETHERNET: u32 = 0;
pub const DEVICE_PWMOUT: u32 = 1;
pub const DEVICE_SLEEP: u32 = 1;
pub const PLATFORM_LITTLE_ENDIAN: u32 = 0;
pub const PLATFORM_BIG_ENDIAN: u32 = 1;
pub const SYSTEM_ENDIAN: u32 = 0;
pub const SUCCESS: u32 = 0;
pub const FAIL: i32 = -1;
pub const _SUCCESS: u32 = 1;
pub const _FAIL: u32 = 0;
pub const FALSE: u32 = 0;
pub const _FALSE: u32 = 0;
pub const ON: u32 = 1;
pub const OFF: u32 = 0;
pub const ENABLE: u32 = 1;
pub const DISABLE: u32 = 0;
pub const BIT0: u32 = 1;
pub const BIT1: u32 = 2;
pub const BIT2: u32 = 4;
pub const BIT3: u32 = 8;
pub const BIT4: u32 = 16;
pub const BIT5: u32 = 32;
pub const BIT6: u32 = 64;
pub const BIT7: u32 = 128;
pub const BIT8: u32 = 256;
pub const BIT9: u32 = 512;
pub const BIT10: u32 = 1024;
pub const BIT11: u32 = 2048;
pub const BIT12: u32 = 4096;
pub const BIT13: u32 = 8192;
pub const BIT14: u32 = 16384;
pub const BIT15: u32 = 32768;
pub const BIT16: u32 = 65536;
pub const BIT17: u32 = 131072;
pub const BIT18: u32 = 262144;
pub const BIT19: u32 = 524288;
pub const BIT20: u32 = 1048576;
pub const BIT21: u32 = 2097152;
pub const BIT22: u32 = 4194304;
pub const BIT23: u32 = 8388608;
pub const BIT24: u32 = 16777216;
pub const BIT25: u32 = 33554432;
pub const BIT26: u32 = 67108864;
pub const BIT27: u32 = 134217728;
pub const BIT28: u32 = 268435456;
pub const BIT29: u32 = 536870912;
pub const BIT30: u32 = 1073741824;
pub const BIT31: u32 = 2147483648;
pub const REG_SYS_NORESET_FF: u32 = 312;
pub const ROMVERSION: u32 = 1;
pub const ROMVERSION_SUB: u32 = 2;
pub const ROMINFORMATION: u32 = 1;
pub const SYSTEM_CTRL_BASE: u32 = 1073741824;
pub const PERI_ON_BASE: u32 = 1073741824;
pub const VENDOR_REG_BASE: u32 = 1073752064;
pub const LP_RW_HSYSON_OFFSET: u32 = 2048;
pub const SYSTEM_CTRL_BASE_HP: u32 = 1073741824;
pub const SYSTEM_CTRL_BASE_HP_S: u32 = 1342177280;
pub const SYSTEM_CTRL_BASE_LP: u32 = 1207959552;
pub const PINMUX_REG_BASE: u32 = 1207960576;
pub const RSIP_REG_BASE: u32 = 1207961088;
pub const TIMERM4_REG_BASE: u32 = 1073750016;
pub const TIMERM0_REG_BASE: u32 = 1207967744;
pub const UART0_REG_BASE: u32 = 1073758208;
pub const UART1_REG_BASE: u32 = 1073782784;
pub const UART2_REG_BASE: u32 = 1208033280;
pub const UART3_REG_BASE: u32 = 1208016896;
pub const UARTLOG_REG_BASE: u32 = 1208033280;
pub const IPCM4_REG_BASE: u32 = 1073766400;
pub const IPCM0_REG_BASE: u32 = 1207984128;
pub const USI_REG_BASE: u32 = 1073774592;
pub const RXI300M4_REG_BASE: u32 = 1073790976;
pub const RXI300M0_REG_BASE: u32 = 1208057856;
pub const SPI1_REG_BASE: u32 = 1073799168;
pub const SPI0_REG_BASE: u32 = 1074233344;
pub const AUDIO_SI_REG_BASE: u32 = 1073807360;
pub const AUDIO_SPORT_REG_BASE: u32 = 1073809408;
pub const IR_REG_BASE: u32 = 1073815552;
pub const PSRAM_REG_BASE: u32 = 1073823744;
pub const PSRAM_BASE: u32 = 33554432;
pub const I2S0_REG_BASE: u32 = 1073872896;
pub const CRYPTO_REG_BASE: u32 = 1073881088;
pub const CRYPTOS_REG_BASE: u32 = 1342316544;
pub const SDIOH_REG_BASE: u32 = 1073897472;
pub const GDMA0_REG_BASE: u32 = 1073913856;
pub const GDMA0S_REG_BASE: u32 = 1342349312;
pub const SDIO_DEVICE_REG_BASE: u32 = 1073922048;
pub const USB_OTG_REG_BASE: u32 = 1074003968;
pub const LCDC_REG_BASE: u32 = 1074200576;
pub const WIFI_REG_BASE: u32 = 1074266112;
pub const WIFI_BB_REG_BASE: u32 = 1074276352;
pub const WIFI_RF_REG_BASE: u32 = 1074280448;
pub const SPI_FLASH_CTRL_BASE: u32 = 1208483840;
pub const SPI_FLASH_BASE: u32 = 134217728;
pub const RTC_BASE: u32 = 1207975936;
pub const CTC_REG_BASE: u32 = 1208074240;
pub const KEYSCAN_REG_BASE: u32 = 1208000512;
pub const I2C0_REG_BASE: u32 = 1208008704;
pub const GPIO_REG_BASE: u32 = 1208041472;
pub const SGPIO_REG_BASE: u32 = 1208066048;
pub const ADC_REG_BASE: u32 = 1208076288;
pub const CMP_REG_BASE: u32 = 1208077312;
pub const QDEC_REG_BASE: u32 = 1208082432;
pub const KM4_IDAU_BASE: u32 = 1342226688;
pub const BACKUP_REG_BASE: u32 = 1207960512;
pub const WDG_REG_BASE: u32 = 1073752064;
pub const RETENTION_RAM_BASE: u32 = 786432;
pub const RETENTION_RAM_SYS_OFFSET: u32 = 128;
pub const RETENTION_RAM_WIFI_FW_OFFSET: u32 = 304;
pub const RETENTION_RAM_WIFI_FW_SIZE: u32 = 720;
pub const MAX_VECTOR_TABLE_NUM: u32 = 80;
pub const MAX_PERIPHERAL_IRQ_NUM: u32 = 64;
pub const MAX_IRQ_PRIORITY_VALUE: u32 = 7;
pub const IRQ_PRIORITY_SHIFT: u32 = 1;
pub const MSP_RAM_LP: u32 = 589820;
pub const VCT_RAM_LP: u32 = 524288;
pub const MSP_RAM_HP: u32 = 268955644;
pub const MSP_RAM_HP_NS: u32 = 268455932;
pub const LOG_BUFFER_NUM: u32 = 6;
pub const LOG_BUFFER_SIZE: u32 = 512;
pub const DRIVER_PREFIX: &'static [u8; 19usize] = b"RTL8721D[Driver]: \0";
pub const UART_LOG_CMD_BUFLEN: u32 = 127;
pub const MAX_ARGV: u32 = 16;
pub const KB_ASCII_NUL: u32 = 0;
pub const KB_ASCII_BS: u32 = 8;
pub const KB_ASCII_TAB: u32 = 9;
pub const KB_ASCII_LF: u32 = 10;
pub const KB_ASCII_CR: u32 = 13;
pub const KB_ASCII_ESC: u32 = 27;
pub const KB_ASCII_SP: u32 = 32;
pub const KB_ASCII_BS_7F: u32 = 127;
pub const KB_ASCII_LBRKT: u32 = 91;
pub const KB_SPACENO_TAB: u32 = 1;
pub const AMEBA_CONSOLE_PREFIX: &'static [u8; 2usize] = b"#\0";
pub const SYSCFG_CUT_VERSION_A: u32 = 0;
pub const SYSCFG_CUT_VERSION_B: u32 = 1;
pub const SYSCFG_TRP_ICFG_STOP_IN_ROMBOOT: u32 = 2;
pub const SYSCFG_TRP_ICFG_FLASH_LOCATION: u32 = 3;
pub const SDM32K_ONE_CAL: u32 = 0;
pub const SDM32K_AUTO_CAL: u32 = 1;
pub const SDM32K_ALWAYS_CAL: u32 = 2;
pub const CLK_KM0_XTAL: u32 = 0;
pub const CLK_KM0_XTALDIV2: u32 = 1;
pub const CLK_KM0_ANA_4M: u32 = 2;
pub const CLK_KM4_200M: u32 = 0;
pub const CLK_KM4_100M: u32 = 1;
pub const CLK_KM4_50M: u32 = 2;
pub const CLK_KM4_25M: u32 = 3;
pub const CLK_KM4_XTAL: u32 = 4;
pub const PLL_I2S: u32 = 0;
pub const PLL_PCM: u32 = 1;
pub const PLL_AUTO: u32 = 0;
pub const PLL_FASTER: u32 = 1;
pub const PLL_SLOWER: u32 = 2;
pub const OSC2M_CAL_CYC_16: u32 = 0;
pub const OSC2M_CAL_CYC_32: u32 = 1;
pub const OSC2M_CAL_CYC_64: u32 = 2;
pub const OSC2M_CAL_CYC_128: u32 = 3;
pub const BIT_SYS_SYSPLL_CK_ADC_EN: u32 = 33554432;
pub const CRYPTO_MAX_DIGEST_LENGTH: u32 = 32;
pub const CRYPTO_MAX_KEY_LENGTH: u32 = 32;
pub const CRYPTO_PADSIZE: u32 = 64;
pub const CRYPTO_AUTH_PADDING: u32 = 64;
pub const CRYPTO_MD5_DIGEST_LENGTH: u32 = 16;
pub const CRYPTO_SHA1_DIGEST_LENGTH: u32 = 20;
pub const CRYPTO_SHA2_DIGEST_LENGTH: u32 = 32;
pub const AUTH_TYPE_MASK_FUNC: u32 = 3;
pub const AUTH_TYPE_MD5: u32 = 2;
pub const AUTH_TYPE_SHA1: u32 = 0;
pub const AUTH_TYPE_SHA2: u32 = 1;
pub const AUTH_TYPE_MASK_HMAC: u32 = 4;
pub const AUTH_TYPE_HMAC_MD5: u32 = 6;
pub const AUTH_TYPE_HMAC_SHA1: u32 = 4;
pub const AUTH_TYPE_HMAC_SHA2: u32 = 5;
pub const AUTH_TYPE_MASK_FUNC_ALL: u32 = 7;
pub const AUTH_TYPE_MASK_SHA2: u32 = 48;
pub const AUTH_TYPE_SHA2_224: u32 = 16;
pub const AUTH_TYPE_SHA2_256: u32 = 32;
pub const AUTH_TYPE_SHA2_224_ALL: u32 = 17;
pub const AUTH_TYPE_SHA2_256_ALL: u32 = 33;
pub const AUTH_TYPE_HMAC_SHA2_224_ALL: u32 = 21;
pub const AUTH_TYPE_HMAC_SHA2_256_ALL: u32 = 37;
pub const CIPHER_TYPE_MODE_ENCRYPT: u32 = 128;
pub const CIPHER_TYPE_MASK_FUNC: u32 = 48;
pub const CIPHER_TYPE_FUNC_DES: u32 = 0;
pub const CIPHER_TYPE_FUNC_3DES: u32 = 16;
pub const CIPHER_TYPE_FUNC_AES: u32 = 32;
pub const CIPHER_TYPE_FUNC_CHACHA: u32 = 48;
pub const CIPHER_TYPE_MASK_BLOCK: u32 = 15;
pub const CIPHER_TYPE_BLOCK_ECB: u32 = 0;
pub const CIPHER_TYPE_BLOCK_CBC: u32 = 1;
pub const CIPHER_TYPE_BLOCK_CFB: u32 = 2;
pub const CIPHER_TYPE_BLOCK_OFB: u32 = 3;
pub const CIPHER_TYPE_BLOCK_CTR: u32 = 4;
pub const CIPHER_TYPE_BLOCK_GCTR: u32 = 5;
pub const CIPHER_TYPE_BLOCK_GMAC: u32 = 6;
pub const CIPHER_TYPE_BLOCK_GHASH: u32 = 7;
pub const CIPHER_TYPE_BLOCK_GCM: u32 = 8;
pub const CIPHER_TYPE_BLOCK_CHACHA: u32 = 1;
pub const CIPHER_TYPE_DES_ECB: u32 = 0;
pub const CIPHER_TYPE_DES_CBC: u32 = 1;
pub const CIPHER_TYPE_DES_CFB: u32 = 2;
pub const CIPHER_TYPE_DES_OFB: u32 = 3;
pub const CIPHER_TYPE_DES_CTR: u32 = 4;
pub const CIPHER_TYPE_3DES_ECB: u32 = 16;
pub const CIPHER_TYPE_3DES_CBC: u32 = 17;
pub const CIPHER_TYPE_3DES_CFB: u32 = 18;
pub const CIPHER_TYPE_3DES_OFB: u32 = 19;
pub const CIPHER_TYPE_3DES_CTR: u32 = 20;
pub const CIPHER_TYPE_AES_ECB: u32 = 32;
pub const CIPHER_TYPE_AES_CBC: u32 = 33;
pub const CIPHER_TYPE_AES_CFB: u32 = 34;
pub const CIPHER_TYPE_AES_OFB: u32 = 35;
pub const CIPHER_TYPE_AES_CTR: u32 = 36;
pub const CIPHER_TYPE_AES_GCTR: u32 = 37;
pub const CIPHER_TYPE_AES_GMAC: u32 = 38;
pub const CIPHER_TYPE_AES_GHASH: u32 = 39;
pub const CIPHER_TYPE_AES_GCM: u32 = 40;
pub const CIPHER_TYPE_CHACHA_POLY1305: u32 = 48;
pub const CIPHER_TYPE_CHACHA: u32 = 49;
pub const CIPHER_TYPE_POLY1305: u32 = 51;
pub const FIFOCNT_TIMEOUT: u32 = 1048576;
pub const _ERRNO_CRYPTO_DESC_NUM_SET_OutRange: i32 = -2;
pub const _ERRNO_CRYPTO_BURST_NUM_SET_OutRange: i32 = -3;
pub const _ERRNO_CRYPTO_NULL_POINTER: i32 = -4;
pub const _ERRNO_CRYPTO_ENGINE_NOT_INIT: i32 = -5;
pub const _ERRNO_CRYPTO_ADDR_NOT_4Byte_Aligned: i32 = -6;
pub const _ERRNO_CRYPTO_KEY_OutRange: i32 = -7;
pub const _ERRNO_CRYPTO_MSG_OutRange: i32 = -8;
pub const _ERRNO_CRYPTO_IV_OutRange: i32 = -9;
pub const _ERRNO_CRYPTO_AUTH_TYPE_NOT_MATCH: i32 = -10;
pub const _ERRNO_CRYPTO_CIPHER_TYPE_NOT_MATCH: i32 = -11;
pub const _ERRNO_CRYPTO_KEY_IV_LEN_DIFF: i32 = -12;
pub const _ERRNO_CRYPTO_HASH_FINAL_NO_UPDATE: i32 = -13;
pub const OTA_INDEX_1: u32 = 0;
pub const OTA_INDEX_2: u32 = 1;
pub const BIT_WL_PMC_OFFMAC: u32 = 2;
pub const BIT_WL_APMC_ONMAC: u32 = 1;
pub const BIT_AFE_POWER_MODE_SEL: u32 = 256;
pub const BIT_SEL_LDO_RF: u32 = 4;
pub const BIT_SEL_LDO_SYN: u32 = 2;
pub const BIT_SEL_LDO_BUF: u32 = 1;
pub const BIT_USB_HOST_INT_REQ: u32 = 2147483648;
pub const BIT_USB_HOST_CMD: u32 = 520093696;
pub const BIT_EFUSE_RD_MSK_CM4: u32 = 8388608;
pub const BIT_USB_SUS_MSK_CM4: u32 = 4194304;
pub const BIT_USB_RES_MSK_CM4: u32 = 2097152;
pub const BIT_SE0_RST_MSK_CM4: u32 = 1048576;
pub const BIT_SIE_ACK_DONE_MSK_CM4: u32 = 524288;
pub const BIT_SIE_NAK_DONE_MSK_CM4: u32 = 262144;
pub const BIT_LPM_RSM_MSK_CM4: u32 = 131072;
pub const BIT_LPM_ACT_MSK_CM4: u32 = 65536;
pub const BIT_EFUSE_RD_MSK_DW8051: u32 = 128;
pub const BIT_USB_SUS_MSK_DW8051: u32 = 64;
pub const BIT_USB_RES_MSK_DW8051: u32 = 32;
pub const BIT_SE0_RST_MSK_DW8051: u32 = 16;
pub const BIT_SIE_ACK_DONE_MSK_DW8051: u32 = 8;
pub const BIT_SIE_NAK_DONE_MSK_DW8051: u32 = 4;
pub const BIT_LPM_RSM_MSK_DW8051: u32 = 2;
pub const BIT_LPM_ACT_MSK_DW8051: u32 = 1;
pub const REG_WL_PMC_CTRL: u32 = 32;
pub const REG_WL_RF_PSS: u32 = 92;
pub const REG_SYS_CFG_8710B: u32 = 240;
pub const REG_USB_INDIRECT_CTRL: u32 = 108;
pub const REG_USB_SIE_IMR: u32 = 120;
pub const REG_USB_SIE_INT: u32 = 124;
pub const REG_WL_PMC_ISR_8711B: u32 = 132;
pub const REG_USB_PWR_OPT: u32 = 136;
pub const REG_USB_HOST_RW_DATA: u32 = 156;
pub const REG_USB_HOST_RW_ADDR: u32 = 248;
pub const REG_SYS_OTF_DEC_CTRL: u32 = 728;
pub const REG_SYS_OTF_DEC_ADDR_MASK0: u32 = 732;
pub const REG_SYS_OTF_DEC_ADDR_MASK1: u32 = 740;
pub const REG_SYS_OTF_DEC_ADDR_MASK2: u32 = 744;
pub const REG_SYS_OTF_DEC_ADDR_MASK3: u32 = 748;
pub const REG_SYS_OTF_DEC_IV_EXT: u32 = 752;
pub const OTF_DEC_BIT_SHIFT_SIZE: u32 = 8;
pub const KEY_REQ_POLL_TIMES: u32 = 255;
pub const FLASH_CLK_DIV2P0: u32 = 0;
pub const FLASH_CLK_DIV2P5: u32 = 1;
pub const FLASH_CLK_DIV3P0: u32 = 2;
pub const FLASH_CLK_DIV3P5: u32 = 3;
pub const FLASH_CLK_DIV4P0: u32 = 4;
pub const SpicOneBitMode: u32 = 0;
pub const SpicDualBitMode: u32 = 1;
pub const SpicQuadBitMode: u32 = 2;
pub const EraseChip: u32 = 0;
pub const EraseBlock: u32 = 1;
pub const EraseSector: u32 = 2;
pub const WAIT_SPIC_BUSY: u32 = 0;
pub const WAIT_FLASH_BUSY: u32 = 1;
pub const WAIT_WRITE_DONE: u32 = 2;
pub const WAIT_WRITE_EN: u32 = 3;
pub const ADDR_3_BYTE: u32 = 3;
pub const ADDR_4_BYTE: u32 = 0;
pub const ADDR_3_BYTE_USER_PRM: u32 = 0;
pub const ADDR_4_BYTE_USER_PRM: u32 = 4;
pub const FLASH_CMD_WREN: u32 = 6;
pub const FLASH_CMD_WRDI: u32 = 4;
pub const FLASH_CMD_WRSR: u32 = 1;
pub const FLASH_CMD_RDID: u32 = 159;
pub const FLASH_CMD_RDSR: u32 = 5;
pub const FLASH_CMD_RDSR2: u32 = 53;
pub const FLASH_CMD_READ: u32 = 3;
pub const FLASH_CMD_FREAD: u32 = 11;
pub const FLASH_CMD_RDSFDP: u32 = 90;
pub const FLASH_CMD_RES: u32 = 171;
pub const FLASH_CMD_REMS: u32 = 144;
pub const FLASH_CMD_DREAD: u32 = 59;
pub const FLASH_CMD_SE: u32 = 32;
pub const FLASH_CMD_BE: u32 = 216;
pub const FLASH_CMD_CE: u32 = 96;
pub const FLASH_CMD_PP: u32 = 2;
pub const FLASH_CMD_DP: u32 = 185;
pub const FLASH_CMD_RDP: u32 = 171;
pub const FLASH_CMD_2READ: u32 = 187;
pub const FLASH_CMD_4READ: u32 = 235;
pub const FLASH_CMD_QREAD: u32 = 107;
pub const FLASH_CMD_4PP: u32 = 50;
pub const FLASH_CMD_FF: u32 = 255;
pub const FLASH_CMD_REMS2: u32 = 146;
pub const FLASH_CMD_REMS4: u32 = 148;
pub const FLASH_CMD_RDSCUR: u32 = 72;
pub const FLASH_CMD_WRSCUR: u32 = 66;
pub const FLASH_DM_CYCLE_2O: u32 = 8;
pub const FLASH_DM_CYCLE_2IO: u32 = 4;
pub const FLASH_DM_CYCLE_4O: u32 = 8;
pub const FLASH_DM_CYCLE_4IO: u32 = 6;
pub const FLASH_CMD_ENT_ADDR4B: u32 = 183;
pub const FLASH_CMD_EXT_ADDR4B: u32 = 233;
pub const FLASH_ID_OTHERS: u32 = 0;
pub const FLASH_ID_MXIC: u32 = 1;
pub const FLASH_ID_WINBOND: u32 = 2;
pub const FLASH_ID_MICRON: u32 = 3;
pub const FLASH_ID_EON: u32 = 4;
pub const FLASH_ID_GD: u32 = 5;
pub const FLASH_ID_BOHONG: u32 = 6;
pub const MANUFACTURER_ID_MXIC: u32 = 194;
pub const MANUFACTURER_ID_WINBOND: u32 = 239;
pub const MANUFACTURER_ID_MICRON: u32 = 32;
pub const MANUFACTURER_ID_BOHONG: u32 = 104;
pub const MANUFACTURER_ID_GD: u32 = 200;
pub const MANUFACTURER_ID_EON: u32 = 28;
pub const MANUFACTURER_ID_FM: u32 = 161;
pub const BIT_SCPOL: u32 = 128;
pub const BIT_SCPH: u32 = 64;
pub const BIT_ATCK_CMD: u32 = 2;
pub const BIT_SPIC_EN: u32 = 1;
pub const BIT_SER: u32 = 1;
pub const BIT_TXE: u32 = 32;
pub const BIT_RFF: u32 = 16;
pub const BIT_RFNE: u32 = 8;
pub const BIT_TFE: u32 = 4;
pub const BIT_TFNF: u32 = 2;
pub const BIT_BUSY: u32 = 1;
pub const BIT_TXSIM: u32 = 512;
pub const BIT_ACEIM: u32 = 256;
pub const BIT_BYEIM: u32 = 128;
pub const BIT_WBEIM: u32 = 64;
pub const BIT_FSEIM: u32 = 32;
pub const BIT_RXFIM: u32 = 16;
pub const BIT_RXOIM: u32 = 8;
pub const BIT_RXUIM: u32 = 4;
pub const BIT_TXOIM: u32 = 2;
pub const BIT_TXEIM: u32 = 1;
pub const BIT_TXSIS: u32 = 512;
pub const BIT_ACEIS: u32 = 256;
pub const BIT_BYEIS: u32 = 128;
pub const BIT_WBEIS: u32 = 64;
pub const BIT_FSEIS: u32 = 32;
pub const BIT_RXFIS: u32 = 16;
pub const BIT_RXOIS: u32 = 8;
pub const BIT_RXUIS: u32 = 4;
pub const BIT_TXOIS: u32 = 2;
pub const BIT_TXEIS: u32 = 1;
pub const BIT_ACEIR: u32 = 256;
pub const BIT_BYEIR: u32 = 128;
pub const BIT_WBEIR: u32 = 64;
pub const BIT_FSEIR: u32 = 32;
pub const BIT_RXFIR: u32 = 16;
pub const BIT_RXOIR: u32 = 8;
pub const BIT_RXUIR: u32 = 4;
pub const BIT_TXOIR: u32 = 2;
pub const BIT_TXEIR: u32 = 1;
pub const BIT_WR_SEQ: u32 = 8;
pub const BIT_WPN_DNUM: u32 = 4;
pub const BIT_WPN_SET: u32 = 2;
pub const BIT_SO_DUM: u32 = 1;
pub const BIT_CTRLR0_CH: u32 = 4096;
pub const BIT_PRM_EN: u32 = 2048;
pub const BIT_WR_BLOCKING: u32 = 512;
pub const BIT_WR_QUAD_II: u32 = 256;
pub const BIT_WR_QUAD_I: u32 = 128;
pub const BIT_WR_DUAL_II: u32 = 64;
pub const BIT_WR_DUAL_I: u32 = 32;
pub const BIT_RD_QUAD_IO: u32 = 16;
pub const BIT_RD_QUAD_O: u32 = 8;
pub const BIT_RD_DUAL_IO: u32 = 4;
pub const BIT_RD_DUAL_I: u32 = 2;
pub const BIT_FRD_SINGEL: u32 = 1;
pub const SPIC_VALID_CMD_MASK: u32 = 32767;
pub const DUAL_PRM_CYCLE_NUM: u32 = 4;
pub const QUAD_PRM_CYCLE_NUM: u32 = 2;
pub const SPIC_LOWSPEED_SAMPLE_PHASE: u32 = 1;
pub const GPIO_PuPd_KEEP: u32 = 255;
pub const IPC_INT_CHAN_SHELL_SWITCH: u32 = 0;
pub const IPC_INT_CHAN_WIFI_FW: u32 = 1;
pub const IPC_INT_CHAN_FLASHPG_REQ: u32 = 2;
pub const IPC_INT_KM4_TICKLESS_INDICATION: u32 = 3;
pub const IPC_USER_BUF_LOG_RP: u32 = 7;
pub const IPC_USER_BUF_LOG_WP: u32 = 8;
pub const IPC_SEM_INDEX_LOG: u32 = 0;
pub const BIT_PLL_SHIFT_I2S_CPC_SEL: u32 = 26;
pub const BIT_PLL_MASK_I2S_CPC_SEL: u32 = 7;
pub const BIT_PLL_SHIFT_I2SS_PS_SEL: u32 = 22;
pub const BIT_PLL_MASK_I2SS_PS_SEL: u32 = 7;
pub const BIT_PLL_SHIFT_I2S_CP_SEL: u32 = 20;
pub const BIT_PLL_MASK_I2S_CP_SEL: u32 = 3;
pub const BIT_PLL_SHIFT_I2S_RS_SEL: u32 = 17;
pub const BIT_PLL_MASK_I2S_RS_SEL: u32 = 7;
pub const BIT_PLL_SHIFT_I2S_CS_SEL: u32 = 15;
pub const BIT_PLL_MASK_I2S_CS_SEL: u32 = 3;
pub const BIT_PLL_SHIFT_I2S_R3_SEL: u32 = 12;
pub const BIT_PLL_MASK_I2S_R3_SEL: u32 = 7;
pub const BIT_PLL_SHIFT_I2S_C3_SET: u32 = 10;
pub const BIT_PLL_MASK_I2S_C3_SET: u32 = 3;
pub const BIT_PLL_SHIFT_I2S_DIV_SEL: u32 = 3;
pub const BIT_PLL_MASK_I2S_DIV_SEL: u32 = 7;
pub const BIT_PLL_SHIFT_I2S_XTAL_SEL: u32 = 28;
pub const BIT_PLL_MASK_I2S_XTAL_SEL: u32 = 15;
pub const BIT_PLL_SHIFT_I2S_FREQ_SEL: u32 = 24;
pub const BIT_PLL_MASK_I2S_FREQ_SEL: u32 = 15;
pub const BIT_PLL_SHIFT_I2S_TBASE_FREQ_SEL: u32 = 20;
pub const BIT_PLL_MASK_I2S_TBASE_FREQ_SEL: u32 = 15;
pub const BIT_PLL_SHIFT_I2S_STEP_FREQ_SEL: u32 = 16;
pub const BIT_PLL_MASK_I2S_STEP_FREQ_SEL: u32 = 15;
pub const BIT_PLL_SHIFT_I2S_BB_DBG_SEL_AFE_SDM: u32 = 11;
pub const BIT_PLL_MASK_I2S_BB_DBG_SEL_AFE_SDM: u32 = 15;
pub const BIT_PLL_SHIFT_I2S_DIVN_SDM: u32 = 5;
pub const BIT_PLL_MASK_I2S_DIVN_SDM: u32 = 63;
pub const BIT_PLL_SHIFT_I2S_SSC_STEP_SEL: u32 = 19;
pub const BIT_PLL_MASK_I2S_SSC_STEP_SEL: u32 = 8191;
pub const BIT_PLL_SHIFT_I2S_SSC_FREQ_SEL: u32 = 6;
pub const BIT_PLL_MASK_I2S_SSC_FREQ_SEL: u32 = 8191;
pub const BIT_PLL_SHIFT_I2S_SDM_FOF: u32 = 19;
pub const BIT_PLL_MASK_I2S_SDM_FOF: u32 = 8191;
pub const BIT_PLL_SHIFT_I2S_SDM_FON: u32 = 16;
pub const BIT_PLL_MASK_I2S_SDM_FON: u32 = 7;
pub const BIT_PLL_SHIFT_PCM_DIVN_SDM: u32 = 5;
pub const BIT_PLL_MASK_PCM_DIVN_SDM: u32 = 63;
pub const BIT_PLL_SHIFT_PCM_SDM_FOF: u32 = 19;
pub const BIT_PLL_MASK_PCM_SDM_FOF: u32 = 8191;
pub const BIT_PLL_SHIFT_PCM_SDM_FON: u32 = 16;
pub const BIT_PLL_MASK_PCM_SDM_FON: u32 = 7;
pub const BIT_MASK_HSYS_PSRAM_CKSL: u32 = 3;
pub const BIT_SHIFT_HSYS_PSRAM_CKSL: u32 = 27;
pub const BIT_SHIFT_HSYS_PSRAM_CKSL_100: u32 = 0;
pub const BIT_SHIFT_HSYS_PSRAM_CKSL_133: u32 = 134217728;
pub const BIT_SHIFT_HSYS_PSRAM_CKSL_200: u32 = 402653184;
pub const BIT_SHIFT_HSUART0_SCLK_SEL: u32 = 4;
pub const BIT_MASK_HSUART0_SCLK_SEL: u32 = 3;
pub const BIT_MASK_HSYS_AC_SPORT_CKSL: u32 = 3;
pub const BIT_SHIFT_HSYS_AC_SPORT_CKSL: u32 = 28;
pub const BIT_MASK_HSYS_I2S_CLKDIV: u32 = 127;
pub const BIT_SHIFT_HSYS_I2S_CLKDIV: u32 = 20;
pub const BIT_MASK_HSYS_SDH_SCK2_PHSEL: u32 = 7;
pub const BIT_SHIFT_HSYS_SDH_SCK2_PHSEL: u32 = 13;
pub const BIT_MASK_HSYS_SDH_SCK1_PHSEL: u32 = 7;
pub const BIT_SHIFT_HSYS_SDH_SCK1_PHSEL: u32 = 10;
pub const BIT_HSYS_SHIFT_SNPS_DPRAM_RM: u32 = 16;
pub const BIT_HSYS_MASK_SNPS_DPRAM_RM: u32 = 15;
pub const BIT_HSYS_SHIFT_SNPS_SPRAM_RA: u32 = 14;
pub const BIT_HSYS_MASK_SNPS_SPRAM_RA: u32 = 3;
pub const BIT_HSYS_SHIFT_SNPS_SPRAM_WA: u32 = 11;
pub const BIT_HSYS_MASK_SNPS_SPRAM_WA: u32 = 7;
pub const BIT_HSYS_SHIFT_SNPS_SPRAM_WPS: u32 = 8;
pub const BIT_HSYS_MASK_SNPS_SPRAM_WPS: u32 = 7;
pub const BIT_HSYS_SHIFT_SNPS_SPRAM_RM: u32 = 0;
pub const BIT_HSYS_MASK_SNPS_SPRAM_RM: u32 = 15;
pub const BIT_HSYS_SHIFT_SNPS_ROM_RM: u32 = 24;
pub const BIT_HSYS_MASK_SNPS_ROM_RM: u32 = 15;
pub const BIT_HSYS_SHIFT_RTK_MEM_RM: u32 = 16;
pub const BIT_HSYS_MASK_RTK_MEM_RM: u32 = 15;
pub const BIT_HSYS_SHIFT_RTK_MEM_RA: u32 = 12;
pub const BIT_HSYS_MASK_RTK_MEM_RA: u32 = 3;
pub const BIT_HSYS_SHIFT_RTK_MEM_WA: u32 = 9;
pub const BIT_HSYS_MASK_RTK_MEM_WA: u32 = 7;
pub const BIT_HSYS_SHIFT_RTK_MEM_SAW: u32 = 4;
pub const BIT_HSYS_MASK_RTK_MEM_SAW: u32 = 3;
pub const BIT_HSYS_SHIFT_RTK_MEM_WM: u32 = 0;
pub const BIT_HSYS_MASK_RTK_MEM_WM: u32 = 15;
pub const BIT_SHIFT_SEC_EF_ADDR: u32 = 8;
pub const BIT_MASK_SEC_EF_ADDR: u32 = 1023;
pub const BIT_SHIFT_SEC_EF_DATA: u32 = 0;
pub const BIT_MASK_SEC_EF_DATA: u32 = 255;
pub const REG_HS_PWR_ISO_CTRL: u32 = 0;
pub const REG_HS_PLATFORM_PARA: u32 = 12;
pub const REG_HS_RFAFE_IND_VIO1833: u32 = 32;
pub const REG_HS_PLL_I2S_CTRL0: u32 = 128;
pub const REG_HS_PLL_I2S_CTRL1: u32 = 132;
pub const REG_HS_PLL_I2S_CTRL2: u32 = 136;
pub const REG_HS_PLL_I2S_CTRL3: u32 = 140;
pub const REG_HS_PLL_PCM_CTRL0: u32 = 144;
pub const REG_HS_PLL_PCM_CTRL1: u32 = 148;
pub const REG_HS_PLL_PCM_CTRL2: u32 = 152;
pub const REG_HS_PLL_PCM_CTRL3: u32 = 156;
pub const REG_HS_PLL_TEST: u32 = 160;
pub const REG_HS_WAKE_EVENT_MSK0: u32 = 288;
pub const REG_HS_WAKE_EVENT_STATUS0: u32 = 292;
pub const REG_HS_WAKE_EVENT_MSK1: u32 = 296;
pub const REG_HS_WAKE_EVENT_STATUS1: u32 = 300;
pub const REG_HS_PERI_FUNC_CTRL1: u32 = 512;
pub const REG_HS_PERI_FUNC_CTRL2: u32 = 516;
pub const REG_HS_PERI_FUNC_CTRL3: u32 = 520;
pub const REG_HS_PERI_FUNC_CTRL4: u32 = 524;
pub const REG_HS_PERI_CLK_CTRL1: u32 = 528;
pub const REG_HS_PERI_CLK_CTRL2: u32 = 532;
pub const REG_HS_PERI_CLK_CTRL3: u32 = 536;
pub const REG_HS_BT_CTRL: u32 = 552;
pub const REG_HS_WL_CTRL: u32 = 576;
pub const REG_HS_OTG_CTRL: u32 = 580;
pub const REG_HS_SDIO_CTRL: u32 = 584;
pub const REG_HS_SPI_CTRL: u32 = 616;
pub const REG_HS_MEM_CTRL0: u32 = 768;
pub const REG_HS_MEM_CTRL1: u32 = 772;
pub const REG_HS_MEM_CTRL2: u32 = 776;
pub const REG_HS_SEC_EFUSE_CTRL0: u32 = 268437520;
pub const REG_HS_SECURE_BOOT_STA: u32 = 2048;
pub const BIT_AON_SHIFT_CK32K_CKSEL: u32 = 12;
pub const BIT_AON_MASK_CK32K_CKSEL: u32 = 3;
pub const BIT_MASK_AON_CHIP_VERSION_SW: u32 = 15;
pub const BIT_SHIFT_AON_CHIP_VERSION_SW: u32 = 8;
pub const BIT_MASK_AON_BOD_DBNC_CYC: u32 = 3;
pub const BIT_SHIFT_AON_BOD_DBNC_CYC: u32 = 5;
pub const BIT_MASK_BOD_THRESHOLD_H: u32 = 7;
pub const BIT_SHIFT_BOD_THRESHOLD_H: u32 = 23;
pub const BIT_MASK_BOD_THRESHOLD_L: u32 = 7;
pub const BIT_SHIFT_BOD_THRESHOLD_L: u32 = 20;
pub const BIT_MASK_AON_LDO_V09_ADJ: u32 = 15;
pub const BIT_SHIFT_AON_LDO_V09_ADJ: u32 = 12;
pub const BIT_MASK_LDO_PSRAM_ADJ: u32 = 15;
pub const BIT_SHIFT_LDO_PSRAM_ADJ: u32 = 17;
pub const BIT_MASK_LDO_LP_ADJ: u32 = 15;
pub const BIT_SHIFT_LDO_LP_ADJ: u32 = 10;
pub const BIT_AON_SHIFT_XTAL32K_GM_3_0: u32 = 28;
pub const BIT_AON_MASK_XTAL32K_GM_3_0: u32 = 15;
pub const BIT_AON_SHIFT_XTAL32K_CUR_REP_1_0: u32 = 26;
pub const BIT_AON_MASK_XTAL32K_CUR_REP_1_0: u32 = 3;
pub const BIT_AON_SHIFT_XTAL32K_CUR_GM_3_0: u32 = 22;
pub const BIT_AON_MASK_XTAL32K_CUR_GM_3_0: u32 = 15;
pub const BIT_AON_SHIFT_XTAL32K_CUR_GM_INI_3_0: u32 = 18;
pub const BIT_AON_MASK_XTAL32K_CUR_GM_INI_3_0: u32 = 15;
pub const BIT_AON_SHIFT_XTAL32K_CUR_MAIN_1_0: u32 = 16;
pub const BIT_AON_MASK_XTAL32K_CUR_MAIN_1_0: u32 = 3;
pub const BIT_AON_SHIFT_XTAL32K_GM_REP_2_0: u32 = 17;
pub const BIT_AON_MASK_XTAL32K_GM_REP_2_0: u32 = 7;
pub const BIT_AON_SHIFT_XTAL32K_TOK_1_0: u32 = 14;
pub const BIT_AON_MASK_XTAL32K_TOK_1_0: u32 = 3;
pub const BIT_AON_SHIFT_XTAL32K_SC_XO_5_0: u32 = 8;
pub const BIT_AON_MASK_XTAL32K_SC_XO_5_0: u32 = 63;
pub const BIT_AON_SHIFT_XTAL32K_SC_XI_5_0: u32 = 2;
pub const BIT_AON_MASK_XTAL32K_SC_XI_5_0: u32 = 63;
pub const BIT_AON_SHIFT_OSC32K_RCAL_5_0: u32 = 8;
pub const BIT_AON_MASK_OSC32K_RCAL_5_0: u32 = 63;
pub const BIT_AON_SHIFT_WAKE_TM0_TC: u32 = 0;
pub const BIT_AON_MASK_WAKE_TM0_TC: u32 = 1073741823;
pub const BIT_AON_TIMER_COUNTER: u32 = 1073741823;
pub const BIT_AON_SHIFT_WAKE_GPIO_DBNC_CYC: u32 = 8;
pub const BIT_AON_MASK_WAKE_GPIO_DBNC_CYC: u32 = 8388352;
pub const BIT_AON_SHIFT_GPIO_WAKE_EVENT: u32 = 24;
pub const BIT_AON_MASK_GPIO_WAKE_EVENT: u32 = 15;
pub const BIT_AON_SHIFT_GPIO_WAKE_PUPD_EN: u32 = 8;
pub const BIT_AON_MASK_GPIO_WAKE_PUPD_EN: u32 = 15;
pub const BIT_AON_SHIFT_GPIO_WAKE_POLARITY: u32 = 0;
pub const BIT_AON_MASK_GPIO_WAKE_POLARITY: u32 = 15;
pub const BIT_AON_SHIFT_CHIPEN_DBNC_CYC: u32 = 0;
pub const BIT_AON_MASK_CHIPEN_DBNC_CYC: u32 = 32767;
pub const BIT_LS_SHIFT_SDM_ADDR: u32 = 0;
pub const BIT_LS_MASK_SDM_ADDR: u32 = 63;
pub const BIT_AON_SHIFT_SDM_DATA: u32 = 0;
pub const BIT_AON_SHIFT_PMC_STL_LPLDO: u32 = 16;
pub const BIT_AON_MASK_PMC_STL_LPLDO: u32 = 1023;
pub const BIT_AON_SHIFT_PMC_PSW_STABLE: u32 = 0;
pub const BIT_AON_MASK_PMC_PSW_STABLE: u32 = 1023;
pub const BIT_ALL_WAKE_STS: u32 = 255;
pub const BIT_SHIFT_DLPS_BCN_SPACE: u32 = 0;
pub const BIT_MASK_DLPS_BCN_SPACE: u32 = 16777215;
pub const BIT_SHIFT_MAC_TSF_OFFSET: u32 = 16;
pub const BIT_MASK_MAC_TSF_OFFSET: u32 = 255;
pub const BIT_SHIFT_DLPS_BCN_EARLY: u32 = 0;
pub const BIT_DLPS_BCN_EARLY: u32 = 65535;
pub const BIT_SHIFT_FLASH_CLK_SEL: u32 = 9;
pub const BIT_MASK_FLASH_CLK_SEL: u32 = 3;
pub const BIT_SHIFT_FLASH_CLK_ANA4M: u32 = 0;
pub const BIT_SHIFT_FLASH_CLK_XTAL: u32 = 512;
pub const BIT_SHIFT_FLASH_CLK_PLL: u32 = 1024;
pub const BIT_SHIFT_LPCPU_CLK_SEL: u32 = 5;
pub const BIT_MASK_LPCPU_CLK_SEL: u32 = 3;
pub const BIT_SHIFT_LPUART0_SCLK_SEL: u32 = 24;
pub const BIT_MASK_LPUART0_SCLK_SEL: u32 = 3;
pub const BIT_SHIFT_LPUART1_SCLK_SEL: u32 = 26;
pub const BIT_MASK_LPUART1_SCLK_SEL: u32 = 3;
pub const BIT_SHIFT_DIV_INT: u32 = 10;
pub const BIT_MASK_FLASH_DIV_INT: u32 = 3072;
pub const BIT_SHIFT_DIV_FRAC: u32 = 9;
pub const BIT_SHIFT_FLASH_CK_PS_INT: u32 = 4;
pub const BIT_MASK_FLASH_CK_PS_INT: u32 = 112;
pub const BIT_SHIFT_LSYS_HCPU_CKSL: u32 = 25;
pub const BIT_MASK_LSYS_HCPU_CKSL: u32 = 7;
pub const SWRLDO_STABLE_0064US: u32 = 0;
pub const SWRLDO_STABLE_0128US: u32 = 268435456;
pub const SWRLDO_STABLE_0512US: u32 = 536870912;
pub const SWRLDO_STABLE_2048US: u32 = 805306368;
pub const SWRLDO_12V_1P059: u32 = 0;
pub const SWRLDO_12V_1P091: u32 = 16777216;
pub const SWRLDO_12V_1P125: u32 = 33554432;
pub const SWRLDO_12V_1P161: u32 = 50331648;
pub const SWRLDO_12V_1P200: u32 = 67108864;
pub const SWRLDO_12V_1P220: u32 = 83886080;
pub const SWRLDO_12V_1P241: u32 = 100663296;
pub const SWRLDO_12V_1P263: u32 = 117440512;
pub const SWRLDO_12V_1P286: u32 = 134217728;
pub const SWRLDO_12V_1P309: u32 = 150994944;
pub const SWRLDO_12V_1P333: u32 = 167772160;
pub const SWRLDO_12V_1P385: u32 = 184549376;
pub const SWRLDO_12V_1P440: u32 = 201326592;
pub const SWRLDO_12V_1P500: u32 = 218103808;
pub const SWRLDO_12V_1P565: u32 = 234881024;
pub const SWRLDO_12V_1P636: u32 = 251658240;
pub const LDOH_12V_0P840V: u32 = 0;
pub const LDOH_12V_0P857V: u32 = 1048576;
pub const LDOH_12V_0P875V: u32 = 2097152;
pub const LDOH_12V_0P893V: u32 = 3145728;
pub const LDOH_12V_0P913V: u32 = 4194304;
pub const LDOH_12V_0P933V: u32 = 5242880;
pub const LDOH_12V_0P955V: u32 = 6291456;
pub const LDOH_12V_0P977V: u32 = 7340032;
pub const LDOH_12V_1P024V: u32 = 8388608;
pub const LDOH_12V_1P077V: u32 = 9437184;
pub const LDOH_12V_1P135V: u32 = 10485760;
pub const LDOH_12V_1P167V: u32 = 11534336;
pub const LDOH_12V_1P200V: u32 = 12582912;
pub const LDOH_12V_1P235V: u32 = 13631488;
pub const LDOH_12V_1P272V: u32 = 14680064;
pub const LDOH_12V_1P313V: u32 = 15728640;
pub const BIT_PMC_OPT_EN_SWR_XTAL: u32 = 65536;
pub const BIT_MASK_SWR_REG_ZCDC_H: u32 = 24576;
pub const BIT_SHIFT_SWR_REG_ZCDC_H: u32 = 13;
pub const BIT_MASK_SWR_VOL_L1: u32 = 15;
pub const BIT_MASK_SWR_OCP_L1: u32 = 1792;
pub const BIT_SHIFT_SWR_OCP_L1: u32 = 8;
pub const BIT_MASK_SYS_EEROM_XTAL_FREQ_SEL: u32 = 983040;
pub const BIT_SHIFT_SYS_EEROM_XTAL_FREQ_SEL: u32 = 16;
pub const BIT_MASK_BOOT_FLASH_BAUD_SEL: u32 = 8388608;
pub const BIT_SHIFT_BOOT_FLASH_BAUD_SEL: u32 = 23;
pub const BIT_SYS_SPIC_ADDR_4BYTE_EN: u32 = 4194304;
pub const BIT_SYS_SPIC_BOOT_SPEEDUP_DIS: u32 = 2097152;
pub const BIT_SYS_DIS_BOOT_LOG_EN: u32 = 1048576;
pub const BIT_SYS_FLASH_DEEP_SLEEP_EN: u32 = 524288;
pub const BIT_SYS_FLASH_ENCRYPT_EN: u32 = 262144;
pub const BIT_SYS_RDP_EN: u32 = 131072;
pub const BIT_SYS_SWD_GP_SEL: u32 = 65536;
pub const BIT_MASK_OSC4M_FEST: u32 = 251658240;
pub const BIT_SHIFT_OSC4M_FEST: u32 = 24;
pub const BIT_SHIFT_SWR_FREQ_L_SEL: u32 = 28;
pub const BIT_MASK_SWR_FREQ_L_SEL: u32 = 15;
pub const BIT_SHIFT_SWR_R3_L1_SEL: u32 = 26;
pub const BIT_MASK_SWR_R3_L1_SEL: u32 = 3;
pub const BIT_SHIFT_SWR_R2_L1_SEL: u32 = 24;
pub const BIT_MASK_SWR_R2_L1_SEL: u32 = 3;
pub const BIT_SHIFT_SWR_R1_L1_SEL: u32 = 22;
pub const BIT_MASK_SWR_R1_L1_SEL: u32 = 3;
pub const BIT_SHIFT_SWR_C3_L1_SEL: u32 = 20;
pub const BIT_MASK_SWR_C3_L1_SEL: u32 = 3;
pub const BIT_SHIFT_SWR_C2_L1_SEL: u32 = 18;
pub const BIT_MASK_SWR_C2_L1_SEL: u32 = 3;
pub const BIT_SHIFT_SWR_C1_L1_SEL: u32 = 16;
pub const BIT_MASK_SWR_C1_L1_SEL: u32 = 3;
pub const BIT_SHIFT_SYS_SPSLDO_VOL: u32 = 17;
pub const BIT_MASK_SYS_SPSLDO_VOL: u32 = 7;
pub const BIT_SHIFT_SYS_SWR12_IN: u32 = 14;
pub const BIT_MASK_SYS_SWR12_IN: u32 = 7;
pub const BIT_SHIFT_SWR_STD_L1_SEL: u32 = 12;
pub const BIT_MASK_SWR_STD_L1_SEL: u32 = 3;
pub const BIT_SHIFT_SWR_VOL_L1_SEL: u32 = 8;
pub const BIT_MASK_SWR_VOL_L1_SEL: u32 = 15;
pub const BIT_MASK_SWR_COT_I_L: u32 = 3;
pub const BIT_SHIFT_SWR_COT_I_L: u32 = 5;
pub const BIT_SHIFT_SYS_REGU_LDOE25_ADJ: u32 = 8;
pub const BIT_MASK_SYS_REGU_LDOE25_ADJ: u32 = 15;
pub const BIT_SHIFT_PLL_BG_VOL: u32 = 4;
pub const BIT_MASK_PLL_BG_VOL: u32 = 511;
pub const BIT_SHIFT_OSC2M_IB_SEL: u32 = 24;
pub const BIT_MASK_OSC2M_IB_SEL: u32 = 15;
pub const BIT_SHIFT_OSC2M_VCM_SEL: u32 = 20;
pub const BIT_MASK_OSC2M_VCM_SEL: u32 = 15;
pub const BIT_SHIFT_OSC2M_C_SEL: u32 = 16;
pub const BIT_MASK_OSC2M_C_SEL: u32 = 15;
pub const BIT_SHIFT_OSC2M_R_SEL: u32 = 8;
pub const BIT_MASK_OSC2M_R_SEL: u32 = 255;
pub const BIT_SHIFT_DIV_SEL: u32 = 5;
pub const BIT_DIV_SEL: u32 = 16352;
pub const BIT_SHIFT_EN_CK_400M_PS: u32 = 4;
pub const BIT_EN_CK_400M_PS: u32 = 16;
pub const BIT_SHIFT_EN_CK_400M: u32 = 3;
pub const BIT_EN_CK_400M: u32 = 8;
pub const BIT_SHIFT_PHASE_SEL: u32 = 0;
pub const BIT_PHASE_SEL: u32 = 7;
pub const BIT_MASK_EFUSE_UNLOCK: u32 = 65280;
pub const BIT_SYS_EF_RWFLAG: u32 = 2147483648;
pub const BIT_MASK_SYS_EF_PGPD: u32 = 1879048192;
pub const BIT_MASK_SYS_EF_RDT: u32 = 251658240;
pub const BIT_MASK_SYS_EF_PGTS: u32 = 15728640;
pub const BIT_SYS_EF_ALDEN: u32 = 262144;
pub const BIT_SHIFT_SYS_EF_ADDR: u32 = 8;
pub const BIT_MASK_SYS_EF_ADDR: u32 = 1023;
pub const BIT_MASK_SYS_EF_DATA: u32 = 255;
pub const BIT_SYS_EF_CRES_SEL: u32 = 536870912;
pub const BIT_SYS_EF_FORCE_PGMEN: u32 = 1024;
pub const BIT_SYS_EF_CELL_SEL: u32 = 768;
pub const BIT_SYS_EF_TRPT: u32 = 128;
pub const BIT_MASK_SYS_EF_SCAN_TTHD: u32 = 127;
pub const BIT_SHIFT_LSYS_PMC_TUTIME: u32 = 16;
pub const BIT_MASK_LSYS_PMC_TUTIME: u32 = 63;
pub const BIT_LP_SHIFT_RTC_DIV_XTAL32K: u32 = 8;
pub const BIT_LP_MASK_RTC_DIV_XTAL32K: u32 = 2047;
pub const BIT_LSYS_SHIFT_UART_XTAL_DIV_FREQ: u32 = 0;
pub const BIT_LSYS_MASK_UART_XTAL_DIV_FREQ: u32 = 32767;
pub const BIT_LSYS_SHIFT_SWR_PSW_WAIT_CYC: u32 = 24;
pub const BIT_LSYS_NASK_SWR_PSW_WAIT_CYC: u32 = 255;
pub const BIT_LSYS_SHIFT_SWR_REQ_DBNC_CYC: u32 = 16;
pub const BIT_LSYS_MASK_SWR_REQ_DBNC_CYC: u32 = 255;
pub const BIT_LSYS_SHIFT_SWR_STEP1_VOL: u32 = 12;
pub const BIT_LSYS_MASK_SWR_STEP1_VOL: u32 = 15;
pub const BIT_LSYS_SHIFT_SWR_STEP2_VOL: u32 = 8;
pub const BIT_LSYS_MASK_SWR_STEP2_VOL: u32 = 15;
pub const BIT_LSYS_SHIFT_SWR_STEP3_VOL: u32 = 4;
pub const BIT_LSYS_MASK_SWR_STEP3_VOL: u32 = 15;
pub const BIT_LSYS_SHIFT_SWR_STEP4_VOL: u32 = 0;
pub const BIT_LSYS_MASK_SWR_STEP4_VOL: u32 = 15;
pub const BIT_LSYS_SHIFT_ANAIP_CTL_TUTIME: u32 = 16;
pub const BIT_LSYS_MASK_ANAIP_CTL_TUTIME: u32 = 63;
pub const BIT_LSYS_SHIFT_XTAL_BG2HPMOD_CYC: u32 = 8;
pub const BIT_LSYS_MASK_XTAL_BG2HPMOD_CYC: u32 = 255;
pub const BIT_LSYS_SHIFT_XTAL_DBNC_CYC: u32 = 0;
pub const BIT_LSYS_MASK_XTAL_DBNC_CYC: u32 = 15;
pub const BIT_LSYS_SHIFT_WAKE_GPIO_VALUE: u32 = 28;
pub const BIT_LSYS_MASK_WAKE_GPIO_VALUE: u32 = 15;
pub const BIT_LSYS_SHIFT_AC_LDO_REG: u32 = 1;
pub const BIT_LSYS_MASK_AC_LDO_REG: u32 = 127;
pub const BIT_LSYS_SHIFT_BOD_DBNC_CYC: u32 = 0;
pub const BIT_LSYS_MASK_BOD_DBNC_CYC: u32 = 32767;
pub const BIT_LSYS_SHIFT_PATCH_GRPx_INSTR3: u32 = 44;
pub const BIT_LSYS_MASK_PATCH_GRPx_INSTR3: u32 = 262143;
pub const BIT_LSYS_SHIFT_PATCH_GRPx_INSTR2: u32 = 26;
pub const BIT_LSYS_MASK_PATCH_GRPx_INSTR2: u32 = 262143;
pub const BIT_LSYS_SHIFT_PATCH_GRPx_INSTR1: u32 = 8;
pub const BIT_LSYS_MASK_PATCH_GRPx_INSTR1: u32 = 262143;
pub const BIT_LSYS_SHIFT_PATCH_GRPx_SADDR: u32 = 0;
pub const BIT_LSYS_MASK_PATCH_GRPx_SADDR: u32 = 255;
pub const BIT_SYSCFG_BD_PKG_SEL: u32 = 2147483648;
pub const BIT_SysCFG_TRP_UART_IMAGE: u32 = 1073741824;
pub const BIT_SysCFG_TRP_SPSLDO_SEL: u32 = 67108864;
pub const BIT_SysCFG_TRP_TESTMODE_EN: u32 = 33554432;
pub const BIT_MASK_SYSCFG_ALF_EN: u32 = 251658240;
pub const BIT_MASK_SYSCFG_CHIP_TYPE: u32 = 128;
pub const BIT_SHIFT_SYSCFG_VENDOR_ID: u32 = 4;
pub const BIT_SHIFT_SYSCFG_CUT_VER: u32 = 0;
pub const BIT_SHIFT_SYSCFG_TRP_ICFG: u32 = 28;
pub const BIT_BOOT_REASON_SHIFT: u32 = 16;
pub const BIT_BOOT_REASON_MASK: u32 = 63;
pub const BIT_MASK_SYSCFG_ROM_INFO: u32 = 65535;
pub const BIT_SHIFT_CAL_CLK_SEL: u32 = 24;
pub const BIT_MASK_CAL_CLK_SEL: u32 = 3;
pub const BIT_SHIFT_CAL_RPT: u32 = 0;
pub const BIT_MASK_CAL_RPT: u32 = 65535;
pub const BIT_SHIFT_OSC2M_CAL_RPT: u32 = 16;
pub const BIT_MASK_OSC2M_CAL_RPT: u32 = 65535;
pub const BIT_SHIFT_OSC2M_CAL_CYC_SEL: u32 = 12;
pub const BIT_MASK_OSC2M_CAL_CYC_SEL: u32 = 3;
pub const BIT_SHIFT_OSC2M_CAL_DLY: u32 = 8;
pub const BIT_MASK_OSC2M_CAL_DLY: u32 = 15;
pub const BIT_MASK_AUTO_CAL_MAX_ERROR: u32 = 4294967295;
pub const REG_AON_PWR_CTRL: u32 = 0;
pub const REG_AON_ISO_CTRL: u32 = 4;
pub const REG_AON_BOOT_REASON1: u32 = 12;
pub const REG_AON_LDO_CTRL0: u32 = 16;
pub const REG_AON_LDO_CTRL1: u32 = 20;
pub const REG_MEM_PMCTRL_DSLP: u32 = 28;
pub const REG_XTAL32K_CTRL0: u32 = 32;
pub const REG_XTAL32K_CTRL1: u32 = 36;
pub const REG_OSC32K_CTRL: u32 = 44;
pub const REG_AON_WAKE_TIMER0: u32 = 48;
pub const REG_AON_WAKE_TIMER0_CNT: u32 = 52;
pub const REG_AON_PAD_CTRL: u32 = 56;
pub const REG_AON_WAKE_GPIO_CTRL1: u32 = 60;
pub const REG_AON_WAKE_GPIO_CTRL2: u32 = 64;
pub const REG_AON_DBNC_CTRL: u32 = 68;
pub const REG_AON_CK32KGEN_AD: u32 = 72;
pub const REG_AON_CK32KGEN_RWD: u32 = 76;
pub const REG_AON_PMC_CTRL: u32 = 80;
pub const REG_AON_PM_OPT: u32 = 84;
pub const REG_AON_WAKE_OPT_MSK: u32 = 88;
pub const REG_AON_WAKE_OPT_STS: u32 = 92;
pub const REG_AON_SNOOZE_MSK: u32 = 96;
pub const REG_AON_SNOOZE_STS: u32 = 100;
pub const REG_AON_CHIP_PWR_DOWN_MSK: u32 = 104;
pub const REG_AON_CHIP_PWR_DOWN_STS: u32 = 108;
pub const REG_AON_TSF_BCN_CFG1: u32 = 144;
pub const REG_AON_TSF_BCN_CFG2: u32 = 148;
pub const REG_AON_TSF_CNT_LOW: u32 = 152;
pub const REG_AON_TSF_CNT_HIGH: u32 = 156;
pub const REG_AON_XTAL_CTRL: u32 = 200;
pub const REG_LP_SYSON_PMC_PATCH_REG: u32 = 336;
pub const REG_LP_PWR_ISO_CTRL: u32 = 512;
pub const REG_LP_KM0_CTRL: u32 = 516;
pub const REG_LP_FUNC_EN0: u32 = 520;
pub const REG_LP_FUNC_EN1: u32 = 524;
pub const REG_LP_CLK_CTRL0: u32 = 528;
pub const REG_LP_CLK_CTRL1: u32 = 532;
pub const REG_LP_FLASH_CTRL: u32 = 536;
pub const REG_LP_KM4_CTRL: u32 = 540;
pub const REG_SYS_EFUSE_SYSCFG0: u32 = 544;
pub const REG_SYS_EFUSE_SYSCFG1: u32 = 548;
pub const REG_SYS_EFUSE_SYSCFG2: u32 = 552;
pub const REG_SYS_EFUSE_SYSCFG3: u32 = 556;
pub const REG_SYS_EFUSE_SYSCFG4: u32 = 1504;
pub const REG_SYS_EFUSE_SYSCFG5: u32 = 1508;
pub const REG_SYS_EFUSE_SYSCFG6: u32 = 1512;
pub const REG_SYS_EFUSE_SYSCFG7: u32 = 1516;
pub const REG_SWD_PMUX_EN: u32 = 560;
pub const REG_LP_SWR_CTRL0: u32 = 576;
pub const REG_LP_SWR_CTRL1: u32 = 580;
pub const REG_LP_SWR_CTRL2: u32 = 584;
pub const REG_LP_SWR_CTRL3: u32 = 588;
pub const REG_LP_LDO_CTRL0: u32 = 592;
pub const REG_LP_XTAL_CTRL0: u32 = 608;
pub const REG_LP_XTAL_CTRL1: u32 = 612;
pub const REG_LP_XTAL_CTRL2: u32 = 616;
pub const REG_LP_XTAL_CTRL3: u32 = 620;
pub const REG_LP_XTAL_CTRL4: u32 = 624;
pub const REG_LP_XTAL_CTRL5: u32 = 628;
pub const REG_LP_XTAL_CTRL6: u32 = 632;
pub const REG_LP_SYSPLL_CTRL0: u32 = 640;
pub const REG_LP_OSC4M_CTRL: u32 = 656;
pub const REG_LP_OSC2M_CTRL: u32 = 664;
pub const REG_LP_DEBUG_REG: u32 = 672;
pub const REG_LP_PINMUX_CTRL: u32 = 676;
pub const REG_PLL_SYS_REG0: u32 = 688;
pub const REG_PLL_SYS_REG1: u32 = 692;
pub const REG_PLL_SYS_REG2: u32 = 696;
pub const REG_PLL_SYS_REG3: u32 = 700;
pub const REG_PLL_SYS_PS_REG: u32 = 704;
pub const REG_MEM_CTRL2: u32 = 728;
pub const REG_LP_EFUSE_CTRL0: u32 = 740;
pub const REG_LP_EFUSE_CTRL1: u32 = 744;
pub const REG_HS_EFUSE_CTRL1_S: u32 = 2064;
pub const REG_LP_EFUSE_TEST: u32 = 748;
pub const REG_LP_RSIP_KEY_CTRL: u32 = 752;
pub const REG_LP_DSLP_INFO_SW: u32 = 756;
pub const REG_LP_SLP_WAKE_EVENT_MSK0: u32 = 768;
pub const REG_LP_SLP_WAKE_EVENT_STATUS0: u32 = 772;
pub const REG_LP_SLP_WAKE_EVENT_MSK1: u32 = 776;
pub const REG_LP_SLP_WAKE_EVENT_STATUS1: u32 = 780;
pub const REG_LP_PWRMGT_CTRL: u32 = 792;
pub const REG_LP_PWRMGT_OPTION: u32 = 800;
pub const REG_LP_WL_INTR_CTRL: u32 = 784;
pub const REG_LP_WL_POW_CTRL: u32 = 788;
pub const REG_LP_RTC_XTAL_DIV_CTRL: u32 = 816;
pub const REG_LP_UART_XTAL_DIV_CTRL: u32 = 820;
pub const REG_SWR_PSW_CTRL: u32 = 824;
pub const REG_XMODE_SW_CTRL: u32 = 828;
pub const REG_GPIO_SHDN33_CTRL: u32 = 832;
pub const REG_AUDIO_SHARE_PAD_CTRL: u32 = 836;
pub const REG_BOD_DBNC_CTRL: u32 = 840;
pub const REG_SYSON_PMC_PATCH_GRP1_L: u32 = 848;
pub const REG_SYSON_PMC_PATCH_GRP1_H: u32 = 852;
pub const REG_SYSON_PMC_PATCH_GRP2_L: u32 = 856;
pub const REG_SYSON_PMC_PATCH_GRP2_H: u32 = 860;
pub const REG_SYSON_PMC_PATCH_GRP3_L: u32 = 864;
pub const REG_SYSON_PMC_PATCH_GRP3_H: u32 = 868;
pub const REG_SYSON_PMC_PATCH_GRP4_L: u32 = 872;
pub const REG_SYSON_PMC_PATCH_GRP4_H: u32 = 876;
pub const REG_SYSON_PMC_PATCH_GRP5_L: u32 = 880;
pub const REG_SYSON_PMC_PATCH_GRP5_H: u32 = 884;
pub const REG_SYSON_PMC_PATCH_GRP6_L: u32 = 888;
pub const REG_SYSON_PMC_PATCH_GRP6_H: u32 = 892;
pub const REG_LP_GDMA_CTRL: u32 = 896;
pub const REG_LP_BOOT_REASON0: u32 = 960;
pub const REG_LP_BACKUP_REG1: u32 = 964;
pub const REG_LP_BACKUP_REG2: u32 = 968;
pub const REG_LP_BACKUP_REG3: u32 = 972;
pub const REG_LP_BACKUP_REG4: u32 = 976;
pub const REG_LP_BACKUP_REG5: u32 = 980;
pub const REG_LP_BACKUP_REG6: u32 = 984;
pub const REG_LP_BACKUP_REG7: u32 = 988;
pub const REG_LP_EFUSE_PROTECTION: u32 = 992;
pub const REG_LP_SYSTEM_CFG0: u32 = 1008;
pub const REG_LP_SYSTEM_CFG1: u32 = 1012;
pub const REG_LP_SYSTEM_CFG2: u32 = 1016;
pub const REG_LP_BOOT_CFG: u32 = 1016;
pub const REG_SOC_FUNC_EN: u32 = 1016;
pub const REG_GPIO_F9_PAD_CTRL: u32 = 1288;
pub const REG_OSC_CAL: u32 = 10304;
pub const REG_OSC2M_CAL: u32 = 10308;
pub const REG_SDM_CTRL0: u32 = 0;
pub const REG_SDM_CTRL1: u32 = 1;
pub const REG_SDM_CTRL2: u32 = 2;
pub const REG_SDM_CTRL3: u32 = 3;
pub const REG_SDM_CTRL4: u32 = 4;
pub const AUTO_CAL_MAX_ERROR: u32 = 7;
pub const _PA_0: u32 = 0;
pub const _PA_1: u32 = 1;
pub const _PA_2: u32 = 2;
pub const _PA_3: u32 = 3;
pub const _PA_4: u32 = 4;
pub const _PA_5: u32 = 5;
pub const _PA_6: u32 = 6;
pub const _PA_7: u32 = 7;
pub const _PA_8: u32 = 8;
pub const _PA_9: u32 = 9;
pub const _PA_10: u32 = 10;
pub const _PA_11: u32 = 11;
pub const _PA_12: u32 = 12;
pub const _PA_13: u32 = 13;
pub const _PA_14: u32 = 14;
pub const _PA_15: u32 = 15;
pub const _PA_16: u32 = 16;
pub const _PA_17: u32 = 17;
pub const _PA_18: u32 = 18;
pub const _PA_19: u32 = 19;
pub const _PA_20: u32 = 20;
pub const _PA_21: u32 = 21;
pub const _PA_22: u32 = 22;
pub const _PA_23: u32 = 23;
pub const _PA_24: u32 = 24;
pub const _PA_25: u32 = 25;
pub const _PA_26: u32 = 26;
pub const _PA_27: u32 = 27;
pub const _PA_28: u32 = 28;
pub const _PA_29: u32 = 29;
pub const _PA_30: u32 = 30;
pub const _PA_31: u32 = 31;
pub const _PB_0: u32 = 32;
pub const _PB_1: u32 = 33;
pub const _PB_2: u32 = 34;
pub const _PB_3: u32 = 35;
pub const _PB_4: u32 = 36;
pub const _PB_5: u32 = 37;
pub const _PB_6: u32 = 38;
pub const _PB_7: u32 = 39;
pub const _PB_8: u32 = 40;
pub const _PB_9: u32 = 41;
pub const _PB_10: u32 = 42;
pub const _PB_11: u32 = 43;
pub const _PB_12: u32 = 44;
pub const _PB_13: u32 = 45;
pub const _PB_14: u32 = 46;
pub const _PB_15: u32 = 47;
pub const _PB_16: u32 = 48;
pub const _PB_17: u32 = 49;
pub const _PB_18: u32 = 50;
pub const _PB_19: u32 = 51;
pub const _PB_20: u32 = 52;
pub const _PB_21: u32 = 53;
pub const _PB_22: u32 = 54;
pub const _PB_23: u32 = 55;
pub const _PB_24: u32 = 56;
pub const _PB_25: u32 = 57;
pub const _PB_26: u32 = 58;
pub const _PB_27: u32 = 59;
pub const _PB_28: u32 = 60;
pub const _PB_29: u32 = 61;
pub const _PB_30: u32 = 62;
pub const _PB_31: u32 = 63;
pub const _PNC: u32 = 4294967295;
pub const PAD_BIT_SHIFT_DRIVING_STRENGTH: u32 = 10;
pub const PAD_BIT_MASK_DRIVING_STRENGTH: u32 = 3;
pub const PAD_BIT_SHIFT_FUNCTION_ID: u32 = 0;
pub const PAD_BIT_MASK_FUNCTION_ID: u32 = 31;
pub const GPIO_Resistor_LARGE: u32 = 0;
pub const GPIO_Resistor_SMALL: u32 = 1;
pub const PINMUX_FUNCTION_GPIO: u32 = 0;
pub const PINMUX_FUNCTION_UART: u32 = 1;
pub const PINMUX_FUNCTION_UART_RTSCTS: u32 = 2;
pub const PINMUX_FUNCTION_LOGUART: u32 = 2;
pub const PINMUX_FUNCTION_SPIM: u32 = 3;
pub const PINMUX_FUNCTION_SPIS: u32 = 3;
pub const PINMUX_FUNCTION_RTC: u32 = 4;
pub const PINMUX_FUNCTION_TIMINPUT: u32 = 4;
pub const PINMUX_FUNCTION_EXT32K: u32 = 28;
pub const PINMUX_FUNCTION_RTCOUT: u32 = 28;
pub const PINMUX_FUNCTION_TIMINPUT_HS: u32 = 22;
pub const PINMUX_FUNCTION_IR: u32 = 5;
pub const PINMUX_FUNCTION_SPIF: u32 = 6;
pub const PINMUX_FUNCTION_I2C: u32 = 7;
pub const PINMUX_FUNCTION_SDIOD: u32 = 8;
pub const PINMUX_FUNCTION_SDIOH: u32 = 8;
pub const PINMUX_FUNCTION_PWM: u32 = 9;
pub const PINMUX_FUNCTION_PWM_HS: u32 = 9;
pub const PINMUX_FUNCTION_PWM_LP: u32 = 10;
pub const PINMUX_FUNCTION_SWD: u32 = 11;
pub const PINMUX_FUNCTION_I2S: u32 = 12;
pub const PINMUX_FUNCTION_DMIC: u32 = 12;
pub const PINMUX_FUNCTION_KEYSCAN_ROW: u32 = 29;
pub const PINMUX_FUNCTION_KEYSCAN_COL: u32 = 30;
pub const PINMUX_FUNCTION_LCD: u32 = 13;
pub const PINMUX_FUNCTION_USB: u32 = 14;
pub const PINMUX_FUNCTION_QDEC: u32 = 15;
pub const PINMUX_FUNCTION_SGPIO: u32 = 16;
pub const PINMUX_FUNCTION_RFE: u32 = 18;
pub const PINMUX_FUNCTION_BTCOEX: u32 = 19;
pub const PINMUX_FUNCTION_WIFIFW: u32 = 20;
pub const PINMUX_FUNCTION_EXT_PCM: u32 = 20;
pub const PINMUX_FUNCTION_BB_PIN: u32 = 21;
pub const PINMUX_FUNCTION_SIC: u32 = 22;
pub const PINMUX_FUNCTION_WAKEUP: u32 = 31;
pub const PINMUX_FUNCTION_DBGPORT: u32 = 23;
pub const PINMUX_FUNCTION_BBDBG: u32 = 25;
pub const PINMUX_S0: u32 = 0;
pub const PINMUX_S1: u32 = 1;
pub const PINMUX_S2: u32 = 2;
pub const PINMUX_S3: u32 = 3;
pub const PAD_DRV_STRENGTH_0: u32 = 0;
pub const PAD_DRV_STRENGTH_1: u32 = 512;
pub const PAD_DRV_STRENGTH_2: u32 = 1024;
pub const PAD_DRV_STRENGTH_3: u32 = 1536;
pub const PAD_DRV_STRENGTH_4: u32 = 2048;
pub const PAD_DRV_STRENGTH_5: u32 = 2560;
pub const PAD_DRV_STRENGTH_6: u32 = 3072;
pub const PAD_DRV_STRENGTH_7: u32 = 3584;
pub const FLASH_S0_CS_GPIO: u32 = 50;
pub const FLASH_S1_CS_GPIO: u32 = 48;
pub const BOOT_UART_IDX: u32 = 0;
pub const BOOT_UART_PIN_MUX: u32 = 1;
pub const BOOT_UART_BAUD_RATE: u32 = 38400;
pub const BOOT_UART_MAX_IMG_SZ: u32 = 33554432;
pub const SYS_CLK_CTRL1: u32 = 3;
pub const SYS_CLK_CTRL2: u32 = 2;
pub const SYS_CLK_CTRL3: u32 = 1;
pub const SYS_CLK_CTRL4: u32 = 0;
pub const APBPeriph_CLOCK_NULL: u32 = 0;
pub const SYS_FUNC_EN1: u32 = 3;
pub const SYS_FUNC_EN2: u32 = 2;
pub const SYS_FUNC_EN3: u32 = 1;
pub const SYS_FUNC_EN4: u32 = 0;
pub const APBPeriph_NULL: u32 = 0;
pub const __CM3_REV: u32 = 512;
pub const __MPU_PRESENT: u32 = 1;
pub const __NVIC_PRIO_BITS: u32 = 3;
pub const __Vendor_SysTickConfig: u32 = 1;
pub const __SAUREGION_PRESENT: u32 = 1;
pub const __FPU_PRESENT: u32 = 1;
pub const __VFP_FP__: u32 = 1;
pub const __ARM_FEATURE_CMSE: u32 = 3;
pub const CMSE_AU_NONSECURE: u32 = 2;
pub const CMSE_MPU_NONSECURE: u32 = 16;
pub const CMSE_NONSECURE: u32 = 18;
pub const CMSE_MPU_UNPRIV: u32 = 4;
pub const CMSE_MPU_READWRITE: u32 = 1;
pub const CMSE_MPU_READ: u32 = 8;
pub const __ARMv8MML_CMSIS_VERSION_MAIN: u32 = 5;
pub const __ARMv8MML_CMSIS_VERSION_SUB: u32 = 0;
pub const __ARMv8MML_CMSIS_VERSION: u32 = 327680;
pub const __CORTEX_M: u32 = 81;
pub const __FPU_USED: u32 = 1;
pub const APSR_N_Pos: u32 = 31;
pub const APSR_N_Msk: u32 = 2147483648;
pub const APSR_Z_Pos: u32 = 30;
pub const APSR_Z_Msk: u32 = 1073741824;
pub const APSR_C_Pos: u32 = 29;
pub const APSR_C_Msk: u32 = 536870912;
pub const APSR_V_Pos: u32 = 28;
pub const APSR_V_Msk: u32 = 268435456;
pub const APSR_Q_Pos: u32 = 27;
pub const APSR_Q_Msk: u32 = 134217728;
pub const APSR_GE_Pos: u32 = 16;
pub const APSR_GE_Msk: u32 = 983040;
pub const IPSR_ISR_Pos: u32 = 0;
pub const IPSR_ISR_Msk: u32 = 511;
pub const xPSR_N_Pos: u32 = 31;
pub const xPSR_N_Msk: u32 = 2147483648;
pub const xPSR_Z_Pos: u32 = 30;
pub const xPSR_Z_Msk: u32 = 1073741824;
pub const xPSR_C_Pos: u32 = 29;
pub const xPSR_C_Msk: u32 = 536870912;
pub const xPSR_V_Pos: u32 = 28;
pub const xPSR_V_Msk: u32 = 268435456;
pub const xPSR_Q_Pos: u32 = 27;
pub const xPSR_Q_Msk: u32 = 134217728;
pub const xPSR_IT_Pos: u32 = 25;
pub const xPSR_IT_Msk: u32 = 100663296;
pub const xPSR_T_Pos: u32 = 24;
pub const xPSR_T_Msk: u32 = 16777216;
pub const xPSR_GE_Pos: u32 = 16;
pub const xPSR_GE_Msk: u32 = 983040;
pub const xPSR_ISR_Pos: u32 = 0;
pub const xPSR_ISR_Msk: u32 = 511;
pub const CONTROL_SFPA_Pos: u32 = 3;
pub const CONTROL_SFPA_Msk: u32 = 8;
pub const CONTROL_FPCA_Pos: u32 = 2;
pub const CONTROL_FPCA_Msk: u32 = 4;
pub const CONTROL_SPSEL_Pos: u32 = 1;
pub const CONTROL_SPSEL_Msk: u32 = 2;
pub const CONTROL_nPRIV_Pos: u32 = 0;
pub const CONTROL_nPRIV_Msk: u32 = 1;
pub const NVIC_STIR_INTID_Pos: u32 = 0;
pub const NVIC_STIR_INTID_Msk: u32 = 511;
pub const SCB_CPUID_IMPLEMENTER_Pos: u32 = 24;
pub const SCB_CPUID_IMPLEMENTER_Msk: u32 = 4278190080;
pub const SCB_CPUID_VARIANT_Pos: u32 = 20;
pub const SCB_CPUID_VARIANT_Msk: u32 = 15728640;
pub const SCB_CPUID_ARCHITECTURE_Pos: u32 = 16;
pub const SCB_CPUID_ARCHITECTURE_Msk: u32 = 983040;
pub const SCB_CPUID_PARTNO_Pos: u32 = 4;
pub const SCB_CPUID_PARTNO_Msk: u32 = 65520;
pub const SCB_CPUID_REVISION_Pos: u32 = 0;
pub const SCB_CPUID_REVISION_Msk: u32 = 15;
pub const SCB_ICSR_PENDNMISET_Pos: u32 = 31;
pub const SCB_ICSR_PENDNMISET_Msk: u32 = 2147483648;
pub const SCB_ICSR_PENDNMICLR_Pos: u32 = 30;
pub const SCB_ICSR_PENDNMICLR_Msk: u32 = 1073741824;
pub const SCB_ICSR_PENDSVSET_Pos: u32 = 28;
pub const SCB_ICSR_PENDSVSET_Msk: u32 = 268435456;
pub const SCB_ICSR_PENDSVCLR_Pos: u32 = 27;
pub const SCB_ICSR_PENDSVCLR_Msk: u32 = 134217728;
pub const SCB_ICSR_PENDSTSET_Pos: u32 = 26;
pub const SCB_ICSR_PENDSTSET_Msk: u32 = 67108864;
pub const SCB_ICSR_PENDSTCLR_Pos: u32 = 25;
pub const SCB_ICSR_PENDSTCLR_Msk: u32 = 33554432;
pub const SCB_ICSR_STTNS_Pos: u32 = 24;
pub const SCB_ICSR_STTNS_Msk: u32 = 16777216;
pub const SCB_ICSR_ISRPREEMPT_Pos: u32 = 23;
pub const SCB_ICSR_ISRPREEMPT_Msk: u32 = 8388608;
pub const SCB_ICSR_ISRPENDING_Pos: u32 = 22;
pub const SCB_ICSR_ISRPENDING_Msk: u32 = 4194304;
pub const SCB_ICSR_VECTPENDING_Pos: u32 = 12;
pub const SCB_ICSR_VECTPENDING_Msk: u32 = 2093056;
pub const SCB_ICSR_RETTOBASE_Pos: u32 = 11;
pub const SCB_ICSR_RETTOBASE_Msk: u32 = 2048;
pub const SCB_ICSR_VECTACTIVE_Pos: u32 = 0;
pub const SCB_ICSR_VECTACTIVE_Msk: u32 = 511;
pub const SCB_VTOR_TBLOFF_Pos: u32 = 7;
pub const SCB_VTOR_TBLOFF_Msk: u32 = 4294967168;
pub const SCB_AIRCR_VECTKEY_Pos: u32 = 16;
pub const SCB_AIRCR_VECTKEY_Msk: u32 = 4294901760;
pub const SCB_AIRCR_VECTKEYSTAT_Pos: u32 = 16;
pub const SCB_AIRCR_VECTKEYSTAT_Msk: u32 = 4294901760;
pub const SCB_AIRCR_ENDIANESS_Pos: u32 = 15;
pub const SCB_AIRCR_ENDIANESS_Msk: u32 = 32768;
pub const SCB_AIRCR_PRIS_Pos: u32 = 14;
pub const SCB_AIRCR_PRIS_Msk: u32 = 16384;
pub const SCB_AIRCR_BFHFNMINS_Pos: u32 = 13;
pub const SCB_AIRCR_BFHFNMINS_Msk: u32 = 8192;
pub const SCB_AIRCR_PRIGROUP_Pos: u32 = 8;
pub const SCB_AIRCR_PRIGROUP_Msk: u32 = 1792;
pub const SCB_AIRCR_SYSRESETREQS_Pos: u32 = 3;
pub const SCB_AIRCR_SYSRESETREQS_Msk: u32 = 8;
pub const SCB_AIRCR_SYSRESETREQ_Pos: u32 = 2;
pub const SCB_AIRCR_SYSRESETREQ_Msk: u32 = 4;
pub const SCB_AIRCR_VECTCLRACTIVE_Pos: u32 = 1;
pub const SCB_AIRCR_VECTCLRACTIVE_Msk: u32 = 2;
pub const SCB_SCR_SEVONPEND_Pos: u32 = 4;
pub const SCB_SCR_SEVONPEND_Msk: u32 = 16;
pub const SCB_SCR_SLEEPDEEPS_Pos: u32 = 3;
pub const SCB_SCR_SLEEPDEEPS_Msk: u32 = 8;
pub const SCB_SCR_SLEEPDEEP_Pos: u32 = 2;
pub const SCB_SCR_SLEEPDEEP_Msk: u32 = 4;
pub const SCB_SCR_SLEEPONEXIT_Pos: u32 = 1;
pub const SCB_SCR_SLEEPONEXIT_Msk: u32 = 2;
pub const SCB_CCR_BP_Pos: u32 = 18;
pub const SCB_CCR_BP_Msk: u32 = 262144;
pub const SCB_CCR_IC_Pos: u32 = 17;
pub const SCB_CCR_IC_Msk: u32 = 131072;
pub const SCB_CCR_DC_Pos: u32 = 16;
pub const SCB_CCR_DC_Msk: u32 = 65536;
pub const SCB_CCR_STKOFHFNMIGN_Pos: u32 = 10;
pub const SCB_CCR_STKOFHFNMIGN_Msk: u32 = 1024;
pub const SCB_CCR_BFHFNMIGN_Pos: u32 = 8;
pub const SCB_CCR_BFHFNMIGN_Msk: u32 = 256;
pub const SCB_CCR_DIV_0_TRP_Pos: u32 = 4;
pub const SCB_CCR_DIV_0_TRP_Msk: u32 = 16;
pub const SCB_CCR_UNALIGN_TRP_Pos: u32 = 3;
pub const SCB_CCR_UNALIGN_TRP_Msk: u32 = 8;
pub const SCB_CCR_USERSETMPEND_Pos: u32 = 1;
pub const SCB_CCR_USERSETMPEND_Msk: u32 = 2;
pub const SCB_SHCSR_HARDFAULTPENDED_Pos: u32 = 21;
pub const SCB_SHCSR_HARDFAULTPENDED_Msk: u32 = 2097152;
pub const SCB_SHCSR_SECUREFAULTPENDED_Pos: u32 = 20;
pub const SCB_SHCSR_SECUREFAULTPENDED_Msk: u32 = 1048576;
pub const SCB_SHCSR_SECUREFAULTENA_Pos: u32 = 19;
pub const SCB_SHCSR_SECUREFAULTENA_Msk: u32 = 524288;
pub const SCB_SHCSR_USGFAULTENA_Pos: u32 = 18;
pub const SCB_SHCSR_USGFAULTENA_Msk: u32 = 262144;
pub const SCB_SHCSR_BUSFAULTENA_Pos: u32 = 17;
pub const SCB_SHCSR_BUSFAULTENA_Msk: u32 = 131072;
pub const SCB_SHCSR_MEMFAULTENA_Pos: u32 = 16;
pub const SCB_SHCSR_MEMFAULTENA_Msk: u32 = 65536;
pub const SCB_SHCSR_SVCALLPENDED_Pos: u32 = 15;
pub const SCB_SHCSR_SVCALLPENDED_Msk: u32 = 32768;
pub const SCB_SHCSR_BUSFAULTPENDED_Pos: u32 = 14;
pub const SCB_SHCSR_BUSFAULTPENDED_Msk: u32 = 16384;
pub const SCB_SHCSR_MEMFAULTPENDED_Pos: u32 = 13;
pub const SCB_SHCSR_MEMFAULTPENDED_Msk: u32 = 8192;
pub const SCB_SHCSR_USGFAULTPENDED_Pos: u32 = 12;
pub const SCB_SHCSR_USGFAULTPENDED_Msk: u32 = 4096;
pub const SCB_SHCSR_SYSTICKACT_Pos: u32 = 11;
pub const SCB_SHCSR_SYSTICKACT_Msk: u32 = 2048;
pub const SCB_SHCSR_PENDSVACT_Pos: u32 = 10;
pub const SCB_SHCSR_PENDSVACT_Msk: u32 = 1024;
pub const SCB_SHCSR_MONITORACT_Pos: u32 = 8;
pub const SCB_SHCSR_MONITORACT_Msk: u32 = 256;
pub const SCB_SHCSR_SVCALLACT_Pos: u32 = 7;
pub const SCB_SHCSR_SVCALLACT_Msk: u32 = 128;
pub const SCB_SHCSR_NMIACT_Pos: u32 = 5;
pub const SCB_SHCSR_NMIACT_Msk: u32 = 32;
pub const SCB_SHCSR_SECUREFAULTACT_Pos: u32 = 4;
pub const SCB_SHCSR_SECUREFAULTACT_Msk: u32 = 16;
pub const SCB_SHCSR_USGFAULTACT_Pos: u32 = 3;
pub const SCB_SHCSR_USGFAULTACT_Msk: u32 = 8;
pub const SCB_SHCSR_HARDFAULTACT_Pos: u32 = 2;
pub const SCB_SHCSR_HARDFAULTACT_Msk: u32 = 4;
pub const SCB_SHCSR_BUSFAULTACT_Pos: u32 = 1;
pub const SCB_SHCSR_BUSFAULTACT_Msk: u32 = 2;
pub const SCB_SHCSR_MEMFAULTACT_Pos: u32 = 0;
pub const SCB_SHCSR_MEMFAULTACT_Msk: u32 = 1;
pub const SCB_CFSR_USGFAULTSR_Pos: u32 = 16;
pub const SCB_CFSR_USGFAULTSR_Msk: u32 = 4294901760;
pub const SCB_CFSR_BUSFAULTSR_Pos: u32 = 8;
pub const SCB_CFSR_BUSFAULTSR_Msk: u32 = 65280;
pub const SCB_CFSR_MEMFAULTSR_Pos: u32 = 0;
pub const SCB_CFSR_MEMFAULTSR_Msk: u32 = 255;
pub const SCB_CFSR_MMARVALID_Pos: u32 = 7;
pub const SCB_CFSR_MMARVALID_Msk: u32 = 128;
pub const SCB_CFSR_MLSPERR_Pos: u32 = 5;
pub const SCB_CFSR_MLSPERR_Msk: u32 = 32;
pub const SCB_CFSR_MSTKERR_Pos: u32 = 4;
pub const SCB_CFSR_MSTKERR_Msk: u32 = 16;
pub const SCB_CFSR_MUNSTKERR_Pos: u32 = 3;
pub const SCB_CFSR_MUNSTKERR_Msk: u32 = 8;
pub const SCB_CFSR_DACCVIOL_Pos: u32 = 1;
pub const SCB_CFSR_DACCVIOL_Msk: u32 = 2;
pub const SCB_CFSR_IACCVIOL_Pos: u32 = 0;
pub const SCB_CFSR_IACCVIOL_Msk: u32 = 1;
pub const SCB_CFSR_BFARVALID_Pos: u32 = 15;
pub const SCB_CFSR_BFARVALID_Msk: u32 = 32768;
pub const SCB_CFSR_LSPERR_Pos: u32 = 13;
pub const SCB_CFSR_LSPERR_Msk: u32 = 8192;
pub const SCB_CFSR_STKERR_Pos: u32 = 12;
pub const SCB_CFSR_STKERR_Msk: u32 = 4096;
pub const SCB_CFSR_UNSTKERR_Pos: u32 = 11;
pub const SCB_CFSR_UNSTKERR_Msk: u32 = 2048;
pub const SCB_CFSR_IMPRECISERR_Pos: u32 = 10;
pub const SCB_CFSR_IMPRECISERR_Msk: u32 = 1024;
pub const SCB_CFSR_PRECISERR_Pos: u32 = 9;
pub const SCB_CFSR_PRECISERR_Msk: u32 = 512;
pub const SCB_CFSR_IBUSERR_Pos: u32 = 8;
pub const SCB_CFSR_IBUSERR_Msk: u32 = 256;
pub const SCB_CFSR_DIVBYZERO_Pos: u32 = 25;
pub const SCB_CFSR_DIVBYZERO_Msk: u32 = 33554432;
pub const SCB_CFSR_UNALIGNED_Pos: u32 = 24;
pub const SCB_CFSR_UNALIGNED_Msk: u32 = 16777216;
pub const SCB_CFSR_STKOF_Pos: u32 = 20;
pub const SCB_CFSR_STKOF_Msk: u32 = 1048576;
pub const SCB_CFSR_NOCP_Pos: u32 = 19;
pub const SCB_CFSR_NOCP_Msk: u32 = 524288;
pub const SCB_CFSR_INVPC_Pos: u32 = 18;
pub const SCB_CFSR_INVPC_Msk: u32 = 262144;
pub const SCB_CFSR_INVSTATE_Pos: u32 = 17;
pub const SCB_CFSR_INVSTATE_Msk: u32 = 131072;
pub const SCB_CFSR_UNDEFINSTR_Pos: u32 = 16;
pub const SCB_CFSR_UNDEFINSTR_Msk: u32 = 65536;
pub const SCB_HFSR_DEBUGEVT_Pos: u32 = 31;
pub const SCB_HFSR_DEBUGEVT_Msk: u32 = 2147483648;
pub const SCB_HFSR_FORCED_Pos: u32 = 30;
pub const SCB_HFSR_FORCED_Msk: u32 = 1073741824;
pub const SCB_HFSR_VECTTBL_Pos: u32 = 1;
pub const SCB_HFSR_VECTTBL_Msk: u32 = 2;
pub const SCB_DFSR_EXTERNAL_Pos: u32 = 4;
pub const SCB_DFSR_EXTERNAL_Msk: u32 = 16;
pub const SCB_DFSR_VCATCH_Pos: u32 = 3;
pub const SCB_DFSR_VCATCH_Msk: u32 = 8;
pub const SCB_DFSR_DWTTRAP_Pos: u32 = 2;
pub const SCB_DFSR_DWTTRAP_Msk: u32 = 4;
pub const SCB_DFSR_BKPT_Pos: u32 = 1;
pub const SCB_DFSR_BKPT_Msk: u32 = 2;
pub const SCB_DFSR_HALTED_Pos: u32 = 0;
pub const SCB_DFSR_HALTED_Msk: u32 = 1;
pub const SCB_NSACR_CP11_Pos: u32 = 11;
pub const SCB_NSACR_CP11_Msk: u32 = 2048;
pub const SCB_NSACR_CP10_Pos: u32 = 10;
pub const SCB_NSACR_CP10_Msk: u32 = 1024;
pub const SCB_NSACR_CPn_Pos: u32 = 0;
pub const SCB_NSACR_CPn_Msk: u32 = 1;
pub const SCB_CLIDR_LOUU_Pos: u32 = 27;
pub const SCB_CLIDR_LOUU_Msk: u32 = 939524096;
pub const SCB_CLIDR_LOC_Pos: u32 = 24;
pub const SCB_CLIDR_LOC_Msk: u32 = 117440512;
pub const SCB_CTR_FORMAT_Pos: u32 = 29;
pub const SCB_CTR_FORMAT_Msk: u32 = 3758096384;
pub const SCB_CTR_CWG_Pos: u32 = 24;
pub const SCB_CTR_CWG_Msk: u32 = 251658240;
pub const SCB_CTR_ERG_Pos: u32 = 20;
pub const SCB_CTR_ERG_Msk: u32 = 15728640;
pub const SCB_CTR_DMINLINE_Pos: u32 = 16;
pub const SCB_CTR_DMINLINE_Msk: u32 = 983040;
pub const SCB_CTR_IMINLINE_Pos: u32 = 0;
pub const SCB_CTR_IMINLINE_Msk: u32 = 15;
pub const SCB_CCSIDR_WT_Pos: u32 = 31;
pub const SCB_CCSIDR_WT_Msk: u32 = 2147483648;
pub const SCB_CCSIDR_WB_Pos: u32 = 30;
pub const SCB_CCSIDR_WB_Msk: u32 = 1073741824;
pub const SCB_CCSIDR_RA_Pos: u32 = 29;
pub const SCB_CCSIDR_RA_Msk: u32 = 536870912;
pub const SCB_CCSIDR_WA_Pos: u32 = 28;
pub const SCB_CCSIDR_WA_Msk: u32 = 268435456;
pub const SCB_CCSIDR_NUMSETS_Pos: u32 = 13;
pub const SCB_CCSIDR_NUMSETS_Msk: u32 = 268427264;
pub const SCB_CCSIDR_ASSOCIATIVITY_Pos: u32 = 3;
pub const SCB_CCSIDR_ASSOCIATIVITY_Msk: u32 = 8184;
pub const SCB_CCSIDR_LINESIZE_Pos: u32 = 0;
pub const SCB_CCSIDR_LINESIZE_Msk: u32 = 7;
pub const SCB_CSSELR_LEVEL_Pos: u32 = 1;
pub const SCB_CSSELR_LEVEL_Msk: u32 = 14;
pub const SCB_CSSELR_IND_Pos: u32 = 0;
pub const SCB_CSSELR_IND_Msk: u32 = 1;
pub const SCB_STIR_INTID_Pos: u32 = 0;
pub const SCB_STIR_INTID_Msk: u32 = 511;
pub const SCB_DCISW_WAY_Pos: u32 = 31;
pub const SCB_DCISW_WAY_Msk: u32 = 2147483648;
pub const SCB_DCISW_SET_Pos: u32 = 5;
pub const SCB_DCISW_SET_Msk: u32 = 16352;
pub const SCB_DCCSW_WAY_Pos: u32 = 31;
pub const SCB_DCCSW_WAY_Msk: u32 = 2147483648;
pub const SCB_DCCSW_SET_Pos: u32 = 5;
pub const SCB_DCCSW_SET_Msk: u32 = 16352;
pub const SCB_DCCISW_WAY_Pos: u32 = 31;
pub const SCB_DCCISW_WAY_Msk: u32 = 2147483648;
pub const SCB_DCCISW_SET_Pos: u32 = 5;
pub const SCB_DCCISW_SET_Msk: u32 = 16352;
pub const SCB_ITCMCR_SZ_Pos: u32 = 3;
pub const SCB_ITCMCR_SZ_Msk: u32 = 120;
pub const SCB_ITCMCR_RETEN_Pos: u32 = 2;
pub const SCB_ITCMCR_RETEN_Msk: u32 = 4;
pub const SCB_ITCMCR_RMW_Pos: u32 = 1;
pub const SCB_ITCMCR_RMW_Msk: u32 = 2;
pub const SCB_ITCMCR_EN_Pos: u32 = 0;
pub const SCB_ITCMCR_EN_Msk: u32 = 1;
pub const SCB_DTCMCR_SZ_Pos: u32 = 3;
pub const SCB_DTCMCR_SZ_Msk: u32 = 120;
pub const SCB_DTCMCR_RETEN_Pos: u32 = 2;
pub const SCB_DTCMCR_RETEN_Msk: u32 = 4;
pub const SCB_DTCMCR_RMW_Pos: u32 = 1;
pub const SCB_DTCMCR_RMW_Msk: u32 = 2;
pub const SCB_DTCMCR_EN_Pos: u32 = 0;
pub const SCB_DTCMCR_EN_Msk: u32 = 1;
pub const SCB_AHBPCR_SZ_Pos: u32 = 1;
pub const SCB_AHBPCR_SZ_Msk: u32 = 14;
pub const SCB_AHBPCR_EN_Pos: u32 = 0;
pub const SCB_AHBPCR_EN_Msk: u32 = 1;
pub const SCB_CACR_FORCEWT_Pos: u32 = 2;
pub const SCB_CACR_FORCEWT_Msk: u32 = 4;
pub const SCB_CACR_ECCEN_Pos: u32 = 1;
pub const SCB_CACR_ECCEN_Msk: u32 = 2;
pub const SCB_CACR_SIWT_Pos: u32 = 0;
pub const SCB_CACR_SIWT_Msk: u32 = 1;
pub const SCB_AHBSCR_INITCOUNT_Pos: u32 = 11;
pub const SCB_AHBSCR_TPRI_Pos: u32 = 2;
pub const SCB_AHBSCR_CTL_Pos: u32 = 0;
pub const SCB_AHBSCR_CTL_Msk: u32 = 3;
pub const SCB_ABFSR_AXIMTYPE_Pos: u32 = 8;
pub const SCB_ABFSR_AXIMTYPE_Msk: u32 = 768;
pub const SCB_ABFSR_EPPB_Pos: u32 = 4;
pub const SCB_ABFSR_EPPB_Msk: u32 = 16;
pub const SCB_ABFSR_AXIM_Pos: u32 = 3;
pub const SCB_ABFSR_AXIM_Msk: u32 = 8;
pub const SCB_ABFSR_AHBP_Pos: u32 = 2;
pub const SCB_ABFSR_AHBP_Msk: u32 = 4;
pub const SCB_ABFSR_DTCM_Pos: u32 = 1;
pub const SCB_ABFSR_DTCM_Msk: u32 = 2;
pub const SCB_ABFSR_ITCM_Pos: u32 = 0;
pub const SCB_ABFSR_ITCM_Msk: u32 = 1;
pub const SCnSCB_ICTR_INTLINESNUM_Pos: u32 = 0;
pub const SCnSCB_ICTR_INTLINESNUM_Msk: u32 = 15;
pub const SysTick_CTRL_COUNTFLAG_Pos: u32 = 16;
pub const SysTick_CTRL_COUNTFLAG_Msk: u32 = 65536;
pub const SysTick_CTRL_CLKSOURCE_Pos: u32 = 2;
pub const SysTick_CTRL_CLKSOURCE_Msk: u32 = 4;
pub const SysTick_CTRL_TICKINT_Pos: u32 = 1;
pub const SysTick_CTRL_TICKINT_Msk: u32 = 2;
pub const SysTick_CTRL_ENABLE_Pos: u32 = 0;
pub const SysTick_CTRL_ENABLE_Msk: u32 = 1;
pub const SysTick_LOAD_RELOAD_Pos: u32 = 0;
pub const SysTick_LOAD_RELOAD_Msk: u32 = 16777215;
pub const SysTick_VAL_CURRENT_Pos: u32 = 0;
pub const SysTick_VAL_CURRENT_Msk: u32 = 16777215;
pub const SysTick_CALIB_NOREF_Pos: u32 = 31;
pub const SysTick_CALIB_NOREF_Msk: u32 = 2147483648;
pub const SysTick_CALIB_SKEW_Pos: u32 = 30;
pub const SysTick_CALIB_SKEW_Msk: u32 = 1073741824;
pub const SysTick_CALIB_TENMS_Pos: u32 = 0;
pub const SysTick_CALIB_TENMS_Msk: u32 = 16777215;
pub const ITM_STIM_DISABLED_Pos: u32 = 1;
pub const ITM_STIM_DISABLED_Msk: u32 = 2;
pub const ITM_STIM_FIFOREADY_Pos: u32 = 0;
pub const ITM_STIM_FIFOREADY_Msk: u32 = 1;
pub const ITM_TPR_PRIVMASK_Pos: u32 = 0;
pub const ITM_TPR_PRIVMASK_Msk: u32 = 15;
pub const ITM_TCR_BUSY_Pos: u32 = 23;
pub const ITM_TCR_BUSY_Msk: u32 = 8388608;
pub const ITM_TCR_TRACEBUSID_Pos: u32 = 16;
pub const ITM_TCR_TRACEBUSID_Msk: u32 = 8323072;
pub const ITM_TCR_GTSFREQ_Pos: u32 = 10;
pub const ITM_TCR_GTSFREQ_Msk: u32 = 3072;
pub const ITM_TCR_TSPRESCALE_Pos: u32 = 8;
pub const ITM_TCR_TSPRESCALE_Msk: u32 = 768;
pub const ITM_TCR_STALLENA_Pos: u32 = 5;
pub const ITM_TCR_STALLENA_Msk: u32 = 32;
pub const ITM_TCR_SWOENA_Pos: u32 = 4;
pub const ITM_TCR_SWOENA_Msk: u32 = 16;
pub const ITM_TCR_DWTENA_Pos: u32 = 3;
pub const ITM_TCR_DWTENA_Msk: u32 = 8;
pub const ITM_TCR_SYNCENA_Pos: u32 = 2;
pub const ITM_TCR_SYNCENA_Msk: u32 = 4;
pub const ITM_TCR_TSENA_Pos: u32 = 1;
pub const ITM_TCR_TSENA_Msk: u32 = 2;
pub const ITM_TCR_ITMENA_Pos: u32 = 0;
pub const ITM_TCR_ITMENA_Msk: u32 = 1;
pub const ITM_IWR_ATVALIDM_Pos: u32 = 0;
pub const ITM_IWR_ATVALIDM_Msk: u32 = 1;
pub const ITM_IRR_ATREADYM_Pos: u32 = 0;
pub const ITM_IRR_ATREADYM_Msk: u32 = 1;
pub const ITM_IMCR_INTEGRATION_Pos: u32 = 0;
pub const ITM_IMCR_INTEGRATION_Msk: u32 = 1;
pub const ITM_LSR_ByteAcc_Pos: u32 = 2;
pub const ITM_LSR_ByteAcc_Msk: u32 = 4;
pub const ITM_LSR_Access_Pos: u32 = 1;
pub const ITM_LSR_Access_Msk: u32 = 2;
pub const ITM_LSR_Present_Pos: u32 = 0;
pub const ITM_LSR_Present_Msk: u32 = 1;
pub const DWT_CTRL_NUMCOMP_Pos: u32 = 28;
pub const DWT_CTRL_NUMCOMP_Msk: u32 = 4026531840;
pub const DWT_CTRL_NOTRCPKT_Pos: u32 = 27;
pub const DWT_CTRL_NOTRCPKT_Msk: u32 = 134217728;
pub const DWT_CTRL_NOEXTTRIG_Pos: u32 = 26;
pub const DWT_CTRL_NOEXTTRIG_Msk: u32 = 67108864;
pub const DWT_CTRL_NOCYCCNT_Pos: u32 = 25;
pub const DWT_CTRL_NOCYCCNT_Msk: u32 = 33554432;
pub const DWT_CTRL_NOPRFCNT_Pos: u32 = 24;
pub const DWT_CTRL_NOPRFCNT_Msk: u32 = 16777216;
pub const DWT_CTRL_CYCDISS_Pos: u32 = 23;
pub const DWT_CTRL_CYCDISS_Msk: u32 = 8388608;
pub const DWT_CTRL_CYCEVTENA_Pos: u32 = 22;
pub const DWT_CTRL_CYCEVTENA_Msk: u32 = 4194304;
pub const DWT_CTRL_FOLDEVTENA_Pos: u32 = 21;
pub const DWT_CTRL_FOLDEVTENA_Msk: u32 = 2097152;
pub const DWT_CTRL_LSUEVTENA_Pos: u32 = 20;
pub const DWT_CTRL_LSUEVTENA_Msk: u32 = 1048576;
pub const DWT_CTRL_SLEEPEVTENA_Pos: u32 = 19;
pub const DWT_CTRL_SLEEPEVTENA_Msk: u32 = 524288;
pub const DWT_CTRL_EXCEVTENA_Pos: u32 = 18;
pub const DWT_CTRL_EXCEVTENA_Msk: u32 = 262144;
pub const DWT_CTRL_CPIEVTENA_Pos: u32 = 17;
pub const DWT_CTRL_CPIEVTENA_Msk: u32 = 131072;
pub const DWT_CTRL_EXCTRCENA_Pos: u32 = 16;
pub const DWT_CTRL_EXCTRCENA_Msk: u32 = 65536;
pub const DWT_CTRL_PCSAMPLENA_Pos: u32 = 12;
pub const DWT_CTRL_PCSAMPLENA_Msk: u32 = 4096;
pub const DWT_CTRL_SYNCTAP_Pos: u32 = 10;
pub const DWT_CTRL_SYNCTAP_Msk: u32 = 3072;
pub const DWT_CTRL_CYCTAP_Pos: u32 = 9;
pub const DWT_CTRL_CYCTAP_Msk: u32 = 512;
pub const DWT_CTRL_POSTINIT_Pos: u32 = 5;
pub const DWT_CTRL_POSTINIT_Msk: u32 = 480;
pub const DWT_CTRL_POSTPRESET_Pos: u32 = 1;
pub const DWT_CTRL_POSTPRESET_Msk: u32 = 30;
pub const DWT_CTRL_CYCCNTENA_Pos: u32 = 0;
pub const DWT_CTRL_CYCCNTENA_Msk: u32 = 1;
pub const DWT_CPICNT_CPICNT_Pos: u32 = 0;
pub const DWT_CPICNT_CPICNT_Msk: u32 = 255;
pub const DWT_EXCCNT_EXCCNT_Pos: u32 = 0;
pub const DWT_EXCCNT_EXCCNT_Msk: u32 = 255;
pub const DWT_SLEEPCNT_SLEEPCNT_Pos: u32 = 0;
pub const DWT_SLEEPCNT_SLEEPCNT_Msk: u32 = 255;
pub const DWT_LSUCNT_LSUCNT_Pos: u32 = 0;
pub const DWT_LSUCNT_LSUCNT_Msk: u32 = 255;
pub const DWT_FOLDCNT_FOLDCNT_Pos: u32 = 0;
pub const DWT_FOLDCNT_FOLDCNT_Msk: u32 = 255;
pub const DWT_FUNCTION_ID_Pos: u32 = 27;
pub const DWT_FUNCTION_ID_Msk: u32 = 4160749568;
pub const DWT_FUNCTION_MATCHED_Pos: u32 = 24;
pub const DWT_FUNCTION_MATCHED_Msk: u32 = 16777216;
pub const DWT_FUNCTION_DATAVSIZE_Pos: u32 = 10;
pub const DWT_FUNCTION_DATAVSIZE_Msk: u32 = 3072;
pub const DWT_FUNCTION_ACTION_Pos: u32 = 4;
pub const DWT_FUNCTION_ACTION_Msk: u32 = 16;
pub const DWT_FUNCTION_MATCH_Pos: u32 = 0;
pub const DWT_FUNCTION_MATCH_Msk: u32 = 15;
pub const TPI_ACPR_PRESCALER_Pos: u32 = 0;
pub const TPI_ACPR_PRESCALER_Msk: u32 = 8191;
pub const TPI_SPPR_TXMODE_Pos: u32 = 0;
pub const TPI_SPPR_TXMODE_Msk: u32 = 3;
pub const TPI_FFSR_FtNonStop_Pos: u32 = 3;
pub const TPI_FFSR_FtNonStop_Msk: u32 = 8;
pub const TPI_FFSR_TCPresent_Pos: u32 = 2;
pub const TPI_FFSR_TCPresent_Msk: u32 = 4;
pub const TPI_FFSR_FtStopped_Pos: u32 = 1;
pub const TPI_FFSR_FtStopped_Msk: u32 = 2;
pub const TPI_FFSR_FlInProg_Pos: u32 = 0;
pub const TPI_FFSR_FlInProg_Msk: u32 = 1;
pub const TPI_FFCR_TrigIn_Pos: u32 = 8;
pub const TPI_FFCR_TrigIn_Msk: u32 = 256;
pub const TPI_FFCR_EnFCont_Pos: u32 = 1;
pub const TPI_FFCR_EnFCont_Msk: u32 = 2;
pub const TPI_TRIGGER_TRIGGER_Pos: u32 = 0;
pub const TPI_TRIGGER_TRIGGER_Msk: u32 = 1;
pub const TPI_FIFO0_ITM_ATVALID_Pos: u32 = 29;
pub const TPI_FIFO0_ITM_ATVALID_Msk: u32 = 1610612736;
pub const TPI_FIFO0_ITM_bytecount_Pos: u32 = 27;
pub const TPI_FIFO0_ITM_bytecount_Msk: u32 = 402653184;
pub const TPI_FIFO0_ETM_ATVALID_Pos: u32 = 26;
pub const TPI_FIFO0_ETM_ATVALID_Msk: u32 = 201326592;
pub const TPI_FIFO0_ETM_bytecount_Pos: u32 = 24;
pub const TPI_FIFO0_ETM_bytecount_Msk: u32 = 50331648;
pub const TPI_FIFO0_ETM2_Pos: u32 = 16;
pub const TPI_FIFO0_ETM2_Msk: u32 = 16711680;
pub const TPI_FIFO0_ETM1_Pos: u32 = 8;
pub const TPI_FIFO0_ETM1_Msk: u32 = 65280;
pub const TPI_FIFO0_ETM0_Pos: u32 = 0;
pub const TPI_FIFO0_ETM0_Msk: u32 = 255;
pub const TPI_ITATBCTR2_ATREADY_Pos: u32 = 0;
pub const TPI_ITATBCTR2_ATREADY_Msk: u32 = 1;
pub const TPI_FIFO1_ITM_ATVALID_Pos: u32 = 29;
pub const TPI_FIFO1_ITM_ATVALID_Msk: u32 = 1610612736;
pub const TPI_FIFO1_ITM_bytecount_Pos: u32 = 27;
pub const TPI_FIFO1_ITM_bytecount_Msk: u32 = 402653184;
pub const TPI_FIFO1_ETM_ATVALID_Pos: u32 = 26;
pub const TPI_FIFO1_ETM_ATVALID_Msk: u32 = 201326592;
pub const TPI_FIFO1_ETM_bytecount_Pos: u32 = 24;
pub const TPI_FIFO1_ETM_bytecount_Msk: u32 = 50331648;
pub const TPI_FIFO1_ITM2_Pos: u32 = 16;
pub const TPI_FIFO1_ITM2_Msk: u32 = 16711680;
pub const TPI_FIFO1_ITM1_Pos: u32 = 8;
pub const TPI_FIFO1_ITM1_Msk: u32 = 65280;
pub const TPI_FIFO1_ITM0_Pos: u32 = 0;
pub const TPI_FIFO1_ITM0_Msk: u32 = 255;
pub const TPI_ITATBCTR0_ATREADY_Pos: u32 = 0;
pub const TPI_ITATBCTR0_ATREADY_Msk: u32 = 1;
pub const TPI_ITCTRL_Mode_Pos: u32 = 0;
pub const TPI_ITCTRL_Mode_Msk: u32 = 1;
pub const TPI_DEVID_NRZVALID_Pos: u32 = 11;
pub const TPI_DEVID_NRZVALID_Msk: u32 = 2048;
pub const TPI_DEVID_MANCVALID_Pos: u32 = 10;
pub const TPI_DEVID_MANCVALID_Msk: u32 = 1024;
pub const TPI_DEVID_PTINVALID_Pos: u32 = 9;
pub const TPI_DEVID_PTINVALID_Msk: u32 = 512;
pub const TPI_DEVID_MinBufSz_Pos: u32 = 6;
pub const TPI_DEVID_MinBufSz_Msk: u32 = 448;
pub const TPI_DEVID_AsynClkIn_Pos: u32 = 5;
pub const TPI_DEVID_AsynClkIn_Msk: u32 = 32;
pub const TPI_DEVID_NrTraceInput_Pos: u32 = 0;
pub const TPI_DEVID_NrTraceInput_Msk: u32 = 31;
pub const TPI_DEVTYPE_MajorType_Pos: u32 = 4;
pub const TPI_DEVTYPE_MajorType_Msk: u32 = 240;
pub const TPI_DEVTYPE_SubType_Pos: u32 = 0;
pub const TPI_DEVTYPE_SubType_Msk: u32 = 15;
pub const MPU_TYPE_IREGION_Pos: u32 = 16;
pub const MPU_TYPE_IREGION_Msk: u32 = 16711680;
pub const MPU_TYPE_DREGION_Pos: u32 = 8;
pub const MPU_TYPE_DREGION_Msk: u32 = 65280;
pub const MPU_TYPE_SEPARATE_Pos: u32 = 0;
pub const MPU_TYPE_SEPARATE_Msk: u32 = 1;
pub const MPU_CTRL_PRIVDEFENA_Pos: u32 = 2;
pub const MPU_CTRL_PRIVDEFENA_Msk: u32 = 4;
pub const MPU_CTRL_HFNMIENA_Pos: u32 = 1;
pub const MPU_CTRL_HFNMIENA_Msk: u32 = 2;
pub const MPU_CTRL_ENABLE_Pos: u32 = 0;
pub const MPU_CTRL_ENABLE_Msk: u32 = 1;
pub const MPU_RNR_REGION_Pos: u32 = 0;
pub const MPU_RNR_REGION_Msk: u32 = 255;
pub const MPU_RBAR_ADDR_Pos: u32 = 5;
pub const MPU_RBAR_ADDR_Msk: u32 = 4294967264;
pub const MPU_RBAR_SH_Pos: u32 = 3;
pub const MPU_RBAR_SH_Msk: u32 = 24;
pub const MPU_RBAR_AP_Pos: u32 = 1;
pub const MPU_RBAR_AP_Msk: u32 = 6;
pub const MPU_RBAR_XN_Pos: u32 = 0;
pub const MPU_RBAR_XN_Msk: u32 = 1;
pub const MPU_RLAR_LIMIT_Pos: u32 = 5;
pub const MPU_RLAR_LIMIT_Msk: u32 = 4294967264;
pub const MPU_RLAR_AttrIndx_Pos: u32 = 1;
pub const MPU_RLAR_AttrIndx_Msk: u32 = 14;
pub const MPU_RLAR_EN_Pos: u32 = 0;
pub const MPU_RLAR_EN_Msk: u32 = 1;
pub const MPU_MAIR0_Attr3_Pos: u32 = 24;
pub const MPU_MAIR0_Attr3_Msk: u32 = 4278190080;
pub const MPU_MAIR0_Attr2_Pos: u32 = 16;
pub const MPU_MAIR0_Attr2_Msk: u32 = 16711680;
pub const MPU_MAIR0_Attr1_Pos: u32 = 8;
pub const MPU_MAIR0_Attr1_Msk: u32 = 65280;
pub const MPU_MAIR0_Attr0_Pos: u32 = 0;
pub const MPU_MAIR0_Attr0_Msk: u32 = 255;
pub const MPU_MAIR1_Attr7_Pos: u32 = 24;
pub const MPU_MAIR1_Attr7_Msk: u32 = 4278190080;
pub const MPU_MAIR1_Attr6_Pos: u32 = 16;
pub const MPU_MAIR1_Attr6_Msk: u32 = 16711680;
pub const MPU_MAIR1_Attr5_Pos: u32 = 8;
pub const MPU_MAIR1_Attr5_Msk: u32 = 65280;
pub const MPU_MAIR1_Attr4_Pos: u32 = 0;
pub const MPU_MAIR1_Attr4_Msk: u32 = 255;
pub const SAU_CTRL_ALLNS_Pos: u32 = 1;
pub const SAU_CTRL_ALLNS_Msk: u32 = 2;
pub const SAU_CTRL_ENABLE_Pos: u32 = 0;
pub const SAU_CTRL_ENABLE_Msk: u32 = 1;
pub const SAU_TYPE_SREGION_Pos: u32 = 0;
pub const SAU_TYPE_SREGION_Msk: u32 = 255;
pub const SAU_RNR_REGION_Pos: u32 = 0;
pub const SAU_RNR_REGION_Msk: u32 = 255;
pub const SAU_RBAR_BADDR_Pos: u32 = 5;
pub const SAU_RBAR_BADDR_Msk: u32 = 4294967264;
pub const SAU_RLAR_LADDR_Pos: u32 = 5;
pub const SAU_RLAR_LADDR_Msk: u32 = 4294967264;
pub const SAU_RLAR_NSC_Pos: u32 = 1;
pub const SAU_RLAR_NSC_Msk: u32 = 2;
pub const SAU_RLAR_ENABLE_Pos: u32 = 0;
pub const SAU_RLAR_ENABLE_Msk: u32 = 1;
pub const SAU_SFSR_LSERR_Pos: u32 = 7;
pub const SAU_SFSR_LSERR_Msk: u32 = 128;
pub const SAU_SFSR_SFARVALID_Pos: u32 = 6;
pub const SAU_SFSR_SFARVALID_Msk: u32 = 64;
pub const SAU_SFSR_LSPERR_Pos: u32 = 5;
pub const SAU_SFSR_LSPERR_Msk: u32 = 32;
pub const SAU_SFSR_INVTRAN_Pos: u32 = 4;
pub const SAU_SFSR_INVTRAN_Msk: u32 = 16;
pub const SAU_SFSR_AUVIOL_Pos: u32 = 3;
pub const SAU_SFSR_AUVIOL_Msk: u32 = 8;
pub const SAU_SFSR_INVER_Pos: u32 = 2;
pub const SAU_SFSR_INVER_Msk: u32 = 4;
pub const SAU_SFSR_INVIS_Pos: u32 = 1;
pub const SAU_SFSR_INVIS_Msk: u32 = 2;
pub const SAU_SFSR_INVEP_Pos: u32 = 0;
pub const SAU_SFSR_INVEP_Msk: u32 = 1;
pub const FPU_FPCCR_ASPEN_Pos: u32 = 31;
pub const FPU_FPCCR_ASPEN_Msk: u32 = 2147483648;
pub const FPU_FPCCR_LSPEN_Pos: u32 = 30;
pub const FPU_FPCCR_LSPEN_Msk: u32 = 1073741824;
pub const FPU_FPCCR_LSPENS_Pos: u32 = 29;
pub const FPU_FPCCR_LSPENS_Msk: u32 = 536870912;
pub const FPU_FPCCR_CLRONRET_Pos: u32 = 28;
pub const FPU_FPCCR_CLRONRET_Msk: u32 = 268435456;
pub const FPU_FPCCR_CLRONRETS_Pos: u32 = 27;
pub const FPU_FPCCR_CLRONRETS_Msk: u32 = 134217728;
pub const FPU_FPCCR_TS_Pos: u32 = 26;
pub const FPU_FPCCR_TS_Msk: u32 = 67108864;
pub const FPU_FPCCR_UFRDY_Pos: u32 = 10;
pub const FPU_FPCCR_UFRDY_Msk: u32 = 1024;
pub const FPU_FPCCR_SPLIMVIOL_Pos: u32 = 9;
pub const FPU_FPCCR_SPLIMVIOL_Msk: u32 = 512;
pub const FPU_FPCCR_MONRDY_Pos: u32 = 8;
pub const FPU_FPCCR_MONRDY_Msk: u32 = 256;
pub const FPU_FPCCR_SFRDY_Pos: u32 = 7;
pub const FPU_FPCCR_SFRDY_Msk: u32 = 128;
pub const FPU_FPCCR_BFRDY_Pos: u32 = 6;
pub const FPU_FPCCR_BFRDY_Msk: u32 = 64;
pub const FPU_FPCCR_MMRDY_Pos: u32 = 5;
pub const FPU_FPCCR_MMRDY_Msk: u32 = 32;
pub const FPU_FPCCR_HFRDY_Pos: u32 = 4;
pub const FPU_FPCCR_HFRDY_Msk: u32 = 16;
pub const FPU_FPCCR_THREAD_Pos: u32 = 3;
pub const FPU_FPCCR_THREAD_Msk: u32 = 8;
pub const FPU_FPCCR_S_Pos: u32 = 2;
pub const FPU_FPCCR_S_Msk: u32 = 4;
pub const FPU_FPCCR_USER_Pos: u32 = 1;
pub const FPU_FPCCR_USER_Msk: u32 = 2;
pub const FPU_FPCCR_LSPACT_Pos: u32 = 0;
pub const FPU_FPCCR_LSPACT_Msk: u32 = 1;
pub const FPU_FPCAR_ADDRESS_Pos: u32 = 3;
pub const FPU_FPCAR_ADDRESS_Msk: u32 = 4294967288;
pub const FPU_FPDSCR_AHP_Pos: u32 = 26;
pub const FPU_FPDSCR_AHP_Msk: u32 = 67108864;
pub const FPU_FPDSCR_DN_Pos: u32 = 25;
pub const FPU_FPDSCR_DN_Msk: u32 = 33554432;
pub const FPU_FPDSCR_FZ_Pos: u32 = 24;
pub const FPU_FPDSCR_FZ_Msk: u32 = 16777216;
pub const FPU_FPDSCR_RMode_Pos: u32 = 22;
pub const FPU_FPDSCR_RMode_Msk: u32 = 12582912;
pub const FPU_MVFR0_FP_rounding_modes_Pos: u32 = 28;
pub const FPU_MVFR0_FP_rounding_modes_Msk: u32 = 4026531840;
pub const FPU_MVFR0_Short_vectors_Pos: u32 = 24;
pub const FPU_MVFR0_Short_vectors_Msk: u32 = 251658240;
pub const FPU_MVFR0_Square_root_Pos: u32 = 20;
pub const FPU_MVFR0_Square_root_Msk: u32 = 15728640;
pub const FPU_MVFR0_Divide_Pos: u32 = 16;
pub const FPU_MVFR0_Divide_Msk: u32 = 983040;
pub const FPU_MVFR0_FP_excep_trapping_Pos: u32 = 12;
pub const FPU_MVFR0_FP_excep_trapping_Msk: u32 = 61440;
pub const FPU_MVFR0_Double_precision_Pos: u32 = 8;
pub const FPU_MVFR0_Double_precision_Msk: u32 = 3840;
pub const FPU_MVFR0_Single_precision_Pos: u32 = 4;
pub const FPU_MVFR0_Single_precision_Msk: u32 = 240;
pub const FPU_MVFR0_A_SIMD_registers_Pos: u32 = 0;
pub const FPU_MVFR0_A_SIMD_registers_Msk: u32 = 15;
pub const FPU_MVFR1_FP_fused_MAC_Pos: u32 = 28;
pub const FPU_MVFR1_FP_fused_MAC_Msk: u32 = 4026531840;
pub const FPU_MVFR1_FP_HPFP_Pos: u32 = 24;
pub const FPU_MVFR1_FP_HPFP_Msk: u32 = 251658240;
pub const FPU_MVFR1_D_NaN_mode_Pos: u32 = 4;
pub const FPU_MVFR1_D_NaN_mode_Msk: u32 = 240;
pub const FPU_MVFR1_FtZ_mode_Pos: u32 = 0;
pub const FPU_MVFR1_FtZ_mode_Msk: u32 = 15;
pub const CoreDebug_DHCSR_DBGKEY_Pos: u32 = 16;
pub const CoreDebug_DHCSR_DBGKEY_Msk: u32 = 4294901760;
pub const CoreDebug_DHCSR_S_RESTART_ST_Pos: u32 = 26;
pub const CoreDebug_DHCSR_S_RESTART_ST_Msk: u32 = 67108864;
pub const CoreDebug_DHCSR_S_RESET_ST_Pos: u32 = 25;
pub const CoreDebug_DHCSR_S_RESET_ST_Msk: u32 = 33554432;
pub const CoreDebug_DHCSR_S_RETIRE_ST_Pos: u32 = 24;
pub const CoreDebug_DHCSR_S_RETIRE_ST_Msk: u32 = 16777216;
pub const CoreDebug_DHCSR_S_LOCKUP_Pos: u32 = 19;
pub const CoreDebug_DHCSR_S_LOCKUP_Msk: u32 = 524288;
pub const CoreDebug_DHCSR_S_SLEEP_Pos: u32 = 18;
pub const CoreDebug_DHCSR_S_SLEEP_Msk: u32 = 262144;
pub const CoreDebug_DHCSR_S_HALT_Pos: u32 = 17;
pub const CoreDebug_DHCSR_S_HALT_Msk: u32 = 131072;
pub const CoreDebug_DHCSR_S_REGRDY_Pos: u32 = 16;
pub const CoreDebug_DHCSR_S_REGRDY_Msk: u32 = 65536;
pub const CoreDebug_DHCSR_C_SNAPSTALL_Pos: u32 = 5;
pub const CoreDebug_DHCSR_C_SNAPSTALL_Msk: u32 = 32;
pub const CoreDebug_DHCSR_C_MASKINTS_Pos: u32 = 3;
pub const CoreDebug_DHCSR_C_MASKINTS_Msk: u32 = 8;
pub const CoreDebug_DHCSR_C_STEP_Pos: u32 = 2;
pub const CoreDebug_DHCSR_C_STEP_Msk: u32 = 4;
pub const CoreDebug_DHCSR_C_HALT_Pos: u32 = 1;
pub const CoreDebug_DHCSR_C_HALT_Msk: u32 = 2;
pub const CoreDebug_DHCSR_C_DEBUGEN_Pos: u32 = 0;
pub const CoreDebug_DHCSR_C_DEBUGEN_Msk: u32 = 1;
pub const CoreDebug_DCRSR_REGWnR_Pos: u32 = 16;
pub const CoreDebug_DCRSR_REGWnR_Msk: u32 = 65536;
pub const CoreDebug_DCRSR_REGSEL_Pos: u32 = 0;
pub const CoreDebug_DCRSR_REGSEL_Msk: u32 = 31;
pub const CoreDebug_DEMCR_TRCENA_Pos: u32 = 24;
pub const CoreDebug_DEMCR_TRCENA_Msk: u32 = 16777216;
pub const CoreDebug_DEMCR_MON_REQ_Pos: u32 = 19;
pub const CoreDebug_DEMCR_MON_REQ_Msk: u32 = 524288;
pub const CoreDebug_DEMCR_MON_STEP_Pos: u32 = 18;
pub const CoreDebug_DEMCR_MON_STEP_Msk: u32 = 262144;
pub const CoreDebug_DEMCR_MON_PEND_Pos: u32 = 17;
pub const CoreDebug_DEMCR_MON_PEND_Msk: u32 = 131072;
pub const CoreDebug_DEMCR_MON_EN_Pos: u32 = 16;
pub const CoreDebug_DEMCR_MON_EN_Msk: u32 = 65536;
pub const CoreDebug_DEMCR_VC_HARDERR_Pos: u32 = 10;
pub const CoreDebug_DEMCR_VC_HARDERR_Msk: u32 = 1024;
pub const CoreDebug_DEMCR_VC_INTERR_Pos: u32 = 9;
pub const CoreDebug_DEMCR_VC_INTERR_Msk: u32 = 512;
pub const CoreDebug_DEMCR_VC_BUSERR_Pos: u32 = 8;
pub const CoreDebug_DEMCR_VC_BUSERR_Msk: u32 = 256;
pub const CoreDebug_DEMCR_VC_STATERR_Pos: u32 = 7;
pub const CoreDebug_DEMCR_VC_STATERR_Msk: u32 = 128;
pub const CoreDebug_DEMCR_VC_CHKERR_Pos: u32 = 6;
pub const CoreDebug_DEMCR_VC_CHKERR_Msk: u32 = 64;
pub const CoreDebug_DEMCR_VC_NOCPERR_Pos: u32 = 5;
pub const CoreDebug_DEMCR_VC_NOCPERR_Msk: u32 = 32;
pub const CoreDebug_DEMCR_VC_MMERR_Pos: u32 = 4;
pub const CoreDebug_DEMCR_VC_MMERR_Msk: u32 = 16;
pub const CoreDebug_DEMCR_VC_CORERESET_Pos: u32 = 0;
pub const CoreDebug_DEMCR_VC_CORERESET_Msk: u32 = 1;
pub const CoreDebug_DAUTHCTRL_INTSPNIDEN_Pos: u32 = 3;
pub const CoreDebug_DAUTHCTRL_INTSPNIDEN_Msk: u32 = 8;
pub const CoreDebug_DAUTHCTRL_SPNIDENSEL_Pos: u32 = 2;
pub const CoreDebug_DAUTHCTRL_SPNIDENSEL_Msk: u32 = 4;
pub const CoreDebug_DAUTHCTRL_INTSPIDEN_Pos: u32 = 1;
pub const CoreDebug_DAUTHCTRL_INTSPIDEN_Msk: u32 = 2;
pub const CoreDebug_DAUTHCTRL_SPIDENSEL_Pos: u32 = 0;
pub const CoreDebug_DAUTHCTRL_SPIDENSEL_Msk: u32 = 1;
pub const CoreDebug_DSCSR_CDS_Pos: u32 = 16;
pub const CoreDebug_DSCSR_CDS_Msk: u32 = 65536;
pub const CoreDebug_DSCSR_SBRSEL_Pos: u32 = 1;
pub const CoreDebug_DSCSR_SBRSEL_Msk: u32 = 2;
pub const CoreDebug_DSCSR_SBRSELEN_Pos: u32 = 0;
pub const CoreDebug_DSCSR_SBRSELEN_Msk: u32 = 1;
pub const SCS_BASE: u32 = 3758153728;
pub const ITM_BASE: u32 = 3758096384;
pub const DWT_BASE: u32 = 3758100480;
pub const TPI_BASE: u32 = 3758358528;
pub const CoreDebug_BASE: u32 = 3758157296;
pub const SysTick_BASE: u32 = 3758153744;
pub const NVIC_BASE: u32 = 3758153984;
pub const SCB_BASE: u32 = 3758157056;
pub const MPU_BASE: u32 = 3758157200;
pub const SAU_BASE: u32 = 3758157264;
pub const FPU_BASE: u32 = 3758157616;
pub const SCS_BASE_NS: u32 = 3758284800;
pub const CoreDebug_BASE_NS: u32 = 3758288368;
pub const SysTick_BASE_NS: u32 = 3758284816;
pub const NVIC_BASE_NS: u32 = 3758285056;
pub const SCB_BASE_NS: u32 = 3758288128;
pub const MPU_BASE_NS: u32 = 3758288272;
pub const FPU_BASE_NS: u32 = 3758288688;
pub const NVIC_USER_IRQ_OFFSET: u32 = 16;
pub const __ICACHE_PRESENT: u32 = 1;
pub const __DCACHE_PRESENT: u32 = 1;
pub const MPU_EXEC_ALLOW: u32 = 0;
pub const MPU_EXEC_NEVER: u32 = 1;
pub const MPU_PRIV_RW: u32 = 0;
pub const MPU_UN_PRIV_RW: u32 = 2;
pub const MPU_PRIV_R: u32 = 4;
pub const MPU_PRIV_W: u32 = 6;
pub const MPU_NON_SHAREABLE: u32 = 0;
pub const MPU_OUT_SHAREABLE: u32 = 16;
pub const MPU_INR_SHAREABLE: u32 = 24;
pub const MPU_MAX_REGION: u32 = 8;
pub const NORMAL_WT_T_WA: u32 = 1;
pub const NORMAL_WT_T_RA: u32 = 2;
pub const NORMAL_WT_T_RWA: u32 = 3;
pub const NORMAL_NC: u32 = 4;
pub const NORMAL_WB_T_WA: u32 = 5;
pub const NORMAL_WB_T_RA: u32 = 6;
pub const NORMAL_WB_T_RWA: u32 = 7;
pub const NORMAL_WT_NT: u32 = 8;
pub const NORMAL_WT_NT_WA: u32 = 9;
pub const NORMAL_WT_NT_RA: u32 = 10;
pub const NORMAL_WT_NT_RWA: u32 = 11;
pub const NORMAL_WB_NT: u32 = 12;
pub const NORMAL_WB_NT_WA: u32 = 13;
pub const NORMAL_WB_NT_RA: u32 = 14;
pub const NORMAL_WB_NT_RWA: u32 = 15;
pub const DEVICE_NG_NR_NE: u32 = 0;
pub const DEVICE_NG_NR_E: u32 = 4;
pub const DEVICE_NG_R_E: u32 = 8;
pub const DEVICE_G_R_E: u32 = 12;
pub const MPU_INIT_CTRL_ENABLE: u32 = 1;
pub const MPU_INIT_CTRL_PRIVDEFENA: u32 = 1;
pub const MPU_INIT_CTRL_HFNMIENA: u32 = 0;
pub const MPU_MEM_ATTR0: u32 = 68;
pub const MPU_MEM_ATTR1: u32 = 34;
pub const MPU_MEM_ATTR2: u32 = 119;
pub const MPU_MEM_ATTR3: u32 = 0;
pub const MPU_MEM_ATTR4: u32 = 0;
pub const MPU_MEM_ATTR5: u32 = 0;
pub const MPU_MEM_ATTR6: u32 = 0;
pub const MPU_MEM_ATTR7: u32 = 0;
pub const MPU_MEM_ATTR_IDX_NC: u32 = 0;
pub const MPU_MEM_ATTR_IDX_WT_T_RA: u32 = 1;
pub const MPU_MEM_ATTR_IDX_WB_T_RWA: u32 = 2;
pub const MPU_MEM_ATTR_IDX_DEVICE: u32 = 3;
pub const MAX_GDMA_INDX: u32 = 0;
pub const MAX_GDMA_CHNL: u32 = 5;
pub const GDMA_HANDSHAKE_INTERFACE_UART0_TX: u32 = 0;
pub const GDMA_HANDSHAKE_INTERFACE_UART0_RX: u32 = 1;
pub const GDMA_HANDSHAKE_INTERFACE_UART1_TX: u32 = 2;
pub const GDMA_HANDSHAKE_INTERFACE_UART1_RX: u32 = 3;
pub const GDMA_HANDSHAKE_INTERFACE_UART3_TX: u32 = 6;
pub const GDMA_HANDSHAKE_INTERFACE_UART3_RX: u32 = 7;
pub const GDMA_HANDSHAKE_INTERFACE_SPI0_TX: u32 = 4;
pub const GDMA_HANDSHAKE_INTERFACE_SPI0_RX: u32 = 5;
pub const GDMA_HANDSHAKE_INTERFACE_SPI1_TX: u32 = 6;
pub const GDMA_HANDSHAKE_INTERFACE_SPI1_RX: u32 = 7;
pub const GDMA_HANDSHAKE_INTERFACE_I2C0_TX: u32 = 2;
pub const GDMA_HANDSHAKE_INTERFACE_I2C0_RX: u32 = 3;
pub const GDMA_HANDSHAKE_INTERFACE_ADC_RX: u32 = 5;
pub const GDMA_HANDSHAKE_INTERFACE_AUDIO_TX: u32 = 10;
pub const GDMA_HANDSHAKE_INTERFACE_AUDIO_RX: u32 = 11;
pub const GDMA_HANDSHAKE_INTERFACE_USI0_TX: u32 = 8;
pub const GDMA_HANDSHAKE_INTERFACE_USI0_RX: u32 = 9;
pub const GDMA_HANDSHAKE_INTERFACE_SGPIO_TX: u32 = 4;
pub const GDMA_HANDSHAKE_TIMER_CAPTURE_UP: u32 = 0;
pub const GDMA_HANDSHAKE_TIMER_CAPTURE_CH0: u32 = 1;
pub const GDMA_HANDSHAKE_TIMER_PWM_UP: u32 = 2;
pub const GDMA_HANDSHAKE_TIMER_PWM_CH0: u32 = 3;
pub const GDMA_HANDSHAKE_TIMER_PWM_CH1: u32 = 4;
pub const GDMA_HANDSHAKE_TIMER_PWM_CH2: u32 = 5;
pub const GDMA_HANDSHAKE_TIMER_PWM_CH3: u32 = 6;
pub const GDMA_HANDSHAKE_TIMER_PWM_CH4: u32 = 7;
pub const GDMA_HANDSHAKE_TIMER_PWM_CH5: u32 = 8;
pub const REG_GDMA_CH_OFF: u32 = 88;
pub const REG_GDMA_CH_SAR: u32 = 0;
pub const REG_GDMA_CH_DAR: u32 = 8;
pub const REG_GDMA_CH_LLP: u32 = 16;
pub const REG_GDMA_CH_CTL: u32 = 24;
pub const REG_GDMA_CH_SSTAT: u32 = 32;
pub const REG_GDMA_CH_DSTAT: u32 = 40;
pub const REG_GDMA_CH_SSTATAR: u32 = 48;
pub const REG_GDMA_CH_DSTATAR: u32 = 56;
pub const REG_GDMA_CH_CFG: u32 = 64;
pub const REG_GDMA_CH_SGR: u32 = 72;
pub const REG_GDMA_CH_DSR: u32 = 80;
pub const REG_GDMA_RAW_INT_BASE: u32 = 704;
pub const REG_GDMA_RAW_INT_TFR: u32 = 704;
pub const REG_GDMA_RAW_INT_BLOCK: u32 = 712;
pub const REG_GDMA_RAW_INT_SRC_TRAN: u32 = 720;
pub const REG_GDMA_RAW_INT_DST_TRAN: u32 = 728;
pub const REG_GDMA_RAW_INT_ERR: u32 = 736;
pub const REG_GDMA_STATUS_INT_BASE: u32 = 744;
pub const REG_GDMA_STATUS_INT_TFR: u32 = 744;
pub const REG_GDMA_STATUS_INT_BLOCK: u32 = 752;
pub const REG_GDMA_STATUS_INT_SRC_TRAN: u32 = 760;
pub const REG_GDMA_STATUS_INT_DST_TRAN: u32 = 768;
pub const REG_GDMA_STATUS_INT_ERR: u32 = 776;
pub const REG_GDMA_MASK_INT_BASE: u32 = 784;
pub const REG_GDMA_MASK_INT_TFR: u32 = 784;
pub const REG_GDMA_MASK_INT_BLOCK: u32 = 792;
pub const REG_GDMA_MASK_INT_SRC_TRAN: u32 = 800;
pub const REG_GDMA_MASK_INT_DST_TRAN: u32 = 808;
pub const REG_GDMA_MASK_INT_INT_ERR: u32 = 816;
pub const REG_GDMA_CLEAR_INT_BASE: u32 = 824;
pub const REG_GDMA_CLEAR_INT_TFR: u32 = 824;
pub const REG_GDMA_CLEAR_INT_BLOCK: u32 = 832;
pub const REG_GDMA_CLEAR_INT_SRC_TRAN: u32 = 840;
pub const REG_GDMA_CLEAR_INT_DST_TRAN: u32 = 848;
pub const REG_GDMA_CLEAR_INT_ERR: u32 = 856;
pub const REG_GDMA_STATUS_INT: u32 = 864;
pub const REG_GDMA_REQ_SRC: u32 = 872;
pub const REG_GDMA_REQ_DST: u32 = 880;
pub const REG_GDMA_REQ_SGL_REQ: u32 = 888;
pub const REG_GDMA_REQ_DST_REQ: u32 = 896;
pub const REG_GDMA_REQ_LST_SRC: u32 = 904;
pub const REG_GDMA_REQ_LST_DST: u32 = 912;
pub const REG_GDMA_DMAC_CFG: u32 = 920;
pub const REG_GDMA_CH_EN: u32 = 928;
pub const REG_GDMA_DMA_ID: u32 = 936;
pub const REG_GDMA_DMA_TEST: u32 = 944;
pub const REG_GDMA_DMA_COM_PARAMS6: u32 = 968;
pub const REG_GDMA_DMA_COM_PARAMS5: u32 = 976;
pub const REG_GDMA_DMA_COM_PARAMS4: u32 = 984;
pub const REG_GDMA_DMA_COM_PARAMS3: u32 = 992;
pub const REG_GDMA_DMA_COM_PARAMS2: u32 = 1000;
pub const REG_GDMA_DMA_COM_PARAMS1: u32 = 1008;
pub const REG_GDMA_DMA_COM_PARAMS0: u32 = 1016;
pub const TIMER_TICK_US: u32 = 31;
pub const TIMER_TICK_US_X4: u32 = 125;
pub const GPIO_Mode_IN: u32 = 0;
pub const GPIO_Mode_OUT: u32 = 1;
pub const GPIO_Mode_INT: u32 = 2;
pub const GPIO_PuPd_NOPULL: u32 = 0;
pub const GPIO_PuPd_DOWN: u32 = 1;
pub const GPIO_PuPd_UP: u32 = 2;
pub const GPIO_PuPd_SHUTDOWN: u32 = 3;
pub const GPIO_INT_Trigger_LEVEL: u32 = 0;
pub const GPIO_INT_Trigger_EDGE: u32 = 1;
pub const GPIO_INT_Trigger_BOTHEDGE: u32 = 2;
pub const GPIO_INT_POLARITY_ACTIVE_LOW: u32 = 0;
pub const GPIO_INT_POLARITY_ACTIVE_HIGH: u32 = 1;
pub const GPIO_INT_DEBOUNCE_DISABLE: u32 = 0;
pub const GPIO_INT_DEBOUNCE_ENABLE: u32 = 1;
pub const GPIO_PIN_LOW: u32 = 0;
pub const GPIO_PIN_HIGH: u32 = 1;
pub const GPIO_PORT_A: u32 = 0;
pub const GPIO_PORT_B: u32 = 1;
pub const HAL_IRQ_NONE: u32 = 0;
pub const HAL_IRQ_RISE: u32 = 1;
pub const HAL_IRQ_FALL: u32 = 2;
pub const TMOD_TR: u32 = 0;
pub const TMOD_TO: u32 = 1;
pub const TMOD_RO: u32 = 2;
pub const TMOD_EEPROM_R: u32 = 3;
pub const SCPOL_INACTIVE_IS_LOW: u32 = 0;
pub const SCPOL_INACTIVE_IS_HIGH: u32 = 1;
pub const SCPH_TOGGLES_IN_MIDDLE: u32 = 0;
pub const SCPH_TOGGLES_AT_START: u32 = 1;
pub const DFS_4_BITS: u32 = 3;
pub const DFS_5_BITS: u32 = 4;
pub const DFS_6_BITS: u32 = 5;
pub const DFS_7_BITS: u32 = 6;
pub const DFS_8_BITS: u32 = 7;
pub const DFS_9_BITS: u32 = 8;
pub const DFS_10_BITS: u32 = 9;
pub const DFS_11_BITS: u32 = 10;
pub const DFS_12_BITS: u32 = 11;
pub const DFS_13_BITS: u32 = 12;
pub const DFS_14_BITS: u32 = 13;
pub const DFS_15_BITS: u32 = 14;
pub const DFS_16_BITS: u32 = 15;
pub const SPI_SS_NOT_TOGGLE: u32 = 0;
pub const SPI_SS_TOGGLE: u32 = 1;
pub const CFS_1_BIT: u32 = 0;
pub const CFS_2_BITS: u32 = 1;
pub const CFS_3_BITS: u32 = 2;
pub const CFS_4_BITS: u32 = 3;
pub const CFS_5_BITS: u32 = 4;
pub const CFS_6_BITS: u32 = 5;
pub const CFS_7_BITS: u32 = 6;
pub const CFS_8_BITS: u32 = 7;
pub const CFS_9_BITS: u32 = 8;
pub const CFS_10_BITS: u32 = 9;
pub const CFS_11_BITS: u32 = 10;
pub const CFS_12_BITS: u32 = 11;
pub const CFS_13_BITS: u32 = 12;
pub const CFS_14_BITS: u32 = 13;
pub const CFS_15_BITS: u32 = 14;
pub const CFS_16_BITS: u32 = 15;
pub const SSI_SLAVE: u32 = 0;
pub const SSI_MASTER: u32 = 1;
pub const FRF_MOTOROLA_SPI: u32 = 0;
pub const FRF_TI_SSP: u32 = 1;
pub const FRF_NS_MICROWIRE: u32 = 2;
pub const FRF_RSVD: u32 = 3;
pub const SSI_NODMA: u32 = 0;
pub const SSI_RXDMA_ENABLE: u32 = 1;
pub const SSI_TXDMA_ENABLE: u32 = 2;
pub const SSI_TRDMA_ENABLE: u32 = 3;
pub const MW_HANDSHAKE_DISABLE: u32 = 0;
pub const MW_HANDSHAKE_ENABLE: u32 = 1;
pub const MW_DIRECTION_SLAVE_TO_MASTER: u32 = 0;
pub const MW_DIRECTION_MASTER_TO_SLAVE: u32 = 1;
pub const MW_TMOD_NONSEQUENTIAL: u32 = 0;
pub const MW_TMOD_SEQUENTIAL: u32 = 1;
pub const SSI_TX_FIFO_DEPTH: u32 = 64;
pub const SSI_RX_FIFO_DEPTH: u32 = 64;
pub const SPI_SLAVE_TXERR_WORK_AROUND: u32 = 1;
pub const STATETX_DMA: u32 = 1;
pub const STATETX_INT: u32 = 2;
pub const STATETX_POLL: u32 = 3;
pub const STATERX_DMA: u32 = 1;
pub const STATERX_INT: u32 = 2;
pub const STATERX_POLL: u32 = 3;
pub const MAX_UART_INDEX: u32 = 4;
pub const I2C_SS_MIN_SCL_HTIME: u32 = 4000;
pub const I2C_SS_MIN_SCL_LTIME: u32 = 4700;
pub const I2C_FS_MIN_SCL_HTIME: u32 = 600;
pub const I2C_FS_MIN_SCL_LTIME: u32 = 1300;
pub const I2C_HS_MIN_SCL_HTIME_100: u32 = 60;
pub const I2C_HS_MIN_SCL_LTIME_100: u32 = 120;
pub const I2C_HS_MIN_SCL_HTIME_400: u32 = 160;
pub const I2C_HS_MIN_SCL_LTIME_400: u32 = 320;
pub const ADC_CH_NUM: u32 = 11;
pub const BIT_SHIFT_CVLIST_LEN: u32 = 4;
pub const BIT_SHIFT_OP_MODE: u32 = 1;
pub const BIT_SHIFT_COMP_TH_H: u32 = 16;
pub const BIT_SHIFT_COMP_TH_L: u32 = 0;
pub const BIT_SHIFT_DMA_LVL: u32 = 8;
pub const COMP_CH_NUM: u32 = 4;
pub const COMP_WK_NONE: u32 = 0;
pub const BIT_SHIFT_COMP_REF1: u32 = 16;
pub const BIT_SHIFT_COMP_REF0: u32 = 0;
pub const BIT_SHIFT_COMP_CHSW_CNT: u32 = 8;
pub const SDIO_MP_START: u32 = 1;
pub const SDIO_MP_STOP: u32 = 2;
pub const SDIO_MP_LOOPBACK: u32 = 3;
pub const SDIO_MP_STATUS: u32 = 4;
pub const SDIO_MP_READ_REG8: u32 = 5;
pub const SDIO_MP_READ_REG16: u32 = 6;
pub const SDIO_MP_READ_REG32: u32 = 7;
pub const SDIO_MP_WRITE_REG8: u32 = 8;
pub const SDIO_MP_WRITE_REG16: u32 = 9;
pub const SDIO_MP_WRITE_REG32: u32 = 10;
pub const SDIO_MP_WAKEUP: u32 = 11;
pub const SDIO_MP_DUMP: u32 = 12;
pub const SDIO_MP_CTX: u32 = 13;
pub const SDIO_MP_CRX: u32 = 14;
pub const SDIO_MP_CRX_DA: u32 = 15;
pub const SDIO_MP_CRX_STOP: u32 = 16;
pub const SDIO_MP_DBG_MSG: u32 = 17;
pub const RPWM2_ACT_BIT: u32 = 1;
pub const RPWM2_SLEEP_BIT: u32 = 0;
pub const RPWM2_DSTANDBY_BIT: u32 = 2;
pub const RPWM2_PG_BIT: u32 = 0;
pub const RPWM2_FBOOT_BIT: u32 = 4;
pub const RPWM2_NBOOT_BIT: u32 = 0;
pub const RPWM2_WKPIN_0_BIT: u32 = 8;
pub const RPWM2_WKPIN_1_BIT: u32 = 16;
pub const RPWM2_WKPIN_2_BIT: u32 = 32;
pub const RPWM2_WKPIN_3_BIT: u32 = 64;
pub const RPWM2_WKPIN_0_LV_BIT: u32 = 128;
pub const RPWM2_WKPIN_1_LV_BIT: u32 = 256;
pub const RPWM2_WKPIN_2_LV_BIT: u32 = 512;
pub const RPWM2_WKPIN_3_LV_BIT: u32 = 1024;
pub const RPWM2_CG_BIT: u32 = 2048;
pub const RPWM2_ACK_BIT: u32 = 16384;
pub const RPWM2_TOGGLE_BIT: u32 = 32768;
pub const CPWM2_ACT_BIT: u32 = 1;
pub const CPWM2_DSTANDBY_BIT: u32 = 2;
pub const CPWM2_FBOOT_BIT: u32 = 4;
pub const CPWM2_INIC_FW_RDY_BIT: u32 = 8;
pub const CPWM2_TOGGLE_BIT: u32 = 32768;
pub const CPWM1_TOGGLE_BIT: u32 = 128;
pub const SDIO_EVENT_RX_PKT_RDY: u32 = 2;
pub const SDIO_EVENT_DUMP: u32 = 8;
pub const SDIO_EVENT_EXIT: u32 = 134217728;
pub const SDIO_EVENT_MP_STOPPED: u32 = 268435456;
pub const SDIO_EVENT_IRQ_STOPPED: u32 = 536870912;
pub const SDIO_EVENT_TX_STOPPED: u32 = 1073741824;
pub const SDIO_EVENT_RX_STOPPED: u32 = 2147483648;
pub const REG_SPDIO_TXBD_ADDR: u32 = 160;
pub const REG_SPDIO_TXBD_SIZE: u32 = 164;
pub const REG_SPDIO_TXBD_WPTR: u32 = 168;
pub const REG_SPDIO_TXBD_RPTR: u32 = 172;
pub const REG_SPDIO_RXBD_ADDR: u32 = 176;
pub const REG_SPDIO_RXBD_SIZE: u32 = 180;
pub const REG_SPDIO_RXBD_C2H_WPTR: u32 = 182;
pub const REG_SPDIO_RXBD_C2H_RPTR: u32 = 184;
pub const REG_SPDIO_HCI_RX_REQ: u32 = 186;
pub const REG_SPDIO_CPU_RST_DMA: u32 = 187;
pub const REG_SPDIO_RX_REQ_ADDR: u32 = 188;
pub const REG_SPDIO_CPU_INT_MASK: u32 = 192;
pub const REG_SPDIO_CPU_INT_STAS: u32 = 194;
pub const REG_SPDIO_CCPWM: u32 = 196;
pub const REG_SPDIO_CPU_IND: u32 = 197;
pub const REG_SPDIO_CCPWM2: u32 = 198;
pub const REG_SPDIO_CPU_H2C_MSG: u32 = 200;
pub const REG_SPDIO_CPU_C2H_MSG: u32 = 204;
pub const REG_SPDIO_CRPWM: u32 = 208;
pub const REG_SPDIO_CRPWM2: u32 = 210;
pub const REG_SPDIO_AHB_DMA_CTRL: u32 = 212;
pub const REG_SPDIO_RXBD_CNT: u32 = 216;
pub const REG_SPDIO_TX_BUF_UNIT_SZ: u32 = 217;
pub const REG_SPDIO_RX_BD_FREE_CNT: u32 = 218;
pub const REG_SPDIO_CPU_H2C_MSG_EXT: u32 = 220;
pub const REG_SPDIO_CPU_C2H_MSG_EXT: u32 = 224;
pub const IR_TX_FIFO_SIZE: u32 = 32;
pub const IR_RX_FIFO_SIZE: u32 = 32;
pub const IR_MODE_TX: u32 = 0;
pub const IR_MODE_RX: u32 = 2147483648;
pub const IR_TX_DATA_NORMAL: u32 = 0;
pub const IR_TX_DATA_INVERSE: u32 = 16384;
pub const IR_TX_DATA_CARRIER_NORMAL: u32 = 0;
pub const IR_TX_DATA_CARRIER_INVERSE: u32 = 8192;
pub const IR_TX_DATA_LEVEL_MASK: u32 = 24576;
pub const IR_TX_FIFO_THRESHOLD_MASK: u32 = 7936;
pub const IR_IDLE_OUTPUT_LOW: u32 = 0;
pub const IR_IDLE_OUTPUT_HIGH: u32 = 64;
pub const IR_RX_AUTO_MODE: u32 = 134217728;
pub const IR_RX_MANUAL_MODE: u32 = 0;
pub const IR_RX_FILTER_TIME_20NS: u32 = 0;
pub const IR_RX_FILTER_TIME_30NS: u32 = 2097152;
pub const IR_RX_FILTER_TIME_40NS: u32 = 4194304;
pub const IR_RX_FILTER_TIME_50NS: u32 = 6291456;
pub const IR_RX_FILTER_TIME_60NS: u32 = 8388608;
pub const IR_RX_FILTER_TIME_70NS: u32 = 10485760;
pub const IR_RX_FILTER_TIME_80NS: u32 = 12582912;
pub const IR_RX_FILTER_TIME_90NS: u32 = 14680064;
pub const IR_RX_FIFO_FULL_DISCARD_NEWEST: u32 = 8192;
pub const IR_RX_FIFO_FULL_DISCARD_OLDEST: u32 = 0;
pub const IR_RX_FIFO_THRESHOLD_MASK: u32 = 7936;
pub const IR_RX_COUNT_LOW_LEVEL: u32 = 0;
pub const IR_RX_COUNT_HIGH_LEVEL: u32 = 2147483648;
pub const MAX_USI_INDEX: u32 = 1;
pub const USI_UART_STATETX_DMA: u32 = 1;
pub const USI_UART_STATETX_INT: u32 = 2;
pub const USI_UART_STATETX_POLL: u32 = 3;
pub const USI_UART_STATERX_DMA: u32 = 1;
pub const USI_UART_STATERX_INT: u32 = 2;
pub const USI_UART_STATERX_POLL: u32 = 3;
pub const USI_SPI_TMOD_TR: u32 = 0;
pub const USI_SPI_TMOD_TO: u32 = 1;
pub const USI_SPI_TMOD_RO: u32 = 2;
pub const USI_SPI_SCPOL_INACTIVE_IS_LOW: u32 = 0;
pub const USI_SPI_SCPOL_INACTIVE_IS_HIGH: u32 = 1;
pub const USI_SPI_SCPH_TOGGLES_IN_MIDDLE: u32 = 0;
pub const USI_SPI_SCPH_TOGGLES_AT_START: u32 = 1;
pub const USI_SPI_SS_NOT_TOGGLE: u32 = 0;
pub const USI_SPI_SS_TOGGLE: u32 = 1;
pub const USI_SPI_DFS_4_BITS: u32 = 3;
pub const USI_SPI_DFS_5_BITS: u32 = 4;
pub const USI_SPI_DFS_6_BITS: u32 = 5;
pub const USI_SPI_DFS_7_BITS: u32 = 6;
pub const USI_SPI_DFS_8_BITS: u32 = 7;
pub const USI_SPI_DFS_9_BITS: u32 = 8;
pub const USI_SPI_DFS_10_BITS: u32 = 9;
pub const USI_SPI_DFS_11_BITS: u32 = 10;
pub const USI_SPI_DFS_12_BITS: u32 = 11;
pub const USI_SPI_DFS_13_BITS: u32 = 12;
pub const USI_SPI_DFS_14_BITS: u32 = 13;
pub const USI_SPI_DFS_15_BITS: u32 = 14;
pub const USI_SPI_DFS_16_BITS: u32 = 15;
pub const USI_SPI_SLAVE: u32 = 0;
pub const USI_SPI_MASTER: u32 = 1;
pub const USI_SPI_NODMA: u32 = 0;
pub const USI_SPI_RXDMA_ENABLE: u32 = 1;
pub const USI_SPI_TXDMA_ENABLE: u32 = 2;
pub const USI_SPI_TRDMA_ENABLE: u32 = 3;
pub const USI_SPI_TX_FIFO_DEPTH: u32 = 64;
pub const USI_SPI_RX_FIFO_DEPTH: u32 = 64;
pub const USI_I2C_SS_MIN_SCL_HTIME: u32 = 4000;
pub const USI_I2C_SS_MIN_SCL_LTIME: u32 = 4700;
pub const USI_I2C_FS_MIN_SCL_HTIME: u32 = 600;
pub const USI_I2C_FS_MIN_SCL_LTIME: u32 = 1300;
pub const USI_I2C_HS_MIN_SCL_HTIME_100: u32 = 60;
pub const USI_I2C_HS_MIN_SCL_LTIME_100: u32 = 100;
pub const USI_I2C_HS_MIN_SCL_HTIME_400: u32 = 160;
pub const USI_I2C_HS_MIN_SCL_LTIME_400: u32 = 320;
pub const CRC_S_BASE: u32 = 1342316800;
pub const CRC_TIMEOUT: u32 = 10000;
pub const LCDC_SYS_CLK: u32 = 100000000;
pub const AUDIO_BLOCK_SIZE: u32 = 2048;
pub const EFUSE_MAP_LEN_8711B: u32 = 1024;
pub const EFUSE_MAX_SECTION_8711B: u32 = 128;
pub const PGPKT_DATA_SIZE: u32 = 8;
pub const USER_SECTION: u32 = 44;
pub const OTP_SECTION: u32 = 128;
pub const OTP_SECTION_LEN: u32 = 32;
pub const EFUSE_REAL_CONTENT_LEN: u32 = 512;
pub const LOGICAL_MAP_SECTION_LEN: u32 = 286;
pub const EFUSE_OOB_PROTECT_BYTES: u32 = 226;
pub const L25EOUTVOLTAGE: u32 = 7;
pub const EFUSE_POLL_TIMES: u32 = 20000;
pub const EFUSE_SECURE_START: u32 = 336;
pub const EFUSE_SECURE_END: u32 = 383;
pub const EFUSE_RDP_KEY_ADDR: u32 = 368;
pub const EFUSE_SWD_PWD_ADDR: u32 = 384;
pub const RSIP_KEY_ADDR: u32 = 400;
pub const SBOOT_PK_ADDR: u32 = 416;
pub const EFUSE_SEC_CONFIG_ADDR0: u32 = 448;
pub const EFUSE_SEC_CONFIG_ADDR1: u32 = 449;
pub const CACHE_LINE_SIZE: u32 = 32;
pub const CACHE_LINE_ADDR_MSK: u32 = 4294967264;
pub const PSRAM_FIX_TPHY_LATENCY: u32 = 1;
pub const PSRAM_UNSET_TPHY_LATENCY: u32 = 0;
pub const PSRAM_BURST_LENGTH_128B: u32 = 0;
pub const PSRAM_BURST_LENGTH_64B: u32 = 1;
pub const PSRAM_BURST_LENGTH_16B: u32 = 2;
pub const PSRAM_BURST_LENGTH_32B: u32 = 3;
pub const PSRAM_BURST_VENDOR_TYPE: u32 = 0;
pub const PSRAM_BURST_LEGACY_TYPE: u32 = 1;
pub const PSRAM_2TIMES_LATENCY_FIXED: u32 = 1;
pub const PSRAM_VARIABLE_LATENCY: u32 = 0;
pub const PSRAM_INIT_LATENCY_5CLK: u32 = 0;
pub const PSRAM_INIT_LATENCY_6CLK: u32 = 1;
pub const PSRAM_INIT_LATENCY_3CLK: u32 = 14;
pub const PSRAM_INIT_LATENCY_4CLK: u32 = 15;
pub const PSRAM_DRV_STRENGTH_50OHMS: u32 = 0;
pub const PSRAM_DRV_STRENGTH_35OHMS: u32 = 1;
pub const PSRAM_DRV_STRENGTH_100OHMS: u32 = 2;
pub const PSRAM_DRV_STRENGTH_200OHMS: u32 = 3;
pub const PSRAM_DPD_MODE: u32 = 0;
pub const PSRAM_NORMAL_MODE: u32 = 1;
pub const PSRAM_PASR_FULL_ARRAY: u32 = 0;
pub const PSRAM_PASR_BOT_HALF_ARRAY: u32 = 1;
pub const PSRAM_PASR_BOT_QUARTER_ARRAY: u32 = 2;
pub const PSRAM_PASR_BOT_EIGHTH_ARRAY: u32 = 3;
pub const PSRAM_PASR_NONE: u32 = 4;
pub const PSRAM_PASR_TOP_HALF_ARRAY: u32 = 5;
pub const PSRAM_PASR_TOP_QUARTER_ARRAY: u32 = 6;
pub const PSRAM_PASR_TOP_EIGHTH_ARRAY: u32 = 7;
pub const PSRAM_HALF_SLP_DIS: u32 = 0;
pub const PSRAM_HALF_SLP_EN: u32 = 1;
pub const PSRAM_REFRESH_RATE_FAST: u32 = 0;
pub const PSRAM_REFRESH_RATE_NORMAL: u32 = 1;
pub const PSRAM_WRAPPED_TYPE: u32 = 0;
pub const PSRAM_LINEAR_TYPE: u32 = 1;
pub const PSRAM_MEM_SPACE: u32 = 0;
pub const PSRAM_REG_SPACE: u32 = 1;
pub const PSRAM_WRITE_TRANSACTION: u32 = 0;
pub const PSRAM_READ_TRANSACTION: u32 = 1;
pub const PSRAM_DPIN_READ_MODE: u32 = 0;
pub const PSRAM_DPIN_WRITE_MODE: u32 = 131072;
pub const BIT_PSRAM_DFI_PATH_DLY_SHIFT: u32 = 25;
pub const BIT_PSRAM_TPHY_RDDATA_EN_SHIFT: u32 = 20;
pub const BIT_PSRAM_FIX_TPHY_LAT_SHIFT: u32 = 19;
pub const BIT_PSRAM_TPHY_WRDATA_SHIFT: u32 = 12;
pub const BIT_PSRAM_RD_PIPE_SHIFT: u32 = 8;
pub const BIT_PSRAM_DFI_CS_RD_DLY_SHIFT: u32 = 4;
pub const BIT_PSRAM_DFI_CS_WR_DLY_SHIFT: u32 = 0;
pub const BIT_PSRAM_PU_TIME_SHIFT: u32 = 15;
pub const BIT_PSRAM_CEM_TIME_SHIFT: u32 = 4;
pub const BIT_PSRAM_CPH_TIME_SHIFT: u32 = 0;
pub const BIT_PSRAM_RL_LATENCY_SHIFT: u32 = 5;
pub const BIT_PSRAM_WL_LATENCY_SHIFT: u32 = 0;
pub const BIT_PSRAM_MR0_BURST_DPD_MODE_SHIFT: u32 = 15;
pub const BIT_PSRAM_MR0_BURST_DRV_STRENGTH_SHIFT: u32 = 12;
pub const BIT_PSRAM_MR0_BURST_RSVD_SHIFT: u32 = 8;
pub const BIT_PSRAM_MR0_BURST_INIT_LAT_SHIFT: u32 = 4;
pub const BIT_PSRAM_MR0_BURST_LAT_MODE_SHIFT: u32 = 3;
pub const BIT_PSRAM_MR0_BURST_TYPE_SHIFT: u32 = 2;
pub const BIT_PSRAM_MR0_BURST_LENGTH_SHIFT: u32 = 0;
pub const BIT_PSRAM_MR1_REFRESH_RATE_SHIFT: u32 = 6;
pub const BIT_PSRAM_MR1_HALF_SLP_MODE_SHIFT: u32 = 5;
pub const BIT_PSRAM_MR1_PASR_SHIFT: u32 = 0;
pub const BIT_PSRAM_CFG_CAL_THD_SHIFT: u32 = 4;
pub const BIT_PSRAM_CFG_CAL_JMIN_SHIFT: u32 = 24;
pub const BIT_PSRAM_CFG_CAL_JMAX_SHIFT: u32 = 16;
pub const BIT_PSRAM_CFG_CAL_J_SHIFT: u32 = 8;
pub const BIT_PSRAM_CFG_CAL_N_SHIFT: u32 = 0;
pub const BIT_PSRAM_CFG_CAL_CUR_ST_SHIFT: u32 = 24;
pub const BIT_PSRAM_CFG_CAL_PDST_SHIFT: u32 = 16;
pub const BIT_PSRAM_CFG_CAL_CUR_J_SHIFT: u32 = 8;
pub const BIT_PSRAM_CFG_CAL_CUR_N_SHIFT: u32 = 0;
pub const BIT_PSRAM_WBYTE_ACCU_SHIFT: u32 = 24;
pub const BIT_PSRAM_WBYTE_CNT_SHIFT: u32 = 16;
pub const BIT_PSRAM_RBYTE_ACCU_SHIFT: u32 = 8;
pub const BIT_PSRAM_RBYTE_CNT_SHIFT: u32 = 0;
pub const BIT_PSRAM_TIME_OUT_THOLD_SHIFT: u32 = 0;
pub const BIT_PSRAM_PSRAM_PHY_DBG_SEL_SHIFT: u32 = 0;
pub const BIT_PSRAM_PSRAM_PHY_DBG_SHIFT: u32 = 0;
pub const REG_PSRAM_CAL_CTRL: u32 = 0;
pub const REG_PSRAM_CAL_PARA: u32 = 4;
pub const REG_PSRAM_CAL_STATUS: u32 = 8;
pub const REG_PSRAM_CMD_ADDR_INFO_L: u32 = 16;
pub const REG_PSRAM_CMD_ADDR_INFO_H: u32 = 20;
pub const REG_PSRAM_BYTE_CNT_INFO: u32 = 24;
pub const REG_PSRAM_TIME_OUT_CTRL: u32 = 28;
pub const REG_PSRAM_DBG_SEL: u32 = 240;
pub const REG_PSRAM_DBG_INFO: u32 = 248;
pub const SDIOH_NORMAL_WRITE: u32 = 0;
pub const SDIOH_AUTO_WRITE3: u32 = 1;
pub const SDIOH_AUTO_WRITE4: u32 = 2;
pub const SDIOH_AUTO_READ3: u32 = 5;
pub const SDIOH_AUTO_READ4: u32 = 6;
pub const SDIOH_SEND_CMD_GET_RSP: u32 = 8;
pub const SDIOH_AUTO_WRITE1: u32 = 9;
pub const SDIOH_AUTO_WRITE2: u32 = 10;
pub const SDIOH_NORMAL_READ: u32 = 12;
pub const SDIOH_AUTO_READ1: u32 = 13;
pub const SDIOH_AUTO_READ2: u32 = 14;
pub const SDIOH_TUNING: u32 = 15;
pub const SDIOH_NO_RESP: u32 = 0;
pub const SDIOH_RESP_R1: u32 = 1;
pub const SDIOH_RESP_R2: u32 = 2;
pub const SDIOH_RESP_R3: u32 = 3;
pub const SDIOH_RESP_R6: u32 = 4;
pub const SDIOH_RESP_R7: u32 = 5;
pub const SDIOH_RSP_6B: u32 = 1;
pub const SDIOH_RSP_17B: u32 = 2;
pub const SDIOH_NO_DATA: u32 = 0;
pub const SDIOH_DATA_EXIST: u32 = 1;
pub const SDIOH_DMA_NORMAL: u32 = 0;
pub const SDIOH_DMA_64B: u32 = 1;
pub const SDIOH_DMA_R2: u32 = 2;
pub const SDIOH_SD20_MODE: u32 = 0;
pub const SDIOH_DDR_MODE: u32 = 1;
pub const SDIOH_SD30_MODE: u32 = 2;
pub const SDIOH_BUS_WIDTH_1BIT: u32 = 0;
pub const SDIOH_BUS_WIDTH_4BIT: u32 = 1;
pub const SDIOH_DMA_WRITE: u32 = 0;
pub const SDIOH_DMA_READ: u32 = 1;
pub const SDIOH_SHIFT_LX_BURST_SIZE: u32 = 6;
pub const SDIOH_LX_BURST_SIZE_64B: u32 = 0;
pub const SDIOH_SHIFT_MAP_SEL: u32 = 5;
pub const SDIOH_MAP_SEL_DEC: u32 = 32;
pub const SDIOH_MASK_DRAM_SA: u32 = 268435455;
pub const SDIOH_MASK_DMA_LEN: u32 = 65535;
pub const SDIOH_SHIFT_DDR_WR: u32 = 1;
pub const SDIOH_SD_ISR_ALL: u32 = 22;
pub const SDIOH_SHIFT_SD30_SAMP_CLK_SRC: u32 = 12;
pub const SDIOH_SHIFT_SD30_PUSH_CLK_SRC: u32 = 8;
pub const SDIOH_SHIFT_CRC_CLK_SRC: u32 = 4;
pub const SDIOH_SD30_SAMP_CLK_VP1: u32 = 8192;
pub const SDIOH_SD30_PUSH_CLK_VP0: u32 = 256;
pub const SDIOH_CRC_CLK_SSC: u32 = 0;
pub const SDIOH_MASK_CLKDIV: u32 = 7;
pub const SDIOH_CLK_DIV1: u32 = 0;
pub const SDIOH_CLK_DIV2: u32 = 1;
pub const SDIOH_CLK_DIV4: u32 = 2;
pub const SDIOH_CLK_DIV8: u32 = 3;
pub const SDIOH_CARD_SEL_SD_MODULE: u32 = 2;
pub const SDIOH_CLK_DIV_BY_128: u32 = 0;
pub const SDIOH_SHIFT_MODE_SEL: u32 = 2;
pub const SDIOH_MASK_MODE_SEL: u32 = 12;
pub const SDIOH_SHIFT_BUS_WIDTH: u32 = 0;
pub const SDIOH_MASK_BUS_WIDTH: u32 = 3;
pub const SDIOH_CRC7_CAL_EN: u32 = 0;
pub const SDIOH_CRC16_CHK_EN: u32 = 0;
pub const SDIOH_WAIT_WR_CRCSTA_TO_EN: u32 = 0;
pub const SDIOH_IGNORE_WR_CRC_ERR_EN: u32 = 0;
pub const SDIOH_WAIT_BUSY_END_DIS: u32 = 0;
pub const SDIOH_CRC7_CHK_EN: u32 = 0;
pub const SDIOH_STOP_STA_WAIT_BUSY_EN: u32 = 0;
pub const SDIOH_CMD_STA_WAIT_BUSY_EN: u32 = 0;
pub const SDIOH_DATA_PHA_WAIT_BUSY_DIS: u32 = 0;
pub const SDIOH_SD30_CLK_STOP_DIS: u32 = 0;
pub const SDIOH_SD20_CLK_STOP_DIS: u32 = 0;
pub const SDIOH_SD_CMD_RESP_CHK_DIS: u32 = 0;
pub const SDIOH_ADDR_MODE_SECTOR: u32 = 0;
pub const SDIOH_CMD_RESP_TO_DIS: u32 = 0;
pub const SDIOH_MASK_WR_CRC_STA: u32 = 28;
pub const SDIOH_MASK_BLOCL_CNT_L: u32 = 255;
pub const SDIOH_MASK_BLOCL_CNT_H: u32 = 127;
pub const SDIOH_MASK_COM_CODE: u32 = 15;
pub const SDIOH_CMD_CPLT_TIMEOUT: u32 = 5000;
pub const SDIOH_XFER_CPLT_TIMEOUT: u32 = 1000000;
pub const SDIOH_READ_TIMEOUT: u32 = 100000;
pub const SDIOH_WRITE_TIMEOUT: u32 = 250000;
pub const SDIOH_ERASE_TIMEOUT: u32 = 2000000;
pub const SDIOH_CMD_IDX_MASK: u32 = 63;
pub const SDIOH_CMD8_VHS: u32 = 1;
pub const SDIOH_CMD8_CHK_PATN: u32 = 170;
pub const SDIOH_OCR_VDD_WIN: u32 = 16744448;
pub const SDIOH_C6R2_BUF_LEN: u32 = 64;
pub const SDIOH_CSD_LEN: u32 = 16;
pub const SDIO_RESP0: u32 = 0;
pub const SDIO_RESP1: u32 = 1;
pub const SDIO_RESP2: u32 = 2;
pub const SDIO_RESP3: u32 = 3;
pub const SDIO_RESP4: u32 = 4;
pub const SDIO_RESP5: u32 = 5;
pub const SDIOH_SIG_VOL_33: u32 = 0;
pub const SDIOH_SIG_VOL_18: u32 = 1;
pub const SD: u32 = 0;
pub const EMMC: u32 = 1;
pub const SDIO: u32 = 0;
pub const SD_CARD_READY: u32 = 1;
pub const SD_CARD_IDENTIFICATION: u32 = 2;
pub const SD_CARD_STANDBY: u32 = 3;
pub const SD_CARD_TRANSFER: u32 = 4;
pub const SD_CARD_SENDING: u32 = 5;
pub const SD_CARD_RECEIVING: u32 = 6;
pub const SD_CARD_PROGRAMMING: u32 = 7;
pub const SD_CARD_DISCONNECTED: u32 = 8;
pub const SD_CARD_ERROR: u32 = 255;
pub const SD_SPEC_V101: u32 = 0;
pub const SD_SPEC_V110: u32 = 1;
pub const SD_SPEC_V200: u32 = 2;
pub const SD_SPEC_V300: u32 = 3;
pub const SD_SPEED_DS: u32 = 0;
pub const SD_SPEED_HS: u32 = 1;
pub const SD_SPEED_SDR12: u32 = 2;
pub const SD_SPEED_SDR25: u32 = 3;
pub const SD_SPEED_SDR50: u32 = 4;
pub const SD_SPEED_SDR104: u32 = 5;
pub const SD_SPEED_DDR50: u32 = 6;
pub const SD_KEEP_CUR_SPEED: u32 = 15;
pub const SD_BLOCK_SIZE: u32 = 512;
pub const SD_POWER_SAVING: u32 = 0;
pub const SD_MAX_PERFORM: u32 = 1;
pub const SD_USE_CUR_VOL: u32 = 0;
pub const SD_SWITCH_18V: u32 = 1;
pub const SD_CMD6_CHECK_MODE: u32 = 0;
pub const SD_CMD6_SWITCH_MODE: u32 = 1;
pub const SD_SUPPORT_SDSC_ONLY: u32 = 0;
pub const SD_SUPPORT_SDHC_SDXC: u32 = 1;
pub const FW_VERSION: u32 = 256;
pub const FW_SUBVERSION: u32 = 1;
pub const FW_CHIP_ID: u32 = 33173;
pub const FW_CHIP_VER: u32 = 1;
pub const FW_BUS_TYPE: u32 = 1;
pub const FW_INFO_RSV1: u32 = 0;
pub const FW_INFO_RSV2: u32 = 0;
pub const FW_INFO_RSV3: u32 = 0;
pub const FW_INFO_RSV4: u32 = 0;
pub const FLASH_HS_BOOT_ADDR: u32 = 134234112;
pub const FLASH_RESERVED_DATA_BASE: u32 = 8192;
pub const FLASH_SYSTEM_DATA_ADDR: u32 = 12288;
pub const FLASH_OTA1_CODE_ADDR: u32 = 24608;
pub const FLASH_SECTOR_SIZE: u32 = 4096;
pub const FLASH_BT_PARA_ADDR: u32 = 24560;
pub const ReadQuadIOMode: u32 = 0;
pub const ReadQuadOMode: u32 = 1;
pub const ReadDualIOMode: u32 = 2;
pub const ReadDualOMode: u32 = 3;
pub const ReadOneMode: u32 = 4;
pub const IMAGE_HEADER_LEN: u32 = 32;
pub const SIMULATION_KM0_CPUID: u32 = 0;
pub const SIMULATION_KM4_CPUID: u32 = 1;
pub const KM0_SIMULATION_STAGE_REG: u32 = 324;
pub const KM4_SIMULATION_STAGE_REG: u32 = 328;
pub const CT_CHANNEL_NUM: u32 = 4;
pub const P_NOISE_THRES: u32 = 0;
pub const N_NOISE_THRES: u32 = 1;
pub const SERVER_LOCAL: u32 = 1;
pub const SERVER_CLOUD: u32 = 2;
pub const SERVER_TYPE: u32 = 1;
pub const MAX_IMG_NUM: u32 = 2;
pub const HEADER_BAK_LEN: u32 = 32;
pub const BACKUP_SECTOR: u32 = 8192;
pub const LS_IMG2_OTA1_ADDR: u32 = 134242304;
pub const LS_IMG2_OTA2_ADDR: u32 = 135290880;
pub const BUF_SIZE: u32 = 512;
pub const OTA_IMAG: u32 = 0;
pub const CONFIG_SSL_RSA: u32 = 1;
pub const RTL_CRYPTO_FRAGMENT: u32 = 15360;
pub const CONFIG_PLATFORM_AMEBA_X: u32 = 1;
pub const __NEWLIB_H__: u32 = 1;
pub const _WANT_IO_LONG_LONG: u32 = 1;
pub const _MB_LEN_MAX: u32 = 1;
pub const HAVE_INITFINI_ARRAY: u32 = 1;
pub const _ATEXIT_DYNAMIC_ALLOC: u32 = 1;
pub const _HAVE_LONG_DOUBLE: u32 = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: u32 = 1;
pub const _LDBL_EQ_DBL: u32 = 1;
pub const _FVWRITE_IN_STREAMIO: u32 = 1;
pub const _FSEEK_OPTIMIZATION: u32 = 1;
pub const _WIDE_ORIENT: u32 = 1;
pub const _UNBUF_STREAM_OPT: u32 = 1;
pub const __RAND_MAX: u32 = 2147483647;
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___OFFSETOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const _NULL: u32 = 0;
pub const _ATEXIT_SIZE: u32 = 32;
pub const _RAND48_SEED_0: u32 = 13070;
pub const _RAND48_SEED_1: u32 = 43981;
pub const _RAND48_SEED_2: u32 = 4660;
pub const _RAND48_MULT_0: u32 = 58989;
pub const _RAND48_MULT_1: u32 = 57068;
pub const _RAND48_MULT_2: u32 = 5;
pub const _RAND48_ADD: u32 = 11;
pub const _REENT_EMERGENCY_SIZE: u32 = 25;
pub const _REENT_ASCTIME_SIZE: u32 = 26;
pub const _REENT_SIGNAL_SIZE: u32 = 24;
pub const _N_LISTS: u32 = 30;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _LITTLE_ENDIAN: u32 = 1234;
pub const _BIG_ENDIAN: u32 = 4321;
pub const _PDP_ENDIAN: u32 = 3412;
pub const _BYTE_ORDER: u32 = 1234;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const FD_SETSIZE: u32 = 64;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SORD: u32 = 8192;
pub const __SL64: u32 = 32768;
pub const __SNLK: u32 = 1;
pub const __SWID: u32 = 8192;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const EOF: i32 = -1;
pub const BUFSIZ: u32 = 1024;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const L_tmpnam: u32 = 1024;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const TMP_MAX: u32 = 26;
pub const L_ctermid: u32 = 16;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const MBEDTLS_SSL_MAX_CONTENT_LEN: u32 = 16384;
pub const MB_LEN_MAX: u32 = 1;
pub const MBEDTLS_EXIT_SUCCESS: u32 = 0;
pub const MBEDTLS_EXIT_FAILURE: u32 = 1;
pub const MBEDTLS_ERR_MPI_FILE_IO_ERROR: i32 = -2;
pub const MBEDTLS_ERR_MPI_BAD_INPUT_DATA: i32 = -4;
pub const MBEDTLS_ERR_MPI_INVALID_CHARACTER: i32 = -6;
pub const MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL: i32 = -8;
pub const MBEDTLS_ERR_MPI_NEGATIVE_VALUE: i32 = -10;
pub const MBEDTLS_ERR_MPI_DIVISION_BY_ZERO: i32 = -12;
pub const MBEDTLS_ERR_MPI_NOT_ACCEPTABLE: i32 = -14;
pub const MBEDTLS_ERR_MPI_ALLOC_FAILED: i32 = -16;
pub const MBEDTLS_MPI_MAX_LIMBS: u32 = 10000;
pub const MBEDTLS_MPI_WINDOW_SIZE: u32 = 6;
pub const MBEDTLS_MPI_MAX_SIZE: u32 = 1024;
pub const MBEDTLS_MPI_MAX_BITS: u32 = 8192;
pub const MBEDTLS_MPI_MAX_BITS_SCALE100: u32 = 819200;
pub const MBEDTLS_LN_2_DIV_LN_10_SCALE100: u32 = 332;
pub const MBEDTLS_MPI_RW_BUFFER_SIZE: u32 = 2484;
pub const MBEDTLS_ERR_ECP_BAD_INPUT_DATA: i32 = -20352;
pub const MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL: i32 = -20224;
pub const MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE: i32 = -20096;
pub const MBEDTLS_ERR_ECP_VERIFY_FAILED: i32 = -19968;
pub const MBEDTLS_ERR_ECP_ALLOC_FAILED: i32 = -19840;
pub const MBEDTLS_ERR_ECP_RANDOM_FAILED: i32 = -19712;
pub const MBEDTLS_ERR_ECP_INVALID_KEY: i32 = -19584;
pub const MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH: i32 = -19456;
pub const MBEDTLS_ECP_DP_MAX: u32 = 12;
pub const MBEDTLS_ECP_MAX_BITS: u32 = 521;
pub const MBEDTLS_ECP_MAX_BYTES: u32 = 66;
pub const MBEDTLS_ECP_MAX_PT_LEN: u32 = 133;
pub const MBEDTLS_ECP_WINDOW_SIZE: u32 = 6;
pub const MBEDTLS_ECP_FIXED_POINT_OPTIM: u32 = 1;
pub const MBEDTLS_ECP_PF_UNCOMPRESSED: u32 = 0;
pub const MBEDTLS_ECP_PF_COMPRESSED: u32 = 1;
pub const MBEDTLS_ECP_TLS_NAMED_CURVE: u32 = 3;
pub const MBEDTLS_ERR_MD_FEATURE_UNAVAILABLE: i32 = -20608;
pub const MBEDTLS_ERR_MD_BAD_INPUT_DATA: i32 = -20736;
pub const MBEDTLS_ERR_MD_ALLOC_FAILED: i32 = -20864;
pub const MBEDTLS_ERR_MD_FILE_IO_ERROR: i32 = -20992;
pub const MBEDTLS_MD_MAX_SIZE: u32 = 64;
pub const MBEDTLS_ERR_RSA_BAD_INPUT_DATA: i32 = -16512;
pub const MBEDTLS_ERR_RSA_INVALID_PADDING: i32 = -16640;
pub const MBEDTLS_ERR_RSA_KEY_GEN_FAILED: i32 = -16768;
pub const MBEDTLS_ERR_RSA_KEY_CHECK_FAILED: i32 = -16896;
pub const MBEDTLS_ERR_RSA_PUBLIC_FAILED: i32 = -17024;
pub const MBEDTLS_ERR_RSA_PRIVATE_FAILED: i32 = -17152;
pub const MBEDTLS_ERR_RSA_VERIFY_FAILED: i32 = -17280;
pub const MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE: i32 = -17408;
pub const MBEDTLS_ERR_RSA_RNG_FAILED: i32 = -17536;
pub const MBEDTLS_RSA_PUBLIC: u32 = 0;
pub const MBEDTLS_RSA_PRIVATE: u32 = 1;
pub const MBEDTLS_RSA_PKCS_V15: u32 = 0;
pub const MBEDTLS_RSA_PKCS_V21: u32 = 1;
pub const MBEDTLS_RSA_SIGN: u32 = 1;
pub const MBEDTLS_RSA_CRYPT: u32 = 2;
pub const MBEDTLS_RSA_SALT_LEN_ANY: i32 = -1;
pub const MBEDTLS_ECDSA_MAX_LEN: u32 = 141;
pub const MBEDTLS_ERR_PK_ALLOC_FAILED: i32 = -16256;
pub const MBEDTLS_ERR_PK_TYPE_MISMATCH: i32 = -16128;
pub const MBEDTLS_ERR_PK_BAD_INPUT_DATA: i32 = -16000;
pub const MBEDTLS_ERR_PK_FILE_IO_ERROR: i32 = -15872;
pub const MBEDTLS_ERR_PK_KEY_INVALID_VERSION: i32 = -15744;
pub const MBEDTLS_ERR_PK_KEY_INVALID_FORMAT: i32 = -15616;
pub const MBEDTLS_ERR_PK_UNKNOWN_PK_ALG: i32 = -15488;
pub const MBEDTLS_ERR_PK_PASSWORD_REQUIRED: i32 = -15360;
pub const MBEDTLS_ERR_PK_PASSWORD_MISMATCH: i32 = -15232;
pub const MBEDTLS_ERR_PK_INVALID_PUBKEY: i32 = -15104;
pub const MBEDTLS_ERR_PK_INVALID_ALG: i32 = -14976;
pub const MBEDTLS_ERR_PK_UNKNOWN_NAMED_CURVE: i32 = -14848;
pub const MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE: i32 = -14720;
pub const MBEDTLS_ERR_PK_SIG_LEN_MISMATCH: i32 = -14592;
pub const MBEDTLS_PK_DEBUG_MAX_ITEMS: u32 = 3;
pub const MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE: i32 = -24704;
pub const MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA: i32 = -24832;
pub const MBEDTLS_ERR_CIPHER_ALLOC_FAILED: i32 = -24960;
pub const MBEDTLS_ERR_CIPHER_INVALID_PADDING: i32 = -25088;
pub const MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED: i32 = -25216;
pub const MBEDTLS_ERR_CIPHER_AUTH_FAILED: i32 = -25344;
pub const MBEDTLS_ERR_CIPHER_INVALID_CONTEXT: i32 = -25472;
pub const MBEDTLS_CIPHER_VARIABLE_IV_LEN: u32 = 1;
pub const MBEDTLS_CIPHER_VARIABLE_KEY_LEN: u32 = 2;
pub const MBEDTLS_MAX_IV_LENGTH: u32 = 16;
pub const MBEDTLS_MAX_BLOCK_LENGTH: u32 = 16;
pub const MBEDTLS_TLS_RSA_WITH_NULL_MD5: u32 = 1;
pub const MBEDTLS_TLS_RSA_WITH_NULL_SHA: u32 = 2;
pub const MBEDTLS_TLS_RSA_WITH_RC4_128_MD5: u32 = 4;
pub const MBEDTLS_TLS_RSA_WITH_RC4_128_SHA: u32 = 5;
pub const MBEDTLS_TLS_RSA_WITH_DES_CBC_SHA: u32 = 9;
pub const MBEDTLS_TLS_RSA_WITH_3DES_EDE_CBC_SHA: u32 = 10;
pub const MBEDTLS_TLS_DHE_RSA_WITH_DES_CBC_SHA: u32 = 21;
pub const MBEDTLS_TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA: u32 = 22;
pub const MBEDTLS_TLS_PSK_WITH_NULL_SHA: u32 = 44;
pub const MBEDTLS_TLS_DHE_PSK_WITH_NULL_SHA: u32 = 45;
pub const MBEDTLS_TLS_RSA_PSK_WITH_NULL_SHA: u32 = 46;
pub const MBEDTLS_TLS_RSA_WITH_AES_128_CBC_SHA: u32 = 47;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CBC_SHA: u32 = 51;
pub const MBEDTLS_TLS_RSA_WITH_AES_256_CBC_SHA: u32 = 53;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CBC_SHA: u32 = 57;
pub const MBEDTLS_TLS_RSA_WITH_NULL_SHA256: u32 = 59;
pub const MBEDTLS_TLS_RSA_WITH_AES_128_CBC_SHA256: u32 = 60;
pub const MBEDTLS_TLS_RSA_WITH_AES_256_CBC_SHA256: u32 = 61;
pub const MBEDTLS_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA: u32 = 65;
pub const MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA: u32 = 69;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256: u32 = 103;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256: u32 = 107;
pub const MBEDTLS_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA: u32 = 132;
pub const MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA: u32 = 136;
pub const MBEDTLS_TLS_PSK_WITH_RC4_128_SHA: u32 = 138;
pub const MBEDTLS_TLS_PSK_WITH_3DES_EDE_CBC_SHA: u32 = 139;
pub const MBEDTLS_TLS_PSK_WITH_AES_128_CBC_SHA: u32 = 140;
pub const MBEDTLS_TLS_PSK_WITH_AES_256_CBC_SHA: u32 = 141;
pub const MBEDTLS_TLS_DHE_PSK_WITH_RC4_128_SHA: u32 = 142;
pub const MBEDTLS_TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA: u32 = 143;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_128_CBC_SHA: u32 = 144;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_256_CBC_SHA: u32 = 145;
pub const MBEDTLS_TLS_RSA_PSK_WITH_RC4_128_SHA: u32 = 146;
pub const MBEDTLS_TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA: u32 = 147;
pub const MBEDTLS_TLS_RSA_PSK_WITH_AES_128_CBC_SHA: u32 = 148;
pub const MBEDTLS_TLS_RSA_PSK_WITH_AES_256_CBC_SHA: u32 = 149;
pub const MBEDTLS_TLS_RSA_WITH_AES_128_GCM_SHA256: u32 = 156;
pub const MBEDTLS_TLS_RSA_WITH_AES_256_GCM_SHA384: u32 = 157;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_128_GCM_SHA256: u32 = 158;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_256_GCM_SHA384: u32 = 159;
pub const MBEDTLS_TLS_PSK_WITH_AES_128_GCM_SHA256: u32 = 168;
pub const MBEDTLS_TLS_PSK_WITH_AES_256_GCM_SHA384: u32 = 169;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_128_GCM_SHA256: u32 = 170;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_256_GCM_SHA384: u32 = 171;
pub const MBEDTLS_TLS_RSA_PSK_WITH_AES_128_GCM_SHA256: u32 = 172;
pub const MBEDTLS_TLS_RSA_PSK_WITH_AES_256_GCM_SHA384: u32 = 173;
pub const MBEDTLS_TLS_PSK_WITH_AES_128_CBC_SHA256: u32 = 174;
pub const MBEDTLS_TLS_PSK_WITH_AES_256_CBC_SHA384: u32 = 175;
pub const MBEDTLS_TLS_PSK_WITH_NULL_SHA256: u32 = 176;
pub const MBEDTLS_TLS_PSK_WITH_NULL_SHA384: u32 = 177;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_128_CBC_SHA256: u32 = 178;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_256_CBC_SHA384: u32 = 179;
pub const MBEDTLS_TLS_DHE_PSK_WITH_NULL_SHA256: u32 = 180;
pub const MBEDTLS_TLS_DHE_PSK_WITH_NULL_SHA384: u32 = 181;
pub const MBEDTLS_TLS_RSA_PSK_WITH_AES_128_CBC_SHA256: u32 = 182;
pub const MBEDTLS_TLS_RSA_PSK_WITH_AES_256_CBC_SHA384: u32 = 183;
pub const MBEDTLS_TLS_RSA_PSK_WITH_NULL_SHA256: u32 = 184;
pub const MBEDTLS_TLS_RSA_PSK_WITH_NULL_SHA384: u32 = 185;
pub const MBEDTLS_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 186;
pub const MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 190;
pub const MBEDTLS_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256: u32 = 192;
pub const MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256: u32 = 196;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_NULL_SHA: u32 = 49153;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_RC4_128_SHA: u32 = 49154;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA: u32 = 49155;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA: u32 = 49156;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA: u32 = 49157;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_NULL_SHA: u32 = 49158;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_RC4_128_SHA: u32 = 49159;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA: u32 = 49160;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA: u32 = 49161;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA: u32 = 49162;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_NULL_SHA: u32 = 49163;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_RC4_128_SHA: u32 = 49164;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA: u32 = 49165;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA: u32 = 49166;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA: u32 = 49167;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_NULL_SHA: u32 = 49168;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_RC4_128_SHA: u32 = 49169;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA: u32 = 49170;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA: u32 = 49171;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA: u32 = 49172;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256: u32 = 49187;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384: u32 = 49188;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256: u32 = 49189;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384: u32 = 49190;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256: u32 = 49191;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384: u32 = 49192;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256: u32 = 49193;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384: u32 = 49194;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256: u32 = 49195;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384: u32 = 49196;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256: u32 = 49197;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384: u32 = 49198;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256: u32 = 49199;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384: u32 = 49200;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256: u32 = 49201;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384: u32 = 49202;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_RC4_128_SHA: u32 = 49203;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA: u32 = 49204;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA: u32 = 49205;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA: u32 = 49206;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256: u32 = 49207;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384: u32 = 49208;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_NULL_SHA: u32 = 49209;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_NULL_SHA256: u32 = 49210;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_NULL_SHA384: u32 = 49211;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49266;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49267;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49268;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49269;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49270;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49271;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49272;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49273;
pub const MBEDTLS_TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49274;
pub const MBEDTLS_TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49275;
pub const MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49276;
pub const MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49277;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49286;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49287;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49288;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49289;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49290;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49291;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49292;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49293;
pub const MBEDTLS_TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49294;
pub const MBEDTLS_TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49295;
pub const MBEDTLS_TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49296;
pub const MBEDTLS_TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49297;
pub const MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49298;
pub const MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49299;
pub const MBEDTLS_TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49300;
pub const MBEDTLS_TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49301;
pub const MBEDTLS_TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49302;
pub const MBEDTLS_TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49303;
pub const MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49304;
pub const MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49305;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49306;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49307;
pub const MBEDTLS_TLS_RSA_WITH_AES_128_CCM: u32 = 49308;
pub const MBEDTLS_TLS_RSA_WITH_AES_256_CCM: u32 = 49309;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CCM: u32 = 49310;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CCM: u32 = 49311;
pub const MBEDTLS_TLS_RSA_WITH_AES_128_CCM_8: u32 = 49312;
pub const MBEDTLS_TLS_RSA_WITH_AES_256_CCM_8: u32 = 49313;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CCM_8: u32 = 49314;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CCM_8: u32 = 49315;
pub const MBEDTLS_TLS_PSK_WITH_AES_128_CCM: u32 = 49316;
pub const MBEDTLS_TLS_PSK_WITH_AES_256_CCM: u32 = 49317;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_128_CCM: u32 = 49318;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_256_CCM: u32 = 49319;
pub const MBEDTLS_TLS_PSK_WITH_AES_128_CCM_8: u32 = 49320;
pub const MBEDTLS_TLS_PSK_WITH_AES_256_CCM_8: u32 = 49321;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_128_CCM_8: u32 = 49322;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_256_CCM_8: u32 = 49323;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_CCM: u32 = 49324;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_CCM: u32 = 49325;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8: u32 = 49326;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8: u32 = 49327;
pub const MBEDTLS_TLS_ECJPAKE_WITH_AES_128_CCM_8: u32 = 49407;
pub const MBEDTLS_CIPHERSUITE_WEAK: u32 = 1;
pub const MBEDTLS_CIPHERSUITE_SHORT_TAG: u32 = 2;
pub const MBEDTLS_CIPHERSUITE_NODTLS: u32 = 4;
pub const MBEDTLS_ERR_ASN1_OUT_OF_DATA: i32 = -96;
pub const MBEDTLS_ERR_ASN1_UNEXPECTED_TAG: i32 = -98;
pub const MBEDTLS_ERR_ASN1_INVALID_LENGTH: i32 = -100;
pub const MBEDTLS_ERR_ASN1_LENGTH_MISMATCH: i32 = -102;
pub const MBEDTLS_ERR_ASN1_INVALID_DATA: i32 = -104;
pub const MBEDTLS_ERR_ASN1_ALLOC_FAILED: i32 = -106;
pub const MBEDTLS_ERR_ASN1_BUF_TOO_SMALL: i32 = -108;
pub const MBEDTLS_ASN1_BOOLEAN: u32 = 1;
pub const MBEDTLS_ASN1_INTEGER: u32 = 2;
pub const MBEDTLS_ASN1_BIT_STRING: u32 = 3;
pub const MBEDTLS_ASN1_OCTET_STRING: u32 = 4;
pub const MBEDTLS_ASN1_NULL: u32 = 5;
pub const MBEDTLS_ASN1_OID: u32 = 6;
pub const MBEDTLS_ASN1_UTF8_STRING: u32 = 12;
pub const MBEDTLS_ASN1_SEQUENCE: u32 = 16;
pub const MBEDTLS_ASN1_SET: u32 = 17;
pub const MBEDTLS_ASN1_PRINTABLE_STRING: u32 = 19;
pub const MBEDTLS_ASN1_T61_STRING: u32 = 20;
pub const MBEDTLS_ASN1_IA5_STRING: u32 = 22;
pub const MBEDTLS_ASN1_UTC_TIME: u32 = 23;
pub const MBEDTLS_ASN1_GENERALIZED_TIME: u32 = 24;
pub const MBEDTLS_ASN1_UNIVERSAL_STRING: u32 = 28;
pub const MBEDTLS_ASN1_BMP_STRING: u32 = 30;
pub const MBEDTLS_ASN1_PRIMITIVE: u32 = 0;
pub const MBEDTLS_ASN1_CONSTRUCTED: u32 = 32;
pub const MBEDTLS_ASN1_CONTEXT_SPECIFIC: u32 = 128;
pub const MBEDTLS_X509_MAX_INTERMEDIATE_CA: u32 = 8;
pub const MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE: i32 = -8320;
pub const MBEDTLS_ERR_X509_UNKNOWN_OID: i32 = -8448;
pub const MBEDTLS_ERR_X509_INVALID_FORMAT: i32 = -8576;
pub const MBEDTLS_ERR_X509_INVALID_VERSION: i32 = -8704;
pub const MBEDTLS_ERR_X509_INVALID_SERIAL: i32 = -8832;
pub const MBEDTLS_ERR_X509_INVALID_ALG: i32 = -8960;
pub const MBEDTLS_ERR_X509_INVALID_NAME: i32 = -9088;
pub const MBEDTLS_ERR_X509_INVALID_DATE: i32 = -9216;
pub const MBEDTLS_ERR_X509_INVALID_SIGNATURE: i32 = -9344;
pub const MBEDTLS_ERR_X509_INVALID_EXTENSIONS: i32 = -9472;
pub const MBEDTLS_ERR_X509_UNKNOWN_VERSION: i32 = -9600;
pub const MBEDTLS_ERR_X509_UNKNOWN_SIG_ALG: i32 = -9728;
pub const MBEDTLS_ERR_X509_SIG_MISMATCH: i32 = -9856;
pub const MBEDTLS_ERR_X509_CERT_VERIFY_FAILED: i32 = -9984;
pub const MBEDTLS_ERR_X509_CERT_UNKNOWN_FORMAT: i32 = -10112;
pub const MBEDTLS_ERR_X509_BAD_INPUT_DATA: i32 = -10240;
pub const MBEDTLS_ERR_X509_ALLOC_FAILED: i32 = -10368;
pub const MBEDTLS_ERR_X509_FILE_IO_ERROR: i32 = -10496;
pub const MBEDTLS_ERR_X509_BUFFER_TOO_SMALL: i32 = -10624;
pub const MBEDTLS_X509_BADCERT_EXPIRED: u32 = 1;
pub const MBEDTLS_X509_BADCERT_REVOKED: u32 = 2;
pub const MBEDTLS_X509_BADCERT_CN_MISMATCH: u32 = 4;
pub const MBEDTLS_X509_BADCERT_NOT_TRUSTED: u32 = 8;
pub const MBEDTLS_X509_BADCRL_NOT_TRUSTED: u32 = 16;
pub const MBEDTLS_X509_BADCRL_EXPIRED: u32 = 32;
pub const MBEDTLS_X509_BADCERT_MISSING: u32 = 64;
pub const MBEDTLS_X509_BADCERT_SKIP_VERIFY: u32 = 128;
pub const MBEDTLS_X509_BADCERT_OTHER: u32 = 256;
pub const MBEDTLS_X509_BADCERT_FUTURE: u32 = 512;
pub const MBEDTLS_X509_BADCRL_FUTURE: u32 = 1024;
pub const MBEDTLS_X509_BADCERT_KEY_USAGE: u32 = 2048;
pub const MBEDTLS_X509_BADCERT_EXT_KEY_USAGE: u32 = 4096;
pub const MBEDTLS_X509_BADCERT_NS_CERT_TYPE: u32 = 8192;
pub const MBEDTLS_X509_BADCERT_BAD_MD: u32 = 16384;
pub const MBEDTLS_X509_BADCERT_BAD_PK: u32 = 32768;
pub const MBEDTLS_X509_BADCERT_BAD_KEY: u32 = 65536;
pub const MBEDTLS_X509_BADCRL_BAD_MD: u32 = 131072;
pub const MBEDTLS_X509_BADCRL_BAD_PK: u32 = 262144;
pub const MBEDTLS_X509_BADCRL_BAD_KEY: u32 = 524288;
pub const MBEDTLS_X509_KU_DIGITAL_SIGNATURE: u32 = 128;
pub const MBEDTLS_X509_KU_NON_REPUDIATION: u32 = 64;
pub const MBEDTLS_X509_KU_KEY_ENCIPHERMENT: u32 = 32;
pub const MBEDTLS_X509_KU_DATA_ENCIPHERMENT: u32 = 16;
pub const MBEDTLS_X509_KU_KEY_AGREEMENT: u32 = 8;
pub const MBEDTLS_X509_KU_KEY_CERT_SIGN: u32 = 4;
pub const MBEDTLS_X509_KU_CRL_SIGN: u32 = 2;
pub const MBEDTLS_X509_KU_ENCIPHER_ONLY: u32 = 1;
pub const MBEDTLS_X509_KU_DECIPHER_ONLY: u32 = 32768;
pub const MBEDTLS_X509_NS_CERT_TYPE_SSL_CLIENT: u32 = 128;
pub const MBEDTLS_X509_NS_CERT_TYPE_SSL_SERVER: u32 = 64;
pub const MBEDTLS_X509_NS_CERT_TYPE_EMAIL: u32 = 32;
pub const MBEDTLS_X509_NS_CERT_TYPE_OBJECT_SIGNING: u32 = 16;
pub const MBEDTLS_X509_NS_CERT_TYPE_RESERVED: u32 = 8;
pub const MBEDTLS_X509_NS_CERT_TYPE_SSL_CA: u32 = 4;
pub const MBEDTLS_X509_NS_CERT_TYPE_EMAIL_CA: u32 = 2;
pub const MBEDTLS_X509_NS_CERT_TYPE_OBJECT_SIGNING_CA: u32 = 1;
pub const MBEDTLS_X509_EXT_AUTHORITY_KEY_IDENTIFIER: u32 = 1;
pub const MBEDTLS_X509_EXT_SUBJECT_KEY_IDENTIFIER: u32 = 2;
pub const MBEDTLS_X509_EXT_KEY_USAGE: u32 = 4;
pub const MBEDTLS_X509_EXT_CERTIFICATE_POLICIES: u32 = 8;
pub const MBEDTLS_X509_EXT_POLICY_MAPPINGS: u32 = 16;
pub const MBEDTLS_X509_EXT_SUBJECT_ALT_NAME: u32 = 32;
pub const MBEDTLS_X509_EXT_ISSUER_ALT_NAME: u32 = 64;
pub const MBEDTLS_X509_EXT_SUBJECT_DIRECTORY_ATTRS: u32 = 128;
pub const MBEDTLS_X509_EXT_BASIC_CONSTRAINTS: u32 = 256;
pub const MBEDTLS_X509_EXT_NAME_CONSTRAINTS: u32 = 512;
pub const MBEDTLS_X509_EXT_POLICY_CONSTRAINTS: u32 = 1024;
pub const MBEDTLS_X509_EXT_EXTENDED_KEY_USAGE: u32 = 2048;
pub const MBEDTLS_X509_EXT_CRL_DISTRIBUTION_POINTS: u32 = 4096;
pub const MBEDTLS_X509_EXT_INIHIBIT_ANYPOLICY: u32 = 8192;
pub const MBEDTLS_X509_EXT_FRESHEST_CRL: u32 = 16384;
pub const MBEDTLS_X509_EXT_NS_CERT_TYPE: u32 = 65536;
pub const MBEDTLS_X509_FORMAT_DER: u32 = 1;
pub const MBEDTLS_X509_FORMAT_PEM: u32 = 2;
pub const MBEDTLS_X509_MAX_DN_NAME_SIZE: u32 = 256;
pub const MBEDTLS_X509_CRT_VERSION_1: u32 = 0;
pub const MBEDTLS_X509_CRT_VERSION_2: u32 = 1;
pub const MBEDTLS_X509_CRT_VERSION_3: u32 = 2;
pub const MBEDTLS_X509_RFC5280_MAX_SERIAL_LEN: u32 = 32;
pub const MBEDTLS_X509_RFC5280_UTC_TIME_LEN: u32 = 15;
pub const MBEDTLS_X509_MAX_FILE_PATH_LEN: u32 = 512;
pub const MBEDTLS_ERR_DHM_BAD_INPUT_DATA: i32 = -12416;
pub const MBEDTLS_ERR_DHM_READ_PARAMS_FAILED: i32 = -12544;
pub const MBEDTLS_ERR_DHM_MAKE_PARAMS_FAILED: i32 = -12672;
pub const MBEDTLS_ERR_DHM_READ_PUBLIC_FAILED: i32 = -12800;
pub const MBEDTLS_ERR_DHM_MAKE_PUBLIC_FAILED: i32 = -12928;
pub const MBEDTLS_ERR_DHM_CALC_SECRET_FAILED: i32 = -13056;
pub const MBEDTLS_ERR_DHM_INVALID_FORMAT: i32 = -13184;
pub const MBEDTLS_ERR_DHM_ALLOC_FAILED: i32 = -13312;
pub const MBEDTLS_ERR_DHM_FILE_IO_ERROR: i32 = -13440;
pub const MBEDTLS_DHM_RFC3526_MODP_2048_P : & 'static [u8 ; 513usize] = b"FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA18217C32905E462E36CE3BE39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF6955817183995497CEA956AE515D2261898FA051015728E5A8AACAA68FFFFFFFFFFFFFFFF\0" ;
pub const MBEDTLS_DHM_RFC3526_MODP_2048_G: &'static [u8; 3usize] = b"02\0";
pub const MBEDTLS_DHM_RFC3526_MODP_3072_P : & 'static [u8 ; 769usize] = b"FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA18217C32905E462E36CE3BE39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF6955817183995497CEA956AE515D2261898FA051015728E5A8AAAC42DAD33170D04507A33A85521ABDF1CBA64ECFB850458DBEF0A8AEA71575D060C7DB3970F85A6E1E4C7ABF5AE8CDB0933D71E8C94E04A25619DCEE3D2261AD2EE6BF12FFA06D98A0864D87602733EC86A64521F2B18177B200CBBE117577A615D6C770988C0BAD946E208E24FA074E5AB3143DB5BFCE0FD108E4B82D120A93AD2CAFFFFFFFFFFFFFFFF\0" ;
pub const MBEDTLS_DHM_RFC3526_MODP_3072_G: &'static [u8; 3usize] = b"02\0";
pub const MBEDTLS_DHM_RFC3526_MODP_4096_P : & 'static [u8 ; 1025usize] = b"FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA18217C32905E462E36CE3BE39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF6955817183995497CEA956AE515D2261898FA051015728E5A8AAAC42DAD33170D04507A33A85521ABDF1CBA64ECFB850458DBEF0A8AEA71575D060C7DB3970F85A6E1E4C7ABF5AE8CDB0933D71E8C94E04A25619DCEE3D2261AD2EE6BF12FFA06D98A0864D87602733EC86A64521F2B18177B200CBBE117577A615D6C770988C0BAD946E208E24FA074E5AB3143DB5BFCE0FD108E4B82D120A92108011A723C12A787E6D788719A10BDBA5B2699C327186AF4E23C1A946834B6150BDA2583E9CA2AD44CE8DBBBC2DB04DE8EF92E8EFC141FBECAA6287C59474E6BC05D99B2964FA090C3A2233BA186515BE7ED1F612970CEE2D7AFB81BDD762170481CD0069127D5B05AA993B4EA988D8FDDC186FFB7DC90A6C08F4DF435C934063199FFFFFFFFFFFFFFFF\0" ;
pub const MBEDTLS_DHM_RFC3526_MODP_4096_G: &'static [u8; 3usize] = b"02\0";
pub const MBEDTLS_DHM_RFC5114_MODP_2048_P : & 'static [u8 ; 513usize] = b"AD107E1E9123A9D0D660FAA79559C51FA20D64E5683B9FD1B54B1597B61D0A75E6FA141DF95A56DBAF9A3C407BA1DF15EB3D688A309C180E1DE6B85A1274A0A66D3F8152AD6AC2129037C9EDEFDA4DF8D91E8FEF55B7394B7AD5B7D0B6C12207C9F98D11ED34DBF6C6BA0B2C8BBC27BE6A00E0A0B9C49708B3BF8A317091883681286130BC8985DB1602E714415D9330278273C7DE31EFDC7310F7121FD5A07415987D9ADC0A486DCDF93ACC44328387315D75E198C641A480CD86A1B9E587E8BE60E69CC928B2B9C52172E413042E9B23F10B0E16E79763C9B53DCF4BA80A29E3FB73C16B8E75B97EF363E2FFA31F71CF9DE5384E71B81C0AC4DFFE0C10E64F\0" ;
pub const MBEDTLS_DHM_RFC5114_MODP_2048_G : & 'static [u8 ; 513usize] = b"AC4032EF4F2D9AE39DF30B5C8FFDAC506CDEBE7B89998CAF74866A08CFE4FFE3A6824A4E10B9A6F0DD921F01A70C4AFAAB739D7700C29F52C57DB17C620A8652BE5E9001A8D66AD7C17669101999024AF4D027275AC1348BB8A762D0521BC98AE247150422EA1ED409939D54DA7460CDB5F6C6B250717CBEF180EB34118E98D119529A45D6F834566E3025E316A330EFBB77A86F0C1AB15B051AE3D428C8F8ACB70A8137150B8EEB10E183EDD19963DDD9E263E4770589EF6AA21E7F5F2FF381B539CCE3409D13CD566AFBB48D6C019181E1BCFE94B30269EDFE72FE9B6AA4BD7B5A0F1C71CFFF4C19C418E1F6EC017981BC087F2A7065B384B890D3191F2BFA\0" ;
pub const MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE: i32 = -28800;
pub const MBEDTLS_ERR_SSL_BAD_INPUT_DATA: i32 = -28928;
pub const MBEDTLS_ERR_SSL_INVALID_MAC: i32 = -29056;
pub const MBEDTLS_ERR_SSL_INVALID_RECORD: i32 = -29184;
pub const MBEDTLS_ERR_SSL_CONN_EOF: i32 = -29312;
pub const MBEDTLS_ERR_SSL_UNKNOWN_CIPHER: i32 = -29440;
pub const MBEDTLS_ERR_SSL_NO_CIPHER_CHOSEN: i32 = -29568;
pub const MBEDTLS_ERR_SSL_NO_RNG: i32 = -29696;
pub const MBEDTLS_ERR_SSL_NO_CLIENT_CERTIFICATE: i32 = -29824;
pub const MBEDTLS_ERR_SSL_CERTIFICATE_TOO_LARGE: i32 = -29952;
pub const MBEDTLS_ERR_SSL_CERTIFICATE_REQUIRED: i32 = -30080;
pub const MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED: i32 = -30208;
pub const MBEDTLS_ERR_SSL_CA_CHAIN_REQUIRED: i32 = -30336;
pub const MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE: i32 = -30464;
pub const MBEDTLS_ERR_SSL_FATAL_ALERT_MESSAGE: i32 = -30592;
pub const MBEDTLS_ERR_SSL_PEER_VERIFY_FAILED: i32 = -30720;
pub const MBEDTLS_ERR_SSL_PEER_CLOSE_NOTIFY: i32 = -30848;
pub const MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO: i32 = -30976;
pub const MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO: i32 = -31104;
pub const MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE: i32 = -31232;
pub const MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_REQUEST: i32 = -31360;
pub const MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE: i32 = -31488;
pub const MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO_DONE: i32 = -31616;
pub const MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE: i32 = -31744;
pub const MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_RP: i32 = -31872;
pub const MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_CS: i32 = -32000;
pub const MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY: i32 = -32128;
pub const MBEDTLS_ERR_SSL_BAD_HS_CHANGE_CIPHER_SPEC: i32 = -32256;
pub const MBEDTLS_ERR_SSL_BAD_HS_FINISHED: i32 = -32384;
pub const MBEDTLS_ERR_SSL_ALLOC_FAILED: i32 = -32512;
pub const MBEDTLS_ERR_SSL_HW_ACCEL_FAILED: i32 = -32640;
pub const MBEDTLS_ERR_SSL_HW_ACCEL_FALLTHROUGH: i32 = -28544;
pub const MBEDTLS_ERR_SSL_COMPRESSION_FAILED: i32 = -28416;
pub const MBEDTLS_ERR_SSL_BAD_HS_PROTOCOL_VERSION: i32 = -28288;
pub const MBEDTLS_ERR_SSL_BAD_HS_NEW_SESSION_TICKET: i32 = -28160;
pub const MBEDTLS_ERR_SSL_SESSION_TICKET_EXPIRED: i32 = -28032;
pub const MBEDTLS_ERR_SSL_PK_TYPE_MISMATCH: i32 = -27904;
pub const MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY: i32 = -27776;
pub const MBEDTLS_ERR_SSL_INTERNAL_ERROR: i32 = -27648;
pub const MBEDTLS_ERR_SSL_COUNTER_WRAPPING: i32 = -27520;
pub const MBEDTLS_ERR_SSL_WAITING_SERVER_HELLO_RENEGO: i32 = -27392;
pub const MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED: i32 = -27264;
pub const MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL: i32 = -27136;
pub const MBEDTLS_ERR_SSL_NO_USABLE_CIPHERSUITE: i32 = -27008;
pub const MBEDTLS_ERR_SSL_WANT_READ: i32 = -26880;
pub const MBEDTLS_ERR_SSL_WANT_WRITE: i32 = -26752;
pub const MBEDTLS_ERR_SSL_TIMEOUT: i32 = -26624;
pub const MBEDTLS_ERR_SSL_CLIENT_RECONNECT: i32 = -26496;
pub const MBEDTLS_ERR_SSL_UNEXPECTED_RECORD: i32 = -26368;
pub const MBEDTLS_ERR_SSL_NON_FATAL: i32 = -26240;
pub const MBEDTLS_ERR_SSL_INVALID_VERIFY_HASH: i32 = -26112;
pub const MBEDTLS_SSL_MAJOR_VERSION_3: u32 = 3;
pub const MBEDTLS_SSL_MINOR_VERSION_0: u32 = 0;
pub const MBEDTLS_SSL_MINOR_VERSION_1: u32 = 1;
pub const MBEDTLS_SSL_MINOR_VERSION_2: u32 = 2;
pub const MBEDTLS_SSL_MINOR_VERSION_3: u32 = 3;
pub const MBEDTLS_SSL_TRANSPORT_STREAM: u32 = 0;
pub const MBEDTLS_SSL_TRANSPORT_DATAGRAM: u32 = 1;
pub const MBEDTLS_SSL_MAX_HOST_NAME_LEN: u32 = 255;
pub const MBEDTLS_SSL_MAX_FRAG_LEN_NONE: u32 = 0;
pub const MBEDTLS_SSL_MAX_FRAG_LEN_512: u32 = 1;
pub const MBEDTLS_SSL_MAX_FRAG_LEN_1024: u32 = 2;
pub const MBEDTLS_SSL_MAX_FRAG_LEN_2048: u32 = 3;
pub const MBEDTLS_SSL_MAX_FRAG_LEN_4096: u32 = 4;
pub const MBEDTLS_SSL_MAX_FRAG_LEN_INVALID: u32 = 5;
pub const MBEDTLS_SSL_IS_CLIENT: u32 = 0;
pub const MBEDTLS_SSL_IS_SERVER: u32 = 1;
pub const MBEDTLS_SSL_IS_NOT_FALLBACK: u32 = 0;
pub const MBEDTLS_SSL_IS_FALLBACK: u32 = 1;
pub const MBEDTLS_SSL_EXTENDED_MS_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_EXTENDED_MS_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_ETM_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_ETM_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_COMPRESS_NULL: u32 = 0;
pub const MBEDTLS_SSL_COMPRESS_DEFLATE: u32 = 1;
pub const MBEDTLS_SSL_VERIFY_NONE: u32 = 0;
pub const MBEDTLS_SSL_VERIFY_OPTIONAL: u32 = 1;
pub const MBEDTLS_SSL_VERIFY_REQUIRED: u32 = 2;
pub const MBEDTLS_SSL_VERIFY_UNSET: u32 = 3;
pub const MBEDTLS_SSL_LEGACY_RENEGOTIATION: u32 = 0;
pub const MBEDTLS_SSL_SECURE_RENEGOTIATION: u32 = 1;
pub const MBEDTLS_SSL_RENEGOTIATION_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_RENEGOTIATION_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_ANTI_REPLAY_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_ANTI_REPLAY_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_RENEGOTIATION_NOT_ENFORCED: i32 = -1;
pub const MBEDTLS_SSL_RENEGO_MAX_RECORDS_DEFAULT: u32 = 16;
pub const MBEDTLS_SSL_LEGACY_NO_RENEGOTIATION: u32 = 0;
pub const MBEDTLS_SSL_LEGACY_ALLOW_RENEGOTIATION: u32 = 1;
pub const MBEDTLS_SSL_LEGACY_BREAK_HANDSHAKE: u32 = 2;
pub const MBEDTLS_SSL_TRUNC_HMAC_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_TRUNC_HMAC_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_TRUNCATED_HMAC_LEN: u32 = 10;
pub const MBEDTLS_SSL_SESSION_TICKETS_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_SESSION_TICKETS_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_CBC_RECORD_SPLITTING_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_CBC_RECORD_SPLITTING_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_ARC4_ENABLED: u32 = 0;
pub const MBEDTLS_SSL_ARC4_DISABLED: u32 = 1;
pub const MBEDTLS_SSL_PRESET_DEFAULT: u32 = 0;
pub const MBEDTLS_SSL_PRESET_SUITEB: u32 = 2;
pub const MBEDTLS_SSL_DTLS_TIMEOUT_DFL_MIN: u32 = 1000;
pub const MBEDTLS_SSL_DTLS_TIMEOUT_DFL_MAX: u32 = 60000;
pub const MBEDTLS_SSL_DEFAULT_TICKET_LIFETIME: u32 = 86400;
pub const MBEDTLS_SSL_VERIFY_DATA_MAX_LEN: u32 = 12;
pub const MBEDTLS_SSL_EMPTY_RENEGOTIATION_INFO: u32 = 255;
pub const MBEDTLS_SSL_FALLBACK_SCSV_VALUE: u32 = 22016;
pub const MBEDTLS_SSL_HASH_NONE: u32 = 0;
pub const MBEDTLS_SSL_HASH_MD5: u32 = 1;
pub const MBEDTLS_SSL_HASH_SHA1: u32 = 2;
pub const MBEDTLS_SSL_HASH_SHA224: u32 = 3;
pub const MBEDTLS_SSL_HASH_SHA256: u32 = 4;
pub const MBEDTLS_SSL_HASH_SHA384: u32 = 5;
pub const MBEDTLS_SSL_HASH_SHA512: u32 = 6;
pub const MBEDTLS_SSL_SIG_ANON: u32 = 0;
pub const MBEDTLS_SSL_SIG_RSA: u32 = 1;
pub const MBEDTLS_SSL_SIG_ECDSA: u32 = 3;
pub const MBEDTLS_SSL_CERT_TYPE_RSA_SIGN: u32 = 1;
pub const MBEDTLS_SSL_CERT_TYPE_ECDSA_SIGN: u32 = 64;
pub const MBEDTLS_SSL_MSG_CHANGE_CIPHER_SPEC: u32 = 20;
pub const MBEDTLS_SSL_MSG_ALERT: u32 = 21;
pub const MBEDTLS_SSL_MSG_HANDSHAKE: u32 = 22;
pub const MBEDTLS_SSL_MSG_APPLICATION_DATA: u32 = 23;
pub const MBEDTLS_SSL_ALERT_LEVEL_WARNING: u32 = 1;
pub const MBEDTLS_SSL_ALERT_LEVEL_FATAL: u32 = 2;
pub const MBEDTLS_SSL_ALERT_MSG_CLOSE_NOTIFY: u32 = 0;
pub const MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE: u32 = 10;
pub const MBEDTLS_SSL_ALERT_MSG_BAD_RECORD_MAC: u32 = 20;
pub const MBEDTLS_SSL_ALERT_MSG_DECRYPTION_FAILED: u32 = 21;
pub const MBEDTLS_SSL_ALERT_MSG_RECORD_OVERFLOW: u32 = 22;
pub const MBEDTLS_SSL_ALERT_MSG_DECOMPRESSION_FAILURE: u32 = 30;
pub const MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE: u32 = 40;
pub const MBEDTLS_SSL_ALERT_MSG_NO_CERT: u32 = 41;
pub const MBEDTLS_SSL_ALERT_MSG_BAD_CERT: u32 = 42;
pub const MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_CERT: u32 = 43;
pub const MBEDTLS_SSL_ALERT_MSG_CERT_REVOKED: u32 = 44;
pub const MBEDTLS_SSL_ALERT_MSG_CERT_EXPIRED: u32 = 45;
pub const MBEDTLS_SSL_ALERT_MSG_CERT_UNKNOWN: u32 = 46;
pub const MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER: u32 = 47;
pub const MBEDTLS_SSL_ALERT_MSG_UNKNOWN_CA: u32 = 48;
pub const MBEDTLS_SSL_ALERT_MSG_ACCESS_DENIED: u32 = 49;
pub const MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR: u32 = 50;
pub const MBEDTLS_SSL_ALERT_MSG_DECRYPT_ERROR: u32 = 51;
pub const MBEDTLS_SSL_ALERT_MSG_EXPORT_RESTRICTION: u32 = 60;
pub const MBEDTLS_SSL_ALERT_MSG_PROTOCOL_VERSION: u32 = 70;
pub const MBEDTLS_SSL_ALERT_MSG_INSUFFICIENT_SECURITY: u32 = 71;
pub const MBEDTLS_SSL_ALERT_MSG_INTERNAL_ERROR: u32 = 80;
pub const MBEDTLS_SSL_ALERT_MSG_INAPROPRIATE_FALLBACK: u32 = 86;
pub const MBEDTLS_SSL_ALERT_MSG_USER_CANCELED: u32 = 90;
pub const MBEDTLS_SSL_ALERT_MSG_NO_RENEGOTIATION: u32 = 100;
pub const MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_EXT: u32 = 110;
pub const MBEDTLS_SSL_ALERT_MSG_UNRECOGNIZED_NAME: u32 = 112;
pub const MBEDTLS_SSL_ALERT_MSG_UNKNOWN_PSK_IDENTITY: u32 = 115;
pub const MBEDTLS_SSL_ALERT_MSG_NO_APPLICATION_PROTOCOL: u32 = 120;
pub const MBEDTLS_SSL_HS_HELLO_REQUEST: u32 = 0;
pub const MBEDTLS_SSL_HS_CLIENT_HELLO: u32 = 1;
pub const MBEDTLS_SSL_HS_SERVER_HELLO: u32 = 2;
pub const MBEDTLS_SSL_HS_HELLO_VERIFY_REQUEST: u32 = 3;
pub const MBEDTLS_SSL_HS_NEW_SESSION_TICKET: u32 = 4;
pub const MBEDTLS_SSL_HS_CERTIFICATE: u32 = 11;
pub const MBEDTLS_SSL_HS_SERVER_KEY_EXCHANGE: u32 = 12;
pub const MBEDTLS_SSL_HS_CERTIFICATE_REQUEST: u32 = 13;
pub const MBEDTLS_SSL_HS_SERVER_HELLO_DONE: u32 = 14;
pub const MBEDTLS_SSL_HS_CERTIFICATE_VERIFY: u32 = 15;
pub const MBEDTLS_SSL_HS_CLIENT_KEY_EXCHANGE: u32 = 16;
pub const MBEDTLS_SSL_HS_FINISHED: u32 = 20;
pub const MBEDTLS_TLS_EXT_SERVERNAME: u32 = 0;
pub const MBEDTLS_TLS_EXT_SERVERNAME_HOSTNAME: u32 = 0;
pub const MBEDTLS_TLS_EXT_MAX_FRAGMENT_LENGTH: u32 = 1;
pub const MBEDTLS_TLS_EXT_TRUNCATED_HMAC: u32 = 4;
pub const MBEDTLS_TLS_EXT_SUPPORTED_ELLIPTIC_CURVES: u32 = 10;
pub const MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS: u32 = 11;
pub const MBEDTLS_TLS_EXT_SIG_ALG: u32 = 13;
pub const MBEDTLS_TLS_EXT_ALPN: u32 = 16;
pub const MBEDTLS_TLS_EXT_ENCRYPT_THEN_MAC: u32 = 22;
pub const MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET: u32 = 23;
pub const MBEDTLS_TLS_EXT_SESSION_TICKET: u32 = 35;
pub const MBEDTLS_TLS_EXT_ECJPAKE_KKPP: u32 = 256;
pub const MBEDTLS_TLS_EXT_RENEGOTIATION_INFO: u32 = 65281;
pub const MBEDTLS_PSK_MAX_LEN: u32 = 32;
pub const MBEDTLS_ERR_NET_SOCKET_FAILED: i32 = -66;
pub const MBEDTLS_ERR_NET_CONNECT_FAILED: i32 = -68;
pub const MBEDTLS_ERR_NET_BIND_FAILED: i32 = -70;
pub const MBEDTLS_ERR_NET_LISTEN_FAILED: i32 = -72;
pub const MBEDTLS_ERR_NET_ACCEPT_FAILED: i32 = -74;
pub const MBEDTLS_ERR_NET_RECV_FAILED: i32 = -76;
pub const MBEDTLS_ERR_NET_SEND_FAILED: i32 = -78;
pub const MBEDTLS_ERR_NET_CONN_RESET: i32 = -80;
pub const MBEDTLS_ERR_NET_UNKNOWN_HOST: i32 = -82;
pub const MBEDTLS_ERR_NET_BUFFER_TOO_SMALL: i32 = -67;
pub const MBEDTLS_ERR_NET_INVALID_CONTEXT: i32 = -69;
pub const MBEDTLS_NET_LISTEN_BACKLOG: u32 = 10;
pub const MBEDTLS_NET_PROTO_TCP: u32 = 0;
pub const MBEDTLS_NET_PROTO_UDP: u32 = 1;
pub const PMU_DEVICE_TIMER_DEFAULT_INTERVAL: u32 = 2000;
pub const PMU_DEVICE_TIMER_MAX_INTERVAL: u32 = 30000;
pub const tskKERNEL_VERSION_NUMBER: &'static [u8; 8usize] = b"V10.2.0\0";
pub const tskKERNEL_VERSION_MAJOR: u32 = 10;
pub const tskKERNEL_VERSION_MINOR: u32 = 2;
pub const tskKERNEL_VERSION_BUILD: u32 = 0;
pub const tskMPU_REGION_READ_ONLY: u32 = 1;
pub const tskMPU_REGION_READ_WRITE: u32 = 2;
pub const tskMPU_REGION_EXECUTE_NEVER: u32 = 4;
pub const tskMPU_REGION_NORMAL_MEMORY: u32 = 8;
pub const tskMPU_REGION_DEVICE_MEMORY: u32 = 16;
pub const NVIC_NUM_VECTORS: u32 = 128;
pub const WLAN0_NAME: &'static [u8; 6usize] = b"wlan0\0";
pub const WLAN1_NAME: &'static [u8; 6usize] = b"wlan1\0";
pub const WEP_ENABLED: u32 = 1;
pub const TKIP_ENABLED: u32 = 2;
pub const AES_ENABLED: u32 = 4;
pub const WSEC_SWFLAG: u32 = 8;
pub const AES_CMAC_ENABLED: u32 = 16;
pub const ENTERPRISE_ENABLED: u32 = 32;
pub const SHARED_ENABLED: u32 = 32768;
pub const WPA_SECURITY: u32 = 2097152;
pub const WPA2_SECURITY: u32 = 4194304;
pub const WPA3_SECURITY: u32 = 8388608;
pub const WPS_ENABLED: u32 = 268435456;
pub const RTW_MAX_PSK_LEN: u32 = 64;
pub const RTW_MIN_PSK_LEN: u32 = 8;
pub const MCSSET_LEN: u32 = 16;
pub const IFNAMSIZ: u32 = 16;
pub const ARPHRD_ETHER: u32 = 1;
pub const WIRELESS_EXT: u32 = 22;
pub const E2BIG: u32 = 7;
pub const ETH_ALEN: u32 = 6;
pub const SIOCDEVPRIVATE: u32 = 35312;
pub const SIOCPROTOPRIVATE: u32 = 35296;
pub const SIOCSIWCOMMIT: u32 = 35584;
pub const SIOCGIWNAME: u32 = 35585;
pub const SIOCSIWNWID: u32 = 35586;
pub const SIOCGIWNWID: u32 = 35587;
pub const SIOCSIWFREQ: u32 = 35588;
pub const SIOCGIWFREQ: u32 = 35589;
pub const SIOCSIWMODE: u32 = 35590;
pub const SIOCGIWMODE: u32 = 35591;
pub const SIOCSIWSENS: u32 = 35592;
pub const SIOCGIWSENS: u32 = 35593;
pub const SIOCSIWRANGE: u32 = 35594;
pub const SIOCGIWRANGE: u32 = 35595;
pub const SIOCSIWPRIV: u32 = 35596;
pub const SIOCGIWPRIV: u32 = 35597;
pub const SIOCSIWSTATS: u32 = 35598;
pub const SIOCGIWSTATS: u32 = 35599;
pub const SIOCSIWSPY: u32 = 35600;
pub const SIOCGIWSPY: u32 = 35601;
pub const SIOCSIWTHRSPY: u32 = 35602;
pub const SIOCGIWTHRSPY: u32 = 35603;
pub const SIOCSIWAP: u32 = 35604;
pub const SIOCGIWAP: u32 = 35605;
pub const SIOCGIWAPLIST: u32 = 35607;
pub const SIOCSIWSCAN: u32 = 35608;
pub const SIOCGIWSCAN: u32 = 35609;
pub const SIOCSIWESSID: u32 = 35610;
pub const SIOCGIWESSID: u32 = 35611;
pub const SIOCSIWNICKN: u32 = 35612;
pub const SIOCGIWNICKN: u32 = 35613;
pub const SIOCSIWRATE: u32 = 35616;
pub const SIOCGIWRATE: u32 = 35617;
pub const SIOCSIWRTS: u32 = 35618;
pub const SIOCGIWRTS: u32 = 35619;
pub const SIOCSIWFRAG: u32 = 35620;
pub const SIOCGIWFRAG: u32 = 35621;
pub const SIOCSIWTXPOW: u32 = 35622;
pub const SIOCGIWTXPOW: u32 = 35623;
pub const SIOCSIWRETRY: u32 = 35624;
pub const SIOCGIWRETRY: u32 = 35625;
pub const SIOCSIWENCODE: u32 = 35626;
pub const SIOCGIWENCODE: u32 = 35627;
pub const SIOCSIWPOWER: u32 = 35628;
pub const SIOCGIWPOWER: u32 = 35629;
pub const SIOCSIWMODUL: u32 = 35630;
pub const SIOCGIWMODUL: u32 = 35631;
pub const SIOCSIWGENIE: u32 = 35632;
pub const SIOCGIWGENIE: u32 = 35633;
pub const SIOCSIWMLME: u32 = 35606;
pub const SIOCSIWAUTH: u32 = 35634;
pub const SIOCGIWAUTH: u32 = 35635;
pub const SIOCSIWENCODEEXT: u32 = 35636;
pub const SIOCGIWENCODEEXT: u32 = 35637;
pub const SIOCSIWPMKSA: u32 = 35638;
pub const SIOCSIWMGNTSEND: u32 = 35639;
pub const SIOCSIWEAPOLSEND: u32 = 35640;
pub const SIOCQPATHTABLE: u32 = 35744;
pub const SIOCUPATHTABLE: u32 = 35745;
pub const SIOCAPATHTABLE: u32 = 35746;
pub const SIOCQAPATHTABLE: u32 = 35750;
pub const SIOC_NOTIFY_PATH_CREATE: u32 = 35753;
pub const SIOC_UPDATE_ROOT_INFO: u32 = 35754;
pub const SIOC_SET_ROUTING_INFO: u32 = 35757;
pub const UPDATE_MESH_METRIC: u32 = 35758;
pub const SIOC_MESH_TX_RAW_DATA: u32 = 35759;
pub const REMOVE_PATH_ENTRY: u32 = 35724;
pub const SIOCSIMAILBOX: u32 = 35641;
pub const SIOCSIWMFP: u32 = 35642;
pub const SIOCSIWGRPID: u32 = 35643;
pub const SIOCGIWSNR: u32 = 35644;
pub const SIOCIWFIRSTPRIV: u32 = 35808;
pub const SIOCIWLASTPRIV: u32 = 35839;
pub const SIOCSIWPRIVADAPTIVITY: u32 = 35835;
pub const SIOCGIWPRIVPASSPHRASE: u32 = 35836;
pub const SIOCSIWPRIVCOUNTRY: u32 = 35837;
pub const SIOCSIWPRIVAPESSID: u32 = 35838;
pub const SIOCSIWPRIVPASSPHRASE: u32 = 35839;
pub const SIOCIWFIRST: u32 = 35584;
pub const SIOCIWLAST: u32 = 35839;
pub const IWEVTXDROP: u32 = 35840;
pub const IWEVQUAL: u32 = 35841;
pub const IWEVCUSTOM: u32 = 35842;
pub const IWEVREGISTERED: u32 = 35843;
pub const IWEVEXPIRED: u32 = 35844;
pub const IWEVGENIE: u32 = 35845;
pub const IWEVMICHAELMICFAILURE: u32 = 35846;
pub const IWEVASSOCREQIE: u32 = 35847;
pub const IWEVASSOCRESPIE: u32 = 35848;
pub const IWEVPMKIDCAND: u32 = 35849;
pub const IWEVFIRST: u32 = 35840;
pub const IWEVMGNTRECV: u32 = 35856;
pub const IW_PRIV_TYPE_MASK: u32 = 28672;
pub const IW_PRIV_TYPE_NONE: u32 = 0;
pub const IW_PRIV_TYPE_BYTE: u32 = 4096;
pub const IW_PRIV_TYPE_CHAR: u32 = 8192;
pub const IW_PRIV_TYPE_INT: u32 = 16384;
pub const IW_PRIV_TYPE_FLOAT: u32 = 20480;
pub const IW_PRIV_TYPE_ADDR: u32 = 24576;
pub const IW_PRIV_SIZE_FIXED: u32 = 2048;
pub const IW_PRIV_SIZE_MASK: u32 = 2047;
pub const IW_MAX_FREQUENCIES: u32 = 32;
pub const IW_MAX_BITRATES: u32 = 32;
pub const IW_MAX_TXPOWER: u32 = 8;
pub const IW_MAX_SPY: u32 = 8;
pub const IW_MAX_AP: u32 = 64;
pub const IW_ESSID_MAX_SIZE: u32 = 32;
pub const IW_MODE_AUTO: u32 = 0;
pub const IW_MODE_ADHOC: u32 = 1;
pub const IW_MODE_INFRA: u32 = 2;
pub const IW_MODE_MASTER: u32 = 3;
pub const IW_MODE_REPEAT: u32 = 4;
pub const IW_MODE_SECOND: u32 = 5;
pub const IW_MODE_MONITOR: u32 = 6;
pub const IW_QUAL_QUAL_UPDATED: u32 = 1;
pub const IW_QUAL_LEVEL_UPDATED: u32 = 2;
pub const IW_QUAL_NOISE_UPDATED: u32 = 4;
pub const IW_QUAL_ALL_UPDATED: u32 = 7;
pub const IW_QUAL_DBM: u32 = 8;
pub const IW_QUAL_QUAL_INVALID: u32 = 16;
pub const IW_QUAL_LEVEL_INVALID: u32 = 32;
pub const IW_QUAL_NOISE_INVALID: u32 = 64;
pub const IW_QUAL_RCPI: u32 = 128;
pub const IW_QUAL_ALL_INVALID: u32 = 112;
pub const IW_FREQ_AUTO: u32 = 0;
pub const IW_FREQ_FIXED: u32 = 1;
pub const IW_MAX_ENCODING_SIZES: u32 = 8;
pub const IW_ENCODING_TOKEN_MAX: u32 = 64;
pub const IW_ENCODE_INDEX: u32 = 255;
pub const IW_ENCODE_FLAGS: u32 = 65280;
pub const IW_ENCODE_MODE: u32 = 61440;
pub const IW_ENCODE_DISABLED: u32 = 32768;
pub const IW_ENCODE_ENABLED: u32 = 0;
pub const IW_ENCODE_RESTRICTED: u32 = 16384;
pub const IW_ENCODE_OPEN: u32 = 8192;
pub const IW_ENCODE_NOKEY: u32 = 2048;
pub const IW_ENCODE_TEMP: u32 = 1024;
pub const IW_POWER_ON: u32 = 0;
pub const IW_POWER_TYPE: u32 = 61440;
pub const IW_POWER_PERIOD: u32 = 4096;
pub const IW_POWER_TIMEOUT: u32 = 8192;
pub const IW_POWER_SAVING: u32 = 16384;
pub const IW_POWER_MODE: u32 = 3840;
pub const IW_POWER_UNICAST_R: u32 = 256;
pub const IW_POWER_MULTICAST_R: u32 = 512;
pub const IW_POWER_ALL_R: u32 = 768;
pub const IW_POWER_FORCE_S: u32 = 1024;
pub const IW_POWER_REPEATER: u32 = 2048;
pub const IW_POWER_MODIFIER: u32 = 15;
pub const IW_POWER_MIN: u32 = 1;
pub const IW_POWER_MAX: u32 = 2;
pub const IW_POWER_RELATIVE: u32 = 4;
pub const IW_TXPOW_TYPE: u32 = 255;
pub const IW_TXPOW_DBM: u32 = 0;
pub const IW_TXPOW_MWATT: u32 = 1;
pub const IW_TXPOW_RELATIVE: u32 = 2;
pub const IW_TXPOW_RANGE: u32 = 4096;
pub const IW_RETRY_ON: u32 = 0;
pub const IW_RETRY_TYPE: u32 = 61440;
pub const IW_RETRY_LIMIT: u32 = 4096;
pub const IW_RETRY_LIFETIME: u32 = 8192;
pub const IW_RETRY_MODIFIER: u32 = 255;
pub const IW_RETRY_MIN: u32 = 1;
pub const IW_RETRY_MAX: u32 = 2;
pub const IW_RETRY_RELATIVE: u32 = 4;
pub const IW_RETRY_SHORT: u32 = 16;
pub const IW_RETRY_LONG: u32 = 32;
pub const IW_SCAN_DEFAULT: u32 = 0;
pub const IW_SCAN_ALL_ESSID: u32 = 1;
pub const IW_SCAN_THIS_ESSID: u32 = 2;
pub const IW_SCAN_ALL_FREQ: u32 = 4;
pub const IW_SCAN_THIS_FREQ: u32 = 8;
pub const IW_SCAN_ALL_MODE: u32 = 16;
pub const IW_SCAN_THIS_MODE: u32 = 32;
pub const IW_SCAN_ALL_RATE: u32 = 64;
pub const IW_SCAN_THIS_RATE: u32 = 128;
pub const IW_SCAN_TYPE_ACTIVE: u32 = 0;
pub const IW_SCAN_TYPE_PASSIVE: u32 = 1;
pub const IW_SCAN_MAX_DATA: u32 = 4096;
pub const IW_CUSTOM_MAX: u32 = 256;
pub const IW_GENERIC_IE_MAX: u32 = 1024;
pub const IW_MLME_DEAUTH: u32 = 0;
pub const IW_MLME_DISASSOC: u32 = 1;
pub const IW_MLME_AUTH: u32 = 2;
pub const IW_MLME_ASSOC: u32 = 3;
pub const IW_AUTH_INDEX: u32 = 4095;
pub const IW_AUTH_FLAGS: u32 = 61440;
pub const IW_AUTH_WPA_VERSION: u32 = 0;
pub const IW_AUTH_CIPHER_PAIRWISE: u32 = 1;
pub const IW_AUTH_CIPHER_GROUP: u32 = 2;
pub const IW_AUTH_KEY_MGMT: u32 = 3;
pub const IW_AUTH_TKIP_COUNTERMEASURES: u32 = 4;
pub const IW_AUTH_DROP_UNENCRYPTED: u32 = 5;
pub const IW_AUTH_80211_AUTH_ALG: u32 = 6;
pub const IW_AUTH_WPA_ENABLED: u32 = 7;
pub const IW_AUTH_RX_UNENCRYPTED_EAPOL: u32 = 8;
pub const IW_AUTH_ROAMING_CONTROL: u32 = 9;
pub const IW_AUTH_PRIVACY_INVOKED: u32 = 10;
pub const IW_AUTH_WPA_VERSION_DISABLED: u32 = 1;
pub const IW_AUTH_WPA_VERSION_WPA: u32 = 2;
pub const IW_AUTH_WPA_VERSION_WPA2: u32 = 4;
pub const IW_AUTH_CIPHER_NONE: u32 = 1;
pub const IW_AUTH_CIPHER_WEP40: u32 = 2;
pub const IW_AUTH_CIPHER_TKIP: u32 = 4;
pub const IW_AUTH_CIPHER_CCMP: u32 = 8;
pub const IW_AUTH_CIPHER_WEP104: u32 = 16;
pub const IW_AUTH_KEY_MGMT_802_1X: u32 = 1;
pub const IW_AUTH_KEY_MGMT_PSK: u32 = 2;
pub const IW_AUTH_ALG_OPEN_SYSTEM: u32 = 1;
pub const IW_AUTH_ALG_SHARED_KEY: u32 = 2;
pub const IW_AUTH_ALG_LEAP: u32 = 4;
pub const IW_AUTH_ALG_SAE: u32 = 8;
pub const IW_AUTH_ROAMING_ENABLE: u32 = 0;
pub const IW_AUTH_ROAMING_DISABLE: u32 = 1;
pub const IW_ENCODE_SEQ_MAX_SIZE: u32 = 8;
pub const IW_ENCODE_ALG_NONE: u32 = 0;
pub const IW_ENCODE_ALG_WEP: u32 = 1;
pub const IW_ENCODE_ALG_TKIP: u32 = 2;
pub const IW_ENCODE_ALG_CCMP: u32 = 3;
pub const IW_ENCODE_ALG_PMK: u32 = 4;
pub const IW_ENCODE_ALG_AES_CMAC: u32 = 5;
pub const IW_ENCODE_EXT_TX_SEQ_VALID: u32 = 1;
pub const IW_ENCODE_EXT_RX_SEQ_VALID: u32 = 2;
pub const IW_ENCODE_EXT_GROUP_KEY: u32 = 4;
pub const IW_ENCODE_EXT_SET_TX_KEY: u32 = 8;
pub const IW_MICFAILURE_KEY_ID: u32 = 3;
pub const IW_MICFAILURE_GROUP: u32 = 4;
pub const IW_MICFAILURE_PAIRWISE: u32 = 8;
pub const IW_MICFAILURE_STAKEY: u32 = 16;
pub const IW_MICFAILURE_COUNT: u32 = 96;
pub const IW_ENC_CAPA_WPA: u32 = 1;
pub const IW_ENC_CAPA_WPA2: u32 = 2;
pub const IW_ENC_CAPA_CIPHER_TKIP: u32 = 4;
pub const IW_ENC_CAPA_CIPHER_CCMP: u32 = 8;
pub const IW_MODUL_ALL: u32 = 0;
pub const IW_MODUL_FH: u32 = 1;
pub const IW_MODUL_DS: u32 = 2;
pub const IW_MODUL_CCK: u32 = 4;
pub const IW_MODUL_11B: u32 = 6;
pub const IW_MODUL_PBCC: u32 = 8;
pub const IW_MODUL_OFDM_A: u32 = 16;
pub const IW_MODUL_11A: u32 = 16;
pub const IW_MODUL_11AB: u32 = 22;
pub const IW_MODUL_OFDM_G: u32 = 32;
pub const IW_MODUL_11G: u32 = 38;
pub const IW_MODUL_11AG: u32 = 54;
pub const IW_MODUL_TURBO: u32 = 64;
pub const IW_MODUL_CUSTOM: u32 = 1073741824;
pub const IW_BITRATE_TYPE: u32 = 255;
pub const IW_BITRATE_UNICAST: u32 = 1;
pub const IW_BITRATE_BROADCAST: u32 = 2;
pub const IW_PMKSA_ADD: u32 = 1;
pub const IW_PMKSA_REMOVE: u32 = 2;
pub const IW_PMKSA_FLUSH: u32 = 3;
pub const IW_PMKID_LEN: u32 = 16;
pub const IW_PMKID_CAND_PREAUTH: u32 = 1;
pub const IW_EV_LCP_PK_LEN: u32 = 4;
pub const IW_EV_CHAR_PK_LEN: u32 = 20;
pub const IW_EXT_STR_FOURWAY_DONE: &'static [u8; 24usize] = b"WPA/WPA2 handshake done\0";
pub const IW_EXT_STR_RECONNECTION_FAIL: &'static [u8; 21usize] = b"RECONNECTION FAILURE\0";
pub const IW_EVT_STR_STA_ASSOC: &'static [u8; 10usize] = b"STA Assoc\0";
pub const IW_EVT_STR_STA_DISASSOC: &'static [u8; 13usize] = b"STA Disassoc\0";
pub const IW_EVT_STR_SEND_ACTION_DONE: &'static [u8; 17usize] = b"Send Action Done\0";
pub const IW_EVT_STR_NO_NETWORK: &'static [u8; 33usize] = b"No Assoc Network After Scan Done\0";
pub const IW_EVT_STR_ICV_ERROR: &'static [u8; 9usize] = b"ICV Eror\0";
pub const IW_EVT_STR_CHALLENGE_FAIL: &'static [u8; 20usize] = b"Auth Challenge Fail\0";
pub const PHYDM_LINUX_CODING_STYLE: u32 = 1;
pub const PHYDM_NEW_INTERFACE: u32 = 1;
pub const CONFIG_INIC_EN: u32 = 0;
pub const RTW_NOTCH_FILTER: u32 = 0;
pub const WLAN_INTF_DBG: u32 = 0;
pub const BAD_MIC_COUNTERMEASURE: u32 = 1;
pub const DEFRAGMENTATION: u32 = 1;
pub const WIFI_LOGO_CERTIFICATION: u32 = 0;
pub const RX_AGGREGATION: u32 = 1;
pub const RX_AMSDU: u32 = 0;
pub const USE_SKB_AS_XMITBUF: u32 = 1;
pub const USE_XMIT_EXTBUFF: u32 = 1;
pub const USE_MUTEX_FOR_SPINLOCK: u32 = 1;
pub const SUPPORT_5G_CHANNEL: u32 = 0;
pub const CONFIG_WIFI_SPEC: u32 = 0;
pub const CONFIG_FAKE_EFUSE: u32 = 0;
pub const CONFIG_AUTO_RECONNECT: u32 = 1;
pub const SUPPORT_SCAN_BUF: u32 = 1;
pub const PSK_SUPPORT_TKIP: u32 = 1;
pub const PROMISC_DENY_PAIRWISE: u32 = 0;
pub const NET_IF_NUM: u32 = 2;
pub const CONFIG_TLS: u32 = 0;
pub const CONFIG_PEAP: u32 = 0;
pub const CONFIG_TTLS: u32 = 0;
pub const AP_STA_NUM: u32 = 5;
pub const USE_DEDICATED_BCN_TX: u32 = 0;
pub const CONFIG_RW_PHYSICAL_EFUSE: u32 = 0;
pub const CONFIG_HIDE_PROTECT_EFUSE: u32 = 1;
pub const CONFIG_ADAPTOR_INFO_CACHING_FLASH: u32 = 1;
pub const CHECK_FLASH_VALID_MASK: u32 = 1;
pub const CHECK_EFUSE_VALID_MASK: u32 = 1;
pub const MP_DRIVER: u32 = 0;
pub const DBG: u32 = 0;
pub const ROM_E_RTW_MSG: u32 = 1;
pub const ROM_F_RTW_MSG: u32 = 1;
pub const DBG_DM_DIG: u32 = 0;
pub const RTL8192E_SUPPORT: u32 = 0;
pub const RTL8812A_SUPPORT: u32 = 0;
pub const RTL8821A_SUPPORT: u32 = 0;
pub const RTL8723B_SUPPORT: u32 = 0;
pub const RTL8195A_SUPPORT: u32 = 0;
pub const RTL8188E_SUPPORT: u32 = 0;
pub const RTL8188F_SUPPORT: u32 = 0;
pub const RTL8711B_SUPPORT: u32 = 0;
pub const RTL8721D_SUPPORT: u32 = 0;
pub const RTL8821C_SUPPORT: u32 = 0;
pub const RTL8723D_SUPPORT: u32 = 0;
pub const RTL8195B_SUPPORT: u32 = 0;
pub const RTL8710C_SUPPORT: u32 = 0;
pub const RATE_ADAPTIVE_SUPPORT: u32 = 0;
pub const RTW_ADAPTIVITY_EN_DISABLE: u32 = 0;
pub const RTW_ADAPTIVITY_EN_ENABLE: u32 = 1;
pub const CONFIG_RTW_ADAPTIVITY_EN: u32 = 0;
pub const RTW_ADAPTIVITY_MODE_NORMAL: u32 = 0;
pub const RTW_ADAPTIVITY_MODE_CARRIER_SENSE: u32 = 1;
pub const CONFIG_RTW_ADAPTIVITY_MODE: u32 = 1;
pub const CONFIG_RTW_ADAPTIVITY_DML: u32 = 0;
pub const CONFIG_POWER_TRAINING_WIL: u32 = 0;
pub const RTL8195A_FOR_TEST_CHIP: u32 = 0;
pub const SKB_PRE_ALLOCATE_RX: u32 = 0;
pub const HAL_MAC_ENABLE: u32 = 1;
pub const HAL_BB_ENABLE: u32 = 1;
pub const HAL_RF_ENABLE: u32 = 1;
pub const DISABLE_BB_RF: u32 = 0;
pub const CONFIG_MAC_ADDRESS: u32 = 0;
pub const WLAN_WRAPPER_VERSION: u32 = 1;
pub const TIME_THRES: u32 = 20;
pub const WLAN0_IDX: u32 = 0;
pub const WLAN1_IDX: u32 = 1;
pub const WLAN_UNDEF: i32 = -1;
pub const SCAN_LONGEST_WAIT_TIME: u32 = 4500;
pub const MAC_FMT: &'static [u8; 30usize] = b"%02x:%02x:%02x:%02x:%02x:%02x\0";
pub const PSCAN_ENABLE: u32 = 1;
pub const PSCAN_FAST_SURVEY: u32 = 2;
pub const PSCAN_SIMPLE_CONFIG: u32 = 4;
pub const WIFI_LOGO_CERTIFICATION_CONFIG: u32 = 0;
pub const SYS_LIGHTWEIGHT_PROT: u32 = 1;
pub const LWIP_COMPAT_MUTEX: u32 = 1;
pub const ETHARP_TRUST_IP_MAC: u32 = 0;
pub const IP_REASSEMBLY: u32 = 1;
pub const IP_FRAG: u32 = 1;
pub const ARP_QUEUEING: u32 = 0;
pub const NO_SYS: u32 = 0;
pub const MEM_ALIGNMENT: u32 = 4;
pub const MEM_SIZE: u32 = 7168;
pub const MEMP_NUM_PBUF: u32 = 100;
pub const MEMP_NUM_UDP_PCB: u32 = 6;
pub const MEMP_NUM_TCP_PCB: u32 = 10;
pub const MEMP_NUM_TCP_PCB_LISTEN: u32 = 5;
pub const MEMP_NUM_TCP_SEG: u32 = 20;
pub const MEMP_NUM_SYS_TIMEOUT: u32 = 10;
pub const MEMP_NUM_NETCONN: u32 = 8;
pub const PBUF_POOL_SIZE: u32 = 20;
pub const IP_REASS_MAX_PBUFS: u32 = 10;
pub const PBUF_POOL_BUFSIZE: u32 = 508;
pub const LWIP_TCP: u32 = 1;
pub const TCP_TTL: u32 = 255;
pub const TCP_QUEUE_OOSEQ: u32 = 1;
pub const TCP_MSS: u32 = 1460;
pub const TCP_SND_BUF: u32 = 7300;
pub const TCP_SND_QUEUELEN: u32 = 20;
pub const TCP_WND: u32 = 7300;
pub const LWIP_ICMP: u32 = 1;
pub const LWIP_ARP: u32 = 1;
pub const LWIP_DHCP: u32 = 1;
pub const LWIP_UDP: u32 = 1;
pub const UDP_TTL: u32 = 255;
pub const LWIP_DNS: u32 = 1;
pub const LWIP_UPNP: u32 = 0;
pub const LWIP_SO_SNDRCVTIMEO_NONSTANDARD: u32 = 1;
pub const SO_REUSE: u32 = 1;
pub const LWIP_IGMP: u32 = 1;
pub const LWIP_MTU_ADJUST: u32 = 1;
pub const LWIP_TCP_KEEPALIVE: u32 = 1;
pub const LWIP_UART_ADAPTER: u32 = 0;
pub const LWIP_STATS: u32 = 0;
pub const LWIP_PROVIDE_ERRNO: u32 = 1;
pub const CHECKSUM_GEN_IP: u32 = 1;
pub const CHECKSUM_GEN_UDP: u32 = 1;
pub const CHECKSUM_GEN_TCP: u32 = 1;
pub const CHECKSUM_CHECK_IP: u32 = 1;
pub const CHECKSUM_CHECK_UDP: u32 = 1;
pub const CHECKSUM_CHECK_TCP: u32 = 1;
pub const LWIP_NETCONN: u32 = 1;
pub const LWIP_SOCKET: u32 = 1;
pub const LWIP_DEBUG: u32 = 0;
pub const TCPIP_THREAD_STACKSIZE: u32 = 1000;
pub const TCPIP_MBOX_SIZE: u32 = 6;
pub const DEFAULT_UDP_RECVMBOX_SIZE: u32 = 6;
pub const DEFAULT_TCP_RECVMBOX_SIZE: u32 = 6;
pub const DEFAULT_RAW_RECVMBOX_SIZE: u32 = 6;
pub const DEFAULT_ACCEPTMBOX_SIZE: u32 = 6;
pub const DEFAULT_THREAD_STACKSIZE: u32 = 500;
pub const TCPIP_THREAD_PRIO: u32 = 9;
pub const ETHARP_SUPPORT_STATIC_ENTRIES: u32 = 1;
pub const LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS: u32 = 1;
pub const LWIP_DNS_LEGACY_SUPPORT: u32 = 0;
pub const LWIP_ICMP_SUPPRESS: u32 = 0;
pub const LWIP_ICMP_SUPPRESS_INTERVAL: u32 = 900;
pub const LWIP_TCPIP_CORE_LOCKING: u32 = 0;
pub const LWIP_TCPIP_TIMEOUT: u32 = 1;
pub const LWIP_SO_RCVTIMEO: u32 = 1;
pub const LWIP_SOCKET_SET_ERRNO: u32 = 0;
pub const LWIP_RAW: u32 = 1;
pub const LWIP_AUTOIP: u32 = 1;
pub const TCPIP_THREAD_NAME: &'static [u8; 7usize] = b"TCP_IP\0";
pub const LWIP_IPV6: u32 = 0;
pub const LWIP_VERSION_MAJOR: u32 = 2;
pub const LWIP_VERSION_MINOR: u32 = 0;
pub const LWIP_VERSION_REVISION: u32 = 3;
pub const LWIP_RC_RELEASE: u32 = 255;
pub const LWIP_RC_DEVELOPMENT: u32 = 0;
pub const LWIP_VERSION_STRING_SUFFIX: &'static [u8; 1usize] = b"\0";
pub const U16_F: &'static [u8; 2usize] = b"d\0";
pub const S16_F: &'static [u8; 2usize] = b"d\0";
pub const X16_F: &'static [u8; 2usize] = b"x\0";
pub const U32_F: &'static [u8; 2usize] = b"d\0";
pub const S32_F: &'static [u8; 2usize] = b"d\0";
pub const X32_F: &'static [u8; 2usize] = b"x\0";
pub const SZT_F: &'static [u8; 3usize] = b"uz\0";
pub const LWIP_NO_STDINT_H: u32 = 1;
pub const LWIP_NO_STDDEF_H: u32 = 0;
pub const LWIP_NO_INTTYPES_H: u32 = 0;
pub const X8_F: &'static [u8; 3usize] = b"02\0";
pub const LWIP_NO_LIMITS_H: u32 = 0;
pub const LWIP_DBG_LEVEL_ALL: u32 = 0;
pub const LWIP_DBG_LEVEL_WARNING: u32 = 1;
pub const LWIP_DBG_LEVEL_SERIOUS: u32 = 2;
pub const LWIP_DBG_LEVEL_SEVERE: u32 = 3;
pub const LWIP_DBG_MASK_LEVEL: u32 = 3;
pub const LWIP_DBG_LEVEL_OFF: u32 = 0;
pub const LWIP_DBG_ON: u32 = 128;
pub const LWIP_DBG_OFF: u32 = 0;
pub const LWIP_DBG_TRACE: u32 = 64;
pub const LWIP_DBG_STATE: u32 = 32;
pub const LWIP_DBG_FRESH: u32 = 16;
pub const LWIP_DBG_HALT: u32 = 8;
pub const LWIP_TIMERS: u32 = 1;
pub const LWIP_TIMERS_CUSTOM: u32 = 0;
pub const LWIP_MPU_COMPATIBLE: u32 = 0;
pub const LWIP_TCPIP_CORE_LOCKING_INPUT: u32 = 0;
pub const MEM_LIBC_MALLOC: u32 = 0;
pub const MEMP_MEM_MALLOC: u32 = 0;
pub const MEMP_OVERFLOW_CHECK: u32 = 0;
pub const MEMP_SANITY_CHECK: u32 = 0;
pub const MEM_USE_POOLS: u32 = 0;
pub const MEM_USE_POOLS_TRY_BIGGER_POOL: u32 = 0;
pub const MEMP_USE_CUSTOM_POOLS: u32 = 0;
pub const LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT: u32 = 0;
pub const MEMP_NUM_RAW_PCB: u32 = 4;
pub const MEMP_NUM_REASSDATA: u32 = 5;
pub const MEMP_NUM_FRAG_PBUF: u32 = 15;
pub const MEMP_NUM_ARP_QUEUE: u32 = 30;
pub const MEMP_NUM_IGMP_GROUP: u32 = 8;
pub const MEMP_NUM_NETBUF: u32 = 2;
pub const MEMP_NUM_TCPIP_MSG_API: u32 = 8;
pub const MEMP_NUM_TCPIP_MSG_INPKT: u32 = 8;
pub const MEMP_NUM_NETDB: u32 = 1;
pub const MEMP_NUM_LOCALHOSTLIST: u32 = 1;
pub const MEMP_NUM_API_MSG: u32 = 8;
pub const MEMP_NUM_DNS_API_MSG: u32 = 8;
pub const MEMP_NUM_SOCKET_SETGETSOCKOPT_DATA: u32 = 8;
pub const MEMP_NUM_NETIFAPI_MSG: u32 = 8;
pub const ARP_TABLE_SIZE: u32 = 10;
pub const ARP_MAXAGE: u32 = 300;
pub const ARP_QUEUE_LEN: u32 = 3;
pub const ETHARP_SUPPORT_VLAN: u32 = 0;
pub const LWIP_ETHERNET: u32 = 1;
pub const ETH_PAD_SIZE: u32 = 0;
pub const ETHARP_TABLE_MATCH_NETIF: u32 = 0;
pub const LWIP_IPV4: u32 = 1;
pub const IP_FORWARD: u32 = 0;
pub const IP_OPTIONS_ALLOWED: u32 = 1;
pub const IP_REASS_MAXAGE: u32 = 3;
pub const IP_DEFAULT_TTL: u32 = 255;
pub const IP_SOF_BROADCAST: u32 = 0;
pub const IP_SOF_BROADCAST_RECV: u32 = 0;
pub const IP_FORWARD_ALLOW_TX_ON_RX_NETIF: u32 = 0;
pub const ICMP_TTL: u32 = 255;
pub const LWIP_BROADCAST_PING: u32 = 0;
pub const LWIP_MULTICAST_PING: u32 = 0;
pub const RAW_TTL: u32 = 255;
pub const LWIP_DHCP_CHECK_LINK_UP: u32 = 0;
pub const LWIP_DHCP_BOOTP_FILE: u32 = 0;
pub const LWIP_DHCP_GET_NTP_SRV: u32 = 0;
pub const LWIP_DHCP_MAX_NTP_SERVERS: u32 = 1;
pub const LWIP_DHCP_AUTOIP_COOP: u32 = 0;
pub const LWIP_DHCP_AUTOIP_COOP_TRIES: u32 = 9;
pub const LWIP_MIB2_CALLBACKS: u32 = 0;
pub const DNS_TABLE_SIZE: u32 = 4;
pub const DNS_MAX_NAME_LENGTH: u32 = 256;
pub const DNS_MAX_SERVERS: u32 = 2;
pub const DNS_DOES_NAME_CHECK: u32 = 1;
pub const LWIP_DNS_SECURE_RAND_XID: u32 = 1;
pub const LWIP_DNS_SECURE_NO_MULTIPLE_OUTSTANDING: u32 = 2;
pub const LWIP_DNS_SECURE_RAND_SRC_PORT: u32 = 4;
pub const DNS_LOCAL_HOSTLIST: u32 = 0;
pub const DNS_LOCAL_HOSTLIST_IS_DYNAMIC: u32 = 0;
pub const LWIP_DNS_SUPPORT_MDNS_QUERIES: u32 = 0;
pub const LWIP_UDPLITE: u32 = 0;
pub const LWIP_NETBUF_RECVINFO: u32 = 0;
pub const TCP_MAXRTX: u32 = 12;
pub const TCP_SYNMAXRTX: u32 = 6;
pub const TCP_CALCULATE_EFF_SEND_MSS: u32 = 1;
pub const TCP_OOSEQ_MAX_BYTES: u32 = 0;
pub const TCP_OOSEQ_MAX_PBUFS: u32 = 0;
pub const TCP_LISTEN_BACKLOG: u32 = 0;
pub const TCP_DEFAULT_LISTEN_BACKLOG: u32 = 255;
pub const TCP_OVERSIZE: u32 = 1460;
pub const LWIP_TCP_TIMESTAMPS: u32 = 0;
pub const LWIP_EVENT_API: u32 = 0;
pub const LWIP_CALLBACK_API: u32 = 1;
pub const LWIP_WND_SCALE: u32 = 0;
pub const TCP_RCV_SCALE: u32 = 0;
pub const PBUF_LINK_HLEN: u32 = 14;
pub const PBUF_LINK_ENCAPSULATION_HLEN: u32 = 0;
pub const LWIP_NETIF_HOSTNAME: u32 = 0;
pub const LWIP_NETIF_API: u32 = 0;
pub const LWIP_NETIF_STATUS_CALLBACK: u32 = 0;
pub const LWIP_NETIF_LINK_CALLBACK: u32 = 0;
pub const LWIP_NETIF_REMOVE_CALLBACK: u32 = 0;
pub const LWIP_NETIF_HWADDRHINT: u32 = 0;
pub const LWIP_NETIF_TX_SINGLE_PBUF: u32 = 0;
pub const LWIP_NUM_NETIF_CLIENT_DATA: u32 = 0;
pub const LWIP_LOOPIF_MULTICAST: u32 = 0;
pub const LWIP_NETIF_LOOPBACK: u32 = 0;
pub const LWIP_LOOPBACK_MAX_PBUFS: u32 = 0;
pub const SLIPIF_THREAD_NAME: &'static [u8; 12usize] = b"slipif_loop\0";
pub const SLIPIF_THREAD_STACKSIZE: u32 = 0;
pub const SLIPIF_THREAD_PRIO: u32 = 1;
pub const DEFAULT_THREAD_NAME: &'static [u8; 5usize] = b"lwIP\0";
pub const DEFAULT_THREAD_PRIO: u32 = 1;
pub const LWIP_NETCONN_SEM_PER_THREAD: u32 = 0;
pub const LWIP_NETCONN_FULLDUPLEX: u32 = 0;
pub const LWIP_COMPAT_SOCKETS: u32 = 1;
pub const LWIP_POSIX_SOCKETS_IO_NAMES: u32 = 1;
pub const LWIP_SOCKET_OFFSET: u32 = 0;
pub const LWIP_SO_SNDTIMEO: u32 = 0;
pub const LWIP_SO_RCVBUF: u32 = 0;
pub const LWIP_SO_LINGER: u32 = 0;
pub const LWIP_TCP_CLOSE_TIMEOUT_MS_DEFAULT: u32 = 20000;
pub const SO_REUSE_RXTOALL: u32 = 0;
pub const LWIP_FIONREAD_LINUXMODE: u32 = 0;
pub const LINK_STATS: u32 = 0;
pub const ETHARP_STATS: u32 = 0;
pub const IP_STATS: u32 = 0;
pub const IPFRAG_STATS: u32 = 0;
pub const ICMP_STATS: u32 = 0;
pub const IGMP_STATS: u32 = 0;
pub const UDP_STATS: u32 = 0;
pub const TCP_STATS: u32 = 0;
pub const MEM_STATS: u32 = 0;
pub const MEMP_STATS: u32 = 0;
pub const SYS_STATS: u32 = 0;
pub const LWIP_STATS_DISPLAY: u32 = 0;
pub const IP6_STATS: u32 = 0;
pub const ICMP6_STATS: u32 = 0;
pub const IP6_FRAG_STATS: u32 = 0;
pub const MLD6_STATS: u32 = 0;
pub const ND6_STATS: u32 = 0;
pub const MIB2_STATS: u32 = 0;
pub const LWIP_CHECKSUM_CTRL_PER_NETIF: u32 = 0;
pub const CHECKSUM_GEN_ICMP: u32 = 1;
pub const CHECKSUM_GEN_ICMP6: u32 = 1;
pub const CHECKSUM_CHECK_ICMP: u32 = 1;
pub const CHECKSUM_CHECK_ICMP6: u32 = 1;
pub const LWIP_CHECKSUM_ON_COPY: u32 = 0;
pub const LWIP_IPV6_NUM_ADDRESSES: u32 = 3;
pub const LWIP_IPV6_FORWARD: u32 = 0;
pub const LWIP_IPV6_FRAG: u32 = 0;
pub const LWIP_IPV6_REASS: u32 = 0;
pub const LWIP_IPV6_SEND_ROUTER_SOLICIT: u32 = 1;
pub const LWIP_IPV6_AUTOCONFIG: u32 = 0;
pub const LWIP_IPV6_DUP_DETECT_ATTEMPTS: u32 = 1;
pub const LWIP_ICMP6: u32 = 0;
pub const LWIP_ICMP6_DATASIZE: u32 = 8;
pub const LWIP_ICMP6_HL: u32 = 255;
pub const LWIP_IPV6_MLD: u32 = 0;
pub const MEMP_NUM_MLD6_GROUP: u32 = 4;
pub const LWIP_ND6_QUEUEING: u32 = 0;
pub const MEMP_NUM_ND6_QUEUE: u32 = 20;
pub const LWIP_ND6_NUM_NEIGHBORS: u32 = 10;
pub const LWIP_ND6_NUM_DESTINATIONS: u32 = 10;
pub const LWIP_ND6_NUM_PREFIXES: u32 = 5;
pub const LWIP_ND6_NUM_ROUTERS: u32 = 3;
pub const LWIP_ND6_MAX_MULTICAST_SOLICIT: u32 = 3;
pub const LWIP_ND6_MAX_UNICAST_SOLICIT: u32 = 3;
pub const LWIP_ND6_MAX_ANYCAST_DELAY_TIME: u32 = 1000;
pub const LWIP_ND6_MAX_NEIGHBOR_ADVERTISEMENT: u32 = 3;
pub const LWIP_ND6_REACHABLE_TIME: u32 = 30000;
pub const LWIP_ND6_RETRANS_TIMER: u32 = 1000;
pub const LWIP_ND6_DELAY_FIRST_PROBE_TIME: u32 = 5000;
pub const LWIP_ND6_ALLOW_RA_UPDATES: u32 = 1;
pub const LWIP_ND6_TCP_REACHABILITY_HINTS: u32 = 1;
pub const LWIP_ND6_RDNSS_MAX_DNS_SERVERS: u32 = 0;
pub const LWIP_IPV6_DHCP6: u32 = 0;
pub const LWIP_DBG_MIN_LEVEL: u32 = 0;
pub const LWIP_DBG_TYPES_ON: u32 = 128;
pub const ETHARP_DEBUG: u32 = 0;
pub const NETIF_DEBUG: u32 = 0;
pub const PBUF_DEBUG: u32 = 0;
pub const API_LIB_DEBUG: u32 = 0;
pub const API_MSG_DEBUG: u32 = 0;
pub const SOCKETS_DEBUG: u32 = 0;
pub const ICMP_DEBUG: u32 = 0;
pub const IGMP_DEBUG: u32 = 0;
pub const INET_DEBUG: u32 = 0;
pub const IP_DEBUG: u32 = 0;
pub const IP_REASS_DEBUG: u32 = 0;
pub const RAW_DEBUG: u32 = 0;
pub const MEM_DEBUG: u32 = 0;
pub const MEMP_DEBUG: u32 = 0;
pub const SYS_DEBUG: u32 = 0;
pub const TIMERS_DEBUG: u32 = 0;
pub const TCP_DEBUG: u32 = 0;
pub const TCP_INPUT_DEBUG: u32 = 0;
pub const TCP_FR_DEBUG: u32 = 0;
pub const TCP_RTO_DEBUG: u32 = 0;
pub const TCP_CWND_DEBUG: u32 = 0;
pub const TCP_WND_DEBUG: u32 = 0;
pub const TCP_OUTPUT_DEBUG: u32 = 0;
pub const TCP_RST_DEBUG: u32 = 0;
pub const TCP_QLEN_DEBUG: u32 = 0;
pub const UDP_DEBUG: u32 = 0;
pub const TCPIP_DEBUG: u32 = 0;
pub const SLIP_DEBUG: u32 = 0;
pub const DHCP_DEBUG: u32 = 0;
pub const AUTOIP_DEBUG: u32 = 0;
pub const DNS_DEBUG: u32 = 0;
pub const IP6_DEBUG: u32 = 0;
pub const LWIP_PERF: u32 = 0;
pub const SYS_ARCH_TIMEOUT: u32 = 4294967295;
pub const SYS_MBOX_EMPTY: u32 = 4294967295;
pub const archMESG_QUEUE_LENGTH: u32 = 6;
pub const LWIP_DEBUG_TIMERNAMES: u32 = 0;
pub const IP_CLASSA_NET: u32 = 4278190080;
pub const IP_CLASSA_NSHIFT: u32 = 24;
pub const IP_CLASSA_HOST: u32 = 16777215;
pub const IP_CLASSA_MAX: u32 = 128;
pub const IP_CLASSB_NET: u32 = 4294901760;
pub const IP_CLASSB_NSHIFT: u32 = 16;
pub const IP_CLASSB_HOST: u32 = 65535;
pub const IP_CLASSB_MAX: u32 = 65536;
pub const IP_CLASSC_NET: u32 = 4294967040;
pub const IP_CLASSC_NSHIFT: u32 = 8;
pub const IP_CLASSC_HOST: u32 = 255;
pub const IP_CLASSD_NET: u32 = 4026531840;
pub const IP_CLASSD_NSHIFT: u32 = 28;
pub const IP_CLASSD_HOST: u32 = 268435455;
pub const IP_LOOPBACKNET: u32 = 127;
pub const IP4ADDR_STRLEN_MAX: u32 = 16;
pub const IPADDR_STRLEN_MAX: u32 = 16;
pub const PBUF_TRANSPORT_HLEN: u32 = 20;
pub const PBUF_IP_HLEN: u32 = 20;
pub const PBUF_FLAG_PUSH: u32 = 1;
pub const PBUF_FLAG_IS_CUSTOM: u32 = 2;
pub const PBUF_FLAG_MCASTLOOP: u32 = 4;
pub const PBUF_FLAG_LLBCAST: u32 = 8;
pub const PBUF_FLAG_LLMCAST: u32 = 16;
pub const PBUF_FLAG_TCP_FIN: u32 = 32;
pub const PBUF_POOL_FREE_OOSEQ: u32 = 1;
pub const MEM_SIZE_F: &'static [u8; 2usize] = b"d\0";
pub const MEMP_SIZE: u32 = 0;
pub const NETIF_MAX_HWADDR_LEN: u32 = 6;
pub const NETIF_FLAG_UP: u32 = 1;
pub const NETIF_FLAG_BROADCAST: u32 = 2;
pub const NETIF_FLAG_LINK_UP: u32 = 4;
pub const NETIF_FLAG_ETHARP: u32 = 8;
pub const NETIF_FLAG_ETHERNET: u32 = 16;
pub const NETIF_FLAG_IGMP: u32 = 32;
pub const NETIF_FLAG_MLD6: u32 = 64;
pub const IN_CLASSA_NET: u32 = 4278190080;
pub const IN_CLASSA_NSHIFT: u32 = 24;
pub const IN_CLASSA_HOST: u32 = 16777215;
pub const IN_CLASSA_MAX: u32 = 128;
pub const IN_CLASSB_NET: u32 = 4294901760;
pub const IN_CLASSB_NSHIFT: u32 = 16;
pub const IN_CLASSB_HOST: u32 = 65535;
pub const IN_CLASSB_MAX: u32 = 65536;
pub const IN_CLASSC_NET: u32 = 4294967040;
pub const IN_CLASSC_NSHIFT: u32 = 8;
pub const IN_CLASSC_HOST: u32 = 255;
pub const IN_CLASSD_NET: u32 = 4026531840;
pub const IN_CLASSD_NSHIFT: u32 = 28;
pub const IN_CLASSD_HOST: u32 = 268435455;
pub const IN_LOOPBACKNET: u32 = 127;
pub const INET_ADDRSTRLEN: u32 = 16;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ENOTSUP: u32 = 134;
pub const ECANCELED: u32 = 140;
pub const ENOTRECOVERABLE: u32 = 141;
pub const EOWNERDEAD: u32 = 142;
pub const SIN_ZERO_LEN: u32 = 8;
pub const LWIP_SETGETSOCKOPT_MAXOPTLEN: u32 = 16;
pub const SOCK_STREAM: u32 = 1;
pub const SOCK_DGRAM: u32 = 2;
pub const SOCK_RAW: u32 = 3;
pub const SO_REUSEADDR: u32 = 4;
pub const SO_KEEPALIVE: u32 = 8;
pub const SO_BROADCAST: u32 = 32;
pub const SO_DEBUG: u32 = 1;
pub const SO_ACCEPTCONN: u32 = 2;
pub const SO_DONTROUTE: u32 = 16;
pub const SO_USELOOPBACK: u32 = 64;
pub const SO_LINGER: u32 = 128;
pub const SO_OOBINLINE: u32 = 256;
pub const SO_REUSEPORT: u32 = 512;
pub const SO_SNDBUF: u32 = 4097;
pub const SO_RCVBUF: u32 = 4098;
pub const SO_SNDLOWAT: u32 = 4099;
pub const SO_RCVLOWAT: u32 = 4100;
pub const SO_SNDTIMEO: u32 = 4101;
pub const SO_RCVTIMEO: u32 = 4102;
pub const SO_ERROR: u32 = 4103;
pub const SO_TYPE: u32 = 4104;
pub const SO_CONTIMEO: u32 = 4105;
pub const SO_NO_CHECK: u32 = 4106;
pub const SOL_SOCKET: u32 = 4095;
pub const AF_UNSPEC: u32 = 0;
pub const AF_INET: u32 = 2;
pub const AF_INET6: u32 = 0;
pub const PF_INET: u32 = 2;
pub const PF_INET6: u32 = 0;
pub const PF_UNSPEC: u32 = 0;
pub const IPPROTO_IP: u32 = 0;
pub const IPPROTO_ICMP: u32 = 1;
pub const IPPROTO_TCP: u32 = 6;
pub const IPPROTO_UDP: u32 = 17;
pub const IPPROTO_UDPLITE: u32 = 136;
pub const IPPROTO_RAW: u32 = 255;
pub const MSG_PEEK: u32 = 1;
pub const MSG_WAITALL: u32 = 2;
pub const MSG_OOB: u32 = 4;
pub const MSG_DONTWAIT: u32 = 8;
pub const MSG_MORE: u32 = 16;
pub const IP_TOS: u32 = 1;
pub const IP_TTL: u32 = 2;
pub const TCP_NODELAY: u32 = 1;
pub const TCP_KEEPALIVE: u32 = 2;
pub const TCP_KEEPIDLE: u32 = 3;
pub const TCP_KEEPINTVL: u32 = 4;
pub const TCP_KEEPCNT: u32 = 5;
pub const IP_MULTICAST_TTL: u32 = 5;
pub const IP_MULTICAST_IF: u32 = 6;
pub const IP_MULTICAST_LOOP: u32 = 7;
pub const IP_ADD_MEMBERSHIP: u32 = 3;
pub const IP_DROP_MEMBERSHIP: u32 = 4;
pub const IPTOS_TOS_MASK: u32 = 30;
pub const IPTOS_LOWDELAY: u32 = 16;
pub const IPTOS_THROUGHPUT: u32 = 8;
pub const IPTOS_RELIABILITY: u32 = 4;
pub const IPTOS_LOWCOST: u32 = 2;
pub const IPTOS_MINCOST: u32 = 2;
pub const IPTOS_PREC_MASK: u32 = 224;
pub const IPTOS_PREC_NETCONTROL: u32 = 224;
pub const IPTOS_PREC_INTERNETCONTROL: u32 = 192;
pub const IPTOS_PREC_CRITIC_ECP: u32 = 160;
pub const IPTOS_PREC_FLASHOVERRIDE: u32 = 128;
pub const IPTOS_PREC_FLASH: u32 = 96;
pub const IPTOS_PREC_IMMEDIATE: u32 = 64;
pub const IPTOS_PREC_PRIORITY: u32 = 32;
pub const IPTOS_PREC_ROUTINE: u32 = 0;
pub const IOCPARM_MASK: u32 = 127;
pub const IOC_VOID: u32 = 536870912;
pub const IOC_OUT: u32 = 1073741824;
pub const IOC_IN: u32 = 2147483648;
pub const IOC_INOUT: u32 = 3221225472;
pub const F_GETFL: u32 = 3;
pub const F_SETFL: u32 = 4;
pub const O_NONBLOCK: u32 = 1;
pub const O_NDELAY: u32 = 1;
pub const SHUT_RD: u32 = 0;
pub const SHUT_WR: u32 = 1;
pub const SHUT_RDWR: u32 = 2;
pub const LWIP_TIMEVAL_PRIVATE: u32 = 1;
extern "C" {
    pub fn __builtin_arm_cmse_nonsecure_caller() -> ffi::ctypes::c_int;
}
pub type size_t = ffi::ctypes::c_ulong;
pub type wchar_t = ffi::ctypes::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct max_align_t {
    pub __max_align_ll: ffi::ctypes::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __max_align_ld: u128,
}
pub type __int8_t = ffi::ctypes::c_schar;
pub type __uint8_t = ffi::ctypes::c_uchar;
pub type __int16_t = ffi::ctypes::c_short;
pub type __uint16_t = ffi::ctypes::c_ushort;
pub type __int32_t = ffi::ctypes::c_int;
pub type __uint32_t = ffi::ctypes::c_uint;
pub type __int64_t = ffi::ctypes::c_long;
pub type __uint64_t = ffi::ctypes::c_ulong;
pub type __int_least8_t = ffi::ctypes::c_schar;
pub type __uint_least8_t = ffi::ctypes::c_uchar;
pub type __int_least16_t = ffi::ctypes::c_short;
pub type __uint_least16_t = ffi::ctypes::c_ushort;
pub type __int_least32_t = ffi::ctypes::c_int;
pub type __uint_least32_t = ffi::ctypes::c_uint;
pub type __int_least64_t = ffi::ctypes::c_long;
pub type __uint_least64_t = ffi::ctypes::c_ulong;
pub type __intmax_t = ffi::ctypes::c_long;
pub type __uintmax_t = ffi::ctypes::c_ulong;
pub type __intptr_t = ffi::ctypes::c_long;
pub type __uintptr_t = ffi::ctypes::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ffi::ctypes::c_schar;
pub type uint_fast8_t = ffi::ctypes::c_uchar;
pub type int_fast16_t = ffi::ctypes::c_short;
pub type uint_fast16_t = ffi::ctypes::c_ushort;
pub type int_fast32_t = ffi::ctypes::c_int;
pub type uint_fast32_t = ffi::ctypes::c_uint;
pub type int_fast64_t = ffi::ctypes::c_long;
pub type uint_fast64_t = ffi::ctypes::c_ulong;
extern "C" {
    pub static mut SystemCoreClock: u32;
}
extern "C" {
    pub fn freertos_pre_sleep_processing(expected_idle_time: *mut ffi::ctypes::c_uint);
}
extern "C" {
    pub fn freertos_post_sleep_processing(expected_idle_time: *mut ffi::ctypes::c_uint);
}
extern "C" {
    pub fn freertos_ready_to_sleep() -> ffi::ctypes::c_int;
}
pub type TaskFunction_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ffi::ctypes::c_void)>;
pub type StackType_t = u32;
pub type BaseType_t = ffi::ctypes::c_long;
pub type UBaseType_t = ffi::ctypes::c_ulong;
pub type TickType_t = u32;
extern "C" {
    pub fn vPortYield();
}
extern "C" {
    pub fn vPortEnterCritical();
}
extern "C" {
    pub fn vPortExitCritical();
}
extern "C" {
    pub fn ulSetInterruptMaskFromISR() -> u32;
}
extern "C" {
    pub fn vClearInterruptMaskFromISR(ulMask: u32);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MPURegionSettings {
    pub ulRBAR: u32,
    pub ulRLAR: u32,
}
pub type MPURegionSettings_t = MPURegionSettings;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MPU_SETTINGS {
    pub ulMAIR0: u32,
    pub xRegionsSettings: [MPURegionSettings_t; 4usize],
}
pub type xMPU_SETTINGS = MPU_SETTINGS;
extern "C" {
    pub fn pxPortInitialiseStack(
        pxTopOfStack: *mut StackType_t,
        pxEndOfStack: *mut StackType_t,
        pxCode: TaskFunction_t,
        pvParameters: *mut ffi::ctypes::c_void,
    ) -> *mut StackType_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HeapRegion {
    pub pucStartAddress: *mut u8,
    pub xSizeInBytes: size_t,
}
impl Default for HeapRegion {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type HeapRegion_t = HeapRegion;
extern "C" {
    pub fn vPortDefineHeapRegions(pxHeapRegions: *const HeapRegion_t);
}
extern "C" {
    pub fn pvPortMalloc(xSize: size_t) -> *mut ffi::ctypes::c_void;
}
extern "C" {
    pub fn vPortFree(pv: *mut ffi::ctypes::c_void);
}
extern "C" {
    pub fn vPortInitialiseBlocks();
}
extern "C" {
    pub fn xPortGetFreeHeapSize() -> size_t;
}
extern "C" {
    pub fn xPortGetMinimumEverFreeHeapSize() -> size_t;
}
extern "C" {
    pub fn xPortStartScheduler() -> BaseType_t;
}
extern "C" {
    pub fn vPortEndScheduler();
}
extern "C" {
    pub fn vPortSecCall(
        pvFunc: *mut ffi::ctypes::c_void,
        ulArg0: u32,
        ulArg1: u32,
        ulArg2: u32,
    ) -> ffi::ctypes::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_LIST_ITEM {
    pub xDummy2: TickType_t,
    pub pvDummy3: [*mut ffi::ctypes::c_void; 4usize],
}
impl Default for xSTATIC_LIST_ITEM {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type StaticListItem_t = xSTATIC_LIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_MINI_LIST_ITEM {
    pub xDummy2: TickType_t,
    pub pvDummy3: [*mut ffi::ctypes::c_void; 2usize],
}
impl Default for xSTATIC_MINI_LIST_ITEM {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type StaticMiniListItem_t = xSTATIC_MINI_LIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_LIST {
    pub uxDummy2: UBaseType_t,
    pub pvDummy3: *mut ffi::ctypes::c_void,
    pub xDummy4: StaticMiniListItem_t,
}
impl Default for xSTATIC_LIST {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type StaticList_t = xSTATIC_LIST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_TCB {
    pub pxDummy1: *mut ffi::ctypes::c_void,
    pub xDummy3: [StaticListItem_t; 2usize],
    pub uxDummy5: UBaseType_t,
    pub pxDummy6: *mut ffi::ctypes::c_void,
    pub ucDummy7: [u8; 10usize],
    pub pxDummy8: *mut ffi::ctypes::c_void,
    pub uxDummy10: [UBaseType_t; 2usize],
    pub uxDummy12: [UBaseType_t; 2usize],
    pub ulDummy18: u32,
    pub ucDummy19: u8,
}
impl Default for xSTATIC_TCB {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type StaticTask_t = xSTATIC_TCB;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xSTATIC_QUEUE {
    pub pvDummy1: [*mut ffi::ctypes::c_void; 3usize],
    pub u: xSTATIC_QUEUE__bindgen_ty_1,
    pub xDummy3: [StaticList_t; 2usize],
    pub uxDummy4: [UBaseType_t; 3usize],
    pub ucDummy5: [u8; 2usize],
    pub pvDummy7: *mut ffi::ctypes::c_void,
    pub uxDummy8: UBaseType_t,
    pub ucDummy9: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xSTATIC_QUEUE__bindgen_ty_1 {
    pub pvDummy2: *mut ffi::ctypes::c_void,
    pub uxDummy2: UBaseType_t,
    _bindgen_union_align: u64,
}
impl Default for xSTATIC_QUEUE__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for xSTATIC_QUEUE__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "xSTATIC_QUEUE__bindgen_ty_1 {{ union }}")
    }
}
impl Default for xSTATIC_QUEUE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for xSTATIC_QUEUE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "xSTATIC_QUEUE {{ pvDummy1: {:?}, u: {:?}, xDummy3: {:?}, uxDummy4: {:?}, ucDummy5: {:?}, pvDummy7: {:?}, uxDummy8: {:?}, ucDummy9: {:?} }}" , self . pvDummy1 , self . u , self . xDummy3 , self . uxDummy4 , self . ucDummy5 , self . pvDummy7 , self . uxDummy8 , self . ucDummy9)
    }
}
pub type StaticQueue_t = xSTATIC_QUEUE;
pub type StaticSemaphore_t = StaticQueue_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_EVENT_GROUP {
    pub xDummy1: TickType_t,
    pub xDummy2: StaticList_t,
    pub uxDummy3: UBaseType_t,
}
impl Default for xSTATIC_EVENT_GROUP {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type StaticEventGroup_t = xSTATIC_EVENT_GROUP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_TIMER {
    pub pvDummy1: *mut ffi::ctypes::c_void,
    pub xDummy2: StaticListItem_t,
    pub xDummy3: TickType_t,
    pub pvDummy5: *mut ffi::ctypes::c_void,
    pub pvDummy6: TaskFunction_t,
    pub uxDummy7: UBaseType_t,
    pub ucDummy8: u8,
}
impl Default for xSTATIC_TIMER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type StaticTimer_t = xSTATIC_TIMER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_STREAM_BUFFER {
    pub uxDummy1: [size_t; 4usize],
    pub pvDummy2: [*mut ffi::ctypes::c_void; 3usize],
    pub ucDummy3: u8,
    pub uxDummy4: UBaseType_t,
}
impl Default for xSTATIC_STREAM_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type StaticStreamBuffer_t = xSTATIC_STREAM_BUFFER;
pub type StaticMessageBuffer_t = StaticStreamBuffer_t;
pub type uint = ffi::ctypes::c_uint;
pub type sint = ffi::ctypes::c_int;
pub type BOOL = ffi::ctypes::c_uchar;
pub type bool_ = ffi::ctypes::c_uchar;
pub const _RTK_STATUS___EXIT_SUCCESS: _RTK_STATUS_ = 0;
pub const _RTK_STATUS___EXIT_FAILURE: _RTK_STATUS_ = 1;
pub type _RTK_STATUS_ = ffi::ctypes::c_uint;
pub use self::_RTK_STATUS_ as RTK_STATUS;
pub type PRTK_STATUS = *mut _RTK_STATUS_;
pub type PVOID = *mut ffi::ctypes::c_void;
pub type dma_addr_t = u32;
pub type proc_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut ffi::ctypes::c_void)>;
pub type __kernel_size_t = ffi::ctypes::c_uint;
pub type __kernel_ssize_t = ffi::ctypes::c_int;
pub type SIZE_T = __kernel_size_t;
pub type SSIZE_T = __kernel_ssize_t;
pub type BOOLEAN = ffi::ctypes::c_uchar;
pub type PBOOLEAN = *mut ffi::ctypes::c_uchar;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct BOOT_EXPORT_SYMB_TABLE {
    pub rdp_decrypt_func: ::core::option::Option<
        unsafe extern "C" fn(addr: u32, key: *mut u8, cnt: u8, buf: *mut u8),
    >,
    pub psram_s_start_addr: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct RAM_START_FUNCTION {
    pub RamStartFun: ::core::option::Option<unsafe extern "C" fn()>,
    pub RamWakeupFun: ::core::option::Option<unsafe extern "C" fn()>,
    pub VectorNS: u32,
}
pub type PRAM_START_FUNCTION = *mut RAM_START_FUNCTION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RAM_FUNCTION_START_TABLE_ {
    pub RamStartFun: ::core::option::Option<unsafe extern "C" fn()>,
    pub RamWakeupFun: ::core::option::Option<unsafe extern "C" fn()>,
    pub RamPatchFun0: ::core::option::Option<unsafe extern "C" fn()>,
    pub RamPatchFun1: ::core::option::Option<unsafe extern "C" fn()>,
    pub RamPatchFun2: ::core::option::Option<unsafe extern "C" fn()>,
    pub FlashStartFun: ::core::option::Option<unsafe extern "C" fn()>,
    pub Img1ValidCode: u32,
    pub ExportTable: *mut BOOT_EXPORT_SYMB_TABLE,
}
impl Default for _RAM_FUNCTION_START_TABLE_ {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type RAM_FUNCTION_START_TABLE = _RAM_FUNCTION_START_TABLE_;
pub type PRAM_FUNCTION_START_TABLE = *mut _RAM_FUNCTION_START_TABLE_;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DSLP_RETENTION_FUNC_TABLE_ {
    pub DSLPPatchFun0: ::core::option::Option<unsafe extern "C" fn()>,
    pub PatchLen: u32,
}
pub type DSLP_RETENTION_FUNC_TABLE = _DSLP_RETENTION_FUNC_TABLE_;
pub type PDSLP_RETENTION_FUNC_TABLE = *mut _DSLP_RETENTION_FUNC_TABLE_;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _driver_call_os_func_map {
    pub driver_enter_critical: ::core::option::Option<unsafe extern "C" fn()>,
    pub driver_exit_critical: ::core::option::Option<unsafe extern "C" fn()>,
}
extern "C" {
    pub fn _memset(
        s: *mut ffi::ctypes::c_void,
        c: ffi::ctypes::c_int,
        n: SIZE_T,
    ) -> *mut ffi::ctypes::c_void;
}
extern "C" {
    pub fn _memcpy(
        s1: *mut ffi::ctypes::c_void,
        s2: *const ffi::ctypes::c_void,
        n: SIZE_T,
    ) -> *mut ffi::ctypes::c_void;
}
extern "C" {
    pub fn _memcmp(
        av: *const ffi::ctypes::c_void,
        bv: *const ffi::ctypes::c_void,
        len: SIZE_T,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _memchr(
        src_void: *const ffi::ctypes::c_void,
        c: ffi::ctypes::c_int,
        length: size_t,
    ) -> *mut ffi::ctypes::c_void;
}
extern "C" {
    pub fn _memmove(
        dst_void: *mut ffi::ctypes::c_void,
        src_void: *const ffi::ctypes::c_void,
        length: size_t,
    ) -> *mut ffi::ctypes::c_void;
}
extern "C" {
    pub fn memcpy_gdma_init();
}
extern "C" {
    pub fn memcpy_gdma(
        dest: *mut ffi::ctypes::c_void,
        src: *mut ffi::ctypes::c_void,
        size: u32,
    ) -> ffi::ctypes::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IDAU_EntryTypeDef {
    pub IDAU_BARx: u32,
    pub IDAU_LARx: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IDAU_TypeDef {
    pub ENTRY: [IDAU_EntryTypeDef; 8usize],
    pub IDAU_CTRL: u32,
    pub IDAU_LOCK: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WDG_TypeDef {
    pub VENDOR: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct UART_TypeDef {
    pub DLL: u32,
    pub DLH_INTCR: u32,
    pub INTID: u32,
    pub LCR: u32,
    pub MCR: u32,
    pub LSR: u32,
    pub MDSR: u32,
    pub SPR: u32,
    pub STSR: u32,
    pub RB_THR: u32,
    pub MISCR: u32,
    pub TXPLSR: u32,
    pub RXPLSR: u32,
    pub BAUDMONR: u32,
    pub RSVD2: u32,
    pub DBG_UART: u32,
    pub RX_PATH: u32,
    pub MON_BAUD_CTRL: u32,
    pub MON_BAUD_STS: u32,
    pub MON_CYC_NUM: u32,
    pub RX_BYTE_CNT: u32,
    pub FCR: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SPI_TypeDef {
    pub CTRLR0: u32,
    pub CTRLR1: u32,
    pub SSIENR: u32,
    pub MWCR: u32,
    pub SER: u32,
    pub BAUDR: u32,
    pub TXFTLR: u32,
    pub RXFTLR: u32,
    pub TXFLR: u32,
    pub RXFLR: u32,
    pub SR: u32,
    pub IMR: u32,
    pub ISR: u32,
    pub RISR: u32,
    pub TXOICR: u32,
    pub RXOICR: u32,
    pub RXUICR: u32,
    pub MSTICR: u32,
    pub ICR: u32,
    pub DMACR: u32,
    pub DMATDLR: u32,
    pub DMARDLR: u32,
    pub IDR: u32,
    pub SSI_COMP_VERSION: u32,
    pub DR: [u32; 36usize],
    pub RX_SAMPLE_DLY: u32,
}
impl Default for SPI_TypeDef {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for SPI_TypeDef {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "SPI_TypeDef {{ CTRLR0: {:?}, CTRLR1: {:?}, SSIENR: {:?}, MWCR: {:?}, SER: {:?}, BAUDR: {:?}, TXFTLR: {:?}, RXFTLR: {:?}, TXFLR: {:?}, RXFLR: {:?}, SR: {:?}, IMR: {:?}, ISR: {:?}, RISR: {:?}, TXOICR: {:?}, RXOICR: {:?}, RXUICR: {:?}, MSTICR: {:?}, ICR: {:?}, DMACR: {:?}, DMATDLR: {:?}, DMARDLR: {:?}, IDR: {:?}, SSI_COMP_VERSION: {:?}, DR: [...], RX_SAMPLE_DLY: {:?} }}" , self . CTRLR0 , self . CTRLR1 , self . SSIENR , self . MWCR , self . SER , self . BAUDR , self . TXFTLR , self . RXFTLR , self . TXFLR , self . RXFLR , self . SR , self . IMR , self . ISR , self . RISR , self . TXOICR , self . RXOICR , self . RXUICR , self . MSTICR , self . ICR , self . DMACR , self . DMATDLR , self . DMARDLR , self . IDR , self . SSI_COMP_VERSION , self . RX_SAMPLE_DLY)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SPIC_TypeDef {
    pub ctrlr0: u32,
    pub ctrlr1: u32,
    pub ssienr: u32,
    pub mwcr: u32,
    pub ser: u32,
    pub baudr: u32,
    pub txftlr: u32,
    pub rxftlr: u32,
    pub txflr: u32,
    pub rxflr: u32,
    pub sr: u32,
    pub imr: u32,
    pub isr: u32,
    pub risr: u32,
    pub txoicr: u32,
    pub rxoicr: u32,
    pub rxuicr: u32,
    pub msticr: u32,
    pub icr: u32,
    pub dmacr: u32,
    pub dmatdlr: u32,
    pub dmardlr: u32,
    pub idr: u32,
    pub spi_flash_version: u32,
    pub dr: [SPIC_TypeDef__bindgen_ty_1; 32usize],
    pub rd_fast_single: u32,
    pub rd_dual_o: u32,
    pub rd_dual_io: u32,
    pub rd_quad_o: u32,
    pub rd_quad_io: u32,
    pub wr_single: u32,
    pub wr_dual_i: u32,
    pub wr_dual_ii: u32,
    pub wr_quad_i: u32,
    pub wr_quad_ii: u32,
    pub wr_enable: u32,
    pub rd_status: u32,
    pub ctrlr2: u32,
    pub fbaudr: u32,
    pub addr_length: u32,
    pub auto_length: u32,
    pub valid_cmd: u32,
    pub flash_size: u32,
    pub flush_fifo: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SPIC_TypeDef__bindgen_ty_1 {
    pub byte: u8,
    pub half: u16,
    pub word: u32,
    _bindgen_union_align: u32,
}
impl Default for SPIC_TypeDef__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for SPIC_TypeDef__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "SPIC_TypeDef__bindgen_ty_1 {{ union }}")
    }
}
impl Default for SPIC_TypeDef {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for SPIC_TypeDef {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "SPIC_TypeDef {{ ctrlr0: {:?}, ctrlr1: {:?}, ssienr: {:?}, mwcr: {:?}, ser: {:?}, baudr: {:?}, txftlr: {:?}, rxftlr: {:?}, txflr: {:?}, rxflr: {:?}, sr: {:?}, imr: {:?}, isr: {:?}, risr: {:?}, txoicr: {:?}, rxoicr: {:?}, rxuicr: {:?}, msticr: {:?}, icr: {:?}, dmacr: {:?}, dmatdlr: {:?}, dmardlr: {:?}, idr: {:?}, spi_flash_version: {:?}, dr: [...], rd_fast_single: {:?}, rd_dual_o: {:?}, rd_dual_io: {:?}, rd_quad_o: {:?}, rd_quad_io: {:?}, wr_single: {:?}, wr_dual_i: {:?}, wr_dual_ii: {:?}, wr_quad_i: {:?}, wr_quad_ii: {:?}, wr_enable: {:?}, rd_status: {:?}, ctrlr2: {:?}, fbaudr: {:?}, addr_length: {:?}, auto_length: {:?}, valid_cmd: {:?}, flash_size: {:?}, flush_fifo: {:?} }}" , self . ctrlr0 , self . ctrlr1 , self . ssienr , self . mwcr , self . ser , self . baudr , self . txftlr , self . rxftlr , self . txflr , self . rxflr , self . sr , self . imr , self . isr , self . risr , self . txoicr , self . rxoicr , self . rxuicr , self . msticr , self . icr , self . dmacr , self . dmatdlr , self . dmardlr , self . idr , self . spi_flash_version , self . rd_fast_single , self . rd_dual_o , self . rd_dual_io , self . rd_quad_o , self . rd_quad_io , self . wr_single , self . wr_dual_i , self . wr_dual_ii , self . wr_quad_i , self . wr_quad_ii , self . wr_enable , self . rd_status , self . ctrlr2 , self . fbaudr , self . addr_length , self . auto_length , self . valid_cmd , self . flash_size , self . flush_fifo)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct USI_TypeDef {
    pub USI_MODE_CTRL: u32,
    pub SW_RESET: u32,
    pub RSVD0: [u32; 2usize],
    pub DMA_ENABLE: u32,
    pub DMA_REQ_SIZE: u32,
    pub RSVD1: [u32; 2usize],
    pub TX_FIFO_WRITE: u32,
    pub TX_FIFO_CTRL: u32,
    pub TX_FIFO_STATUS: u32,
    pub RSVD2: [u32; 1usize],
    pub RX_FIFO_READ: u32,
    pub RX_FIFO_CTRL: u32,
    pub RX_FIFO_STATUS: u32,
    pub RX_FIFO_RD_CNT: u32,
    pub INTERRUPT_ENABLE: u32,
    pub INTERRUPT_STATUS: u32,
    pub RAW_INTERRUPT_STATUS: u32,
    pub I2C_TX_ABRT_SOURCE: u32,
    pub INTERRUPT_ALL_CLR: u32,
    pub INTERRUPT_STATUS_CLR: u32,
    pub RSVD3: [u32; 2usize],
    pub DEBUG_SEL: u32,
    pub DEBUG_PORT: u32,
    pub ECO_USE0: u32,
    pub ECO_USE1: u32,
    pub USI_COMP_VERSION: u32,
    pub RSVD4: [u32; 35usize],
    pub UART_CTRL: u32,
    pub UART_IRDA_CTRL: u32,
    pub UART_IRDA_TX_PULSE_WD: u32,
    pub UART_IRDA_RX_PULSE_WD: u32,
    pub UART_TX_FRACTION_BAUD: u32,
    pub UART_RX_BAUD_OSC: u32,
    pub UART_RX_BAUD_XTAL: u32,
    pub UART_RX_FRACTION_BAUD_CTRL: u32,
    pub UART_BAUD_MON_CTRL: u32,
    pub UART_BAUD_MON_STATUS0: u32,
    pub UART_BAUD_MON_STATUS1: u32,
    pub UART_TOGGLE_MON: u32,
    pub UART_FLOW_CTRL: u32,
    pub UART_RXFIFO_TO_TH: u32,
    pub UART_RXDMA_FLOW_CTRL: u32,
    pub RSVD5: [u32; 49usize],
    pub SPI_CTRL: u32,
    pub SPI_TRANS_EN: u32,
    pub SPI_TRANS_STATUS: u32,
    pub RSVD6: [u32; 61usize],
    pub I2C_CTRL: u32,
    pub I2C_SS_SCL_CNT: u32,
    pub I2C_FS_SCL_CNT: u32,
    pub I2C_HS_SCL_CNT: u32,
    pub I2C_SDA_TIMING: u32,
    pub I2C_DIG_FILTER: u32,
    pub I2C_SLV_ACK_CTRL: u32,
    pub I2C_ENABLE: u32,
    pub I2C_TAR: u32,
    pub I2C_DMA_CMD: u32,
    pub I2C_STATUS: u32,
    pub RSVD7: [u32; 1usize],
    pub I2C_ANA_FILTER1: u32,
    pub I2C_ANA_FILTER2: u32,
    pub I2C_ANA_FILTER3: u32,
    pub I2C_ANA_FILTER4: u32,
    pub I2C_ANA_FILTER5: u32,
    pub I2C_ANA_FILTER6: u32,
    pub I2C_ANA_FILTER7: u32,
    pub I2C_ANA_FILTER8: u32,
}
impl Default for USI_TypeDef {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for USI_TypeDef {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "USI_TypeDef {{ USI_MODE_CTRL: {:?}, SW_RESET: {:?}, RSVD0: {:?}, DMA_ENABLE: {:?}, DMA_REQ_SIZE: {:?}, RSVD1: {:?}, TX_FIFO_WRITE: {:?}, TX_FIFO_CTRL: {:?}, TX_FIFO_STATUS: {:?}, RSVD2: {:?}, RX_FIFO_READ: {:?}, RX_FIFO_CTRL: {:?}, RX_FIFO_STATUS: {:?}, RX_FIFO_RD_CNT: {:?}, INTERRUPT_ENABLE: {:?}, INTERRUPT_STATUS: {:?}, RAW_INTERRUPT_STATUS: {:?}, I2C_TX_ABRT_SOURCE: {:?}, INTERRUPT_ALL_CLR: {:?}, INTERRUPT_STATUS_CLR: {:?}, RSVD3: {:?}, DEBUG_SEL: {:?}, DEBUG_PORT: {:?}, ECO_USE0: {:?}, ECO_USE1: {:?}, USI_COMP_VERSION: {:?}, RSVD4: [...], UART_CTRL: {:?}, UART_IRDA_CTRL: {:?}, UART_IRDA_TX_PULSE_WD: {:?}, UART_IRDA_RX_PULSE_WD: {:?}, UART_TX_FRACTION_BAUD: {:?}, UART_RX_BAUD_OSC: {:?}, UART_RX_BAUD_XTAL: {:?}, UART_RX_FRACTION_BAUD_CTRL: {:?}, UART_BAUD_MON_CTRL: {:?}, UART_BAUD_MON_STATUS0: {:?}, UART_BAUD_MON_STATUS1: {:?}, UART_TOGGLE_MON: {:?}, UART_FLOW_CTRL: {:?}, UART_RXFIFO_TO_TH: {:?}, UART_RXDMA_FLOW_CTRL: {:?}, RSVD5: [...], SPI_CTRL: {:?}, SPI_TRANS_EN: {:?}, SPI_TRANS_STATUS: {:?}, RSVD6: [...], I2C_CTRL: {:?}, I2C_SS_SCL_CNT: {:?}, I2C_FS_SCL_CNT: {:?}, I2C_HS_SCL_CNT: {:?}, I2C_SDA_TIMING: {:?}, I2C_DIG_FILTER: {:?}, I2C_SLV_ACK_CTRL: {:?}, I2C_ENABLE: {:?}, I2C_TAR: {:?}, I2C_DMA_CMD: {:?}, I2C_STATUS: {:?}, RSVD7: {:?}, I2C_ANA_FILTER1: {:?}, I2C_ANA_FILTER2: {:?}, I2C_ANA_FILTER3: {:?}, I2C_ANA_FILTER4: {:?}, I2C_ANA_FILTER5: {:?}, I2C_ANA_FILTER6: {:?}, I2C_ANA_FILTER7: {:?}, I2C_ANA_FILTER8: {:?} }}" , self . USI_MODE_CTRL , self . SW_RESET , self . RSVD0 , self . DMA_ENABLE , self . DMA_REQ_SIZE , self . RSVD1 , self . TX_FIFO_WRITE , self . TX_FIFO_CTRL , self . TX_FIFO_STATUS , self . RSVD2 , self . RX_FIFO_READ , self . RX_FIFO_CTRL , self . RX_FIFO_STATUS , self . RX_FIFO_RD_CNT , self . INTERRUPT_ENABLE , self . INTERRUPT_STATUS , self . RAW_INTERRUPT_STATUS , self . I2C_TX_ABRT_SOURCE , self . INTERRUPT_ALL_CLR , self . INTERRUPT_STATUS_CLR , self . RSVD3 , self . DEBUG_SEL , self . DEBUG_PORT , self . ECO_USE0 , self . ECO_USE1 , self . USI_COMP_VERSION , self . UART_CTRL , self . UART_IRDA_CTRL , self . UART_IRDA_TX_PULSE_WD , self . UART_IRDA_RX_PULSE_WD , self . UART_TX_FRACTION_BAUD , self . UART_RX_BAUD_OSC , self . UART_RX_BAUD_XTAL , self . UART_RX_FRACTION_BAUD_CTRL , self . UART_BAUD_MON_CTRL , self . UART_BAUD_MON_STATUS0 , self . UART_BAUD_MON_STATUS1 , self . UART_TOGGLE_MON , self . UART_FLOW_CTRL , self . UART_RXFIFO_TO_TH , self . UART_RXDMA_FLOW_CTRL , self . SPI_CTRL , self . SPI_TRANS_EN , self . SPI_TRANS_STATUS , self . I2C_CTRL , self . I2C_SS_SCL_CNT , self . I2C_FS_SCL_CNT , self . I2C_HS_SCL_CNT , self . I2C_SDA_TIMING , self . I2C_DIG_FILTER , self . I2C_SLV_ACK_CTRL , self . I2C_ENABLE , self . I2C_TAR , self . I2C_DMA_CMD , self . I2C_STATUS , self . RSVD7 , self . I2C_ANA_FILTER1 , self . I2C_ANA_FILTER2 , self . I2C_ANA_FILTER3 , self . I2C_ANA_FILTER4 , self . I2C_ANA_FILTER5 , self . I2C_ANA_FILTER6 , self . I2C_ANA_FILTER7 , self . I2C_ANA_FILTER8)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct LCDC_TypeDef {
    pub LCDC_CTRL: u32,
    pub LCDC_PLANE_SIZE: u32,
    pub LCDC_UNDFLW_CFG: u32,
    pub LCDC_DMA_MODE_CFG: u32,
    pub LCDC_CLK_DIV: u32,
    pub RSVD0: [u32; 3usize],
    pub LCDC_IRQ_EN: u32,
    pub LCDC_IRQ_STATUS: u32,
    pub LCDC_IRQ_RAW: u32,
    pub LCDC_LINE_INT_POS: u32,
    pub LCDC_CUR_POS_STATUS: u32,
    pub LCDC_STATUS: u32,
    pub RSVD1: [u32; 2usize],
    pub LCDC_RGB_CFG: u32,
    pub LCDC_RGB_VSYNC_CFG: u32,
    pub LCDC_RGB_HSYNC_CFG: u32,
    pub LCDC_RGB_SYNC_STATUS: u32,
    pub RSVD2: [u32; 4usize],
    pub LCDC_MCU_CFG: u32,
    pub LCDC_MCU_VSYNC_CFG: u32,
    pub LCDC_MCU_TIMING_CFG: u32,
    pub LCDC_MCU_IO_DATA: u32,
    pub LCDC_MCU_IO_TO_CFG: u32,
    pub RSVD3: [u32; 3usize],
    pub LCDC_LED_CFG: u32,
    pub LCDC_LED_TIMING: u32,
    pub LCDC_LED_IDLE: u32,
    pub RSVD4: [u32; 1usize],
    pub LCDC_IMG_BASE_ADDR: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CT_CH_TypeDef {
    pub CTRL: u32,
    pub ATHR: u32,
    pub MBIAS: u32,
    pub DATA: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CAPTOUCH_TypeDef {
    pub CT_CTRL: u32,
    pub CT_SP_CTRL: u32,
    pub CT_ETC_CTRL: u32,
    pub CT_SNR: u32,
    pub CT_MODE_CTRL: u32,
    pub CT_FIFO_STATUS: u32,
    pub CT_FIFO: u32,
    pub RSVD0: u32,
    pub CT_IER: u32,
    pub CT_ISR: u32,
    pub CT_ISR_RAW: u32,
    pub RSVD1: u32,
    pub CT_ICR_ALL: u32,
    pub CT_ICR: u32,
    pub RSVD2: [u32; 50usize],
    pub CT_CH: [CT_CH_TypeDef; 5usize],
    pub RSVD3: [u32; 172usize],
    pub CT_ADC_REG0X_LPAD: u32,
    pub CT_ADC_REG1X_LPAD: u32,
    pub CT_ADC_REG0X_LPSD: u32,
    pub CT_ADC_TIME: u32,
}
impl Default for CAPTOUCH_TypeDef {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for CAPTOUCH_TypeDef {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "CAPTOUCH_TypeDef {{ CT_CTRL: {:?}, CT_SP_CTRL: {:?}, CT_ETC_CTRL: {:?}, CT_SNR: {:?}, CT_MODE_CTRL: {:?}, CT_FIFO_STATUS: {:?}, CT_FIFO: {:?}, RSVD0: {:?}, CT_IER: {:?}, CT_ISR: {:?}, CT_ISR_RAW: {:?}, RSVD1: {:?}, CT_ICR_ALL: {:?}, CT_ICR: {:?}, RSVD2: [...], CT_CH: {:?}, RSVD3: [...], CT_ADC_REG0X_LPAD: {:?}, CT_ADC_REG1X_LPAD: {:?}, CT_ADC_REG0X_LPSD: {:?}, CT_ADC_TIME: {:?} }}" , self . CT_CTRL , self . CT_SP_CTRL , self . CT_ETC_CTRL , self . CT_SNR , self . CT_MODE_CTRL , self . CT_FIFO_STATUS , self . CT_FIFO , self . RSVD0 , self . CT_IER , self . CT_ISR , self . CT_ISR_RAW , self . RSVD1 , self . CT_ICR_ALL , self . CT_ICR , self . CT_CH , self . CT_ADC_REG0X_LPAD , self . CT_ADC_REG1X_LPAD , self . CT_ADC_REG0X_LPSD , self . CT_ADC_TIME)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IR_TypeDef {
    pub IR_CLK_DIV: u32,
    pub IR_TX_CONFIG: u32,
    pub IR_TX_SR: u32,
    pub IR_TX_COMPE_DIV: u32,
    pub IR_TX_INT_CLR: u32,
    pub IR_TX_FIFO: u32,
    pub IR_RX_CONFIG: u32,
    pub IR_RX_SR: u32,
    pub IR_RX_INT_CLR: u32,
    pub IR_RX_CNT_INT_SEL: u32,
    pub IR_RX_FIFO: u32,
    pub IR_VERSION: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct QDEC_TypeDef {
    pub QDEC_CLK_CFG: u32,
    pub QDEC_CTRL: u32,
    pub QDEC_MPC: u32,
    pub QDEC_RC: u32,
    pub QDEC_PC: u32,
    pub QDEC_ISC: u32,
    pub QDEC_VCTRL: u32,
    pub QDEC_VC: u32,
    pub QDEC_VCCAP: u32,
    pub QDEC_PCCAP: u32,
    pub QDEC_VTRLD: u32,
    pub QDEC_VT: u32,
    pub QDEC_VCOMP: u32,
    pub DUMMY: [u32; 2usize],
    pub QDEC_IMR: u32,
    pub QDEC_ISR: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ADC_TypeDef {
    pub ADC_CONF: u32,
    pub ADC_IN_TYPE: u32,
    pub ADC_COMP_TH_CH: [u32; 11usize],
    pub ADC_COMP_CTRL: u32,
    pub ADC_COMP_STS: u32,
    pub ADC_CHSW_LIST: [u32; 2usize],
    pub ADC_RST_LIST: u32,
    pub ADC_AUTO_CSW_CTRL: u32,
    pub ADC_SW_TRIG: u32,
    pub ADC_LAST_CH: u32,
    pub ADC_BUSY_STS: u32,
    pub ADC_INTR_CTRL: u32,
    pub ADC_INTR_RAW_STS: u32,
    pub ADC_INTR_STS: u32,
    pub ADC_IT_CHNO_CON: u32,
    pub ADC_FULL_LVL: u32,
    pub ADC_EXT_TRIG_TIMER_SEL: u32,
    pub ADC_DATA_CH: [u32; 11usize],
    pub ADC_DATA_GLOBAL: u32,
    pub ADC_DMA_CON: u32,
    pub ADC_FLR: u32,
    pub ADC_CLR_FIFO: u32,
    pub ADC_CLK_DIV: u32,
    pub ADC_DELAY_CNT: u32,
    pub ADC_PWR_CTRL: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CMP_TypeDef {
    pub COMP_REF_CH: [u32; 4usize],
    pub COMP_INTR_CTRL: u32,
    pub COMP_WK_STS: u32,
    pub COMP_WK_RAW_STS: u32,
    pub COMP_CHSW_LIST: u32,
    pub COMP_LAST_CH: u32,
    pub COMP_BUSY_STS: u32,
    pub COMP_CH_STS: u32,
    pub COMP_AUTO_SHUT: u32,
    pub COMP_EXT_TRIG_CTRL: u32,
    pub COMP_EXT_TRIG_TIMER_SEL: u32,
    pub COMP_RST_LIST: u32,
    pub COMP_AUTOSW_EN: u32,
    pub COMP_EN_TRIG: u32,
    pub COMP_EXT_WK_SHUT_CTRL: u32,
    pub COMP_ANALOG: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct I2C_TypeDef {
    pub IC_CON: u32,
    pub IC_TAR: u32,
    pub IC_SAR: u32,
    pub IC_HS_MADDR: u32,
    pub IC_DATA_CMD: u32,
    pub IC_SS_SCL_HCNT: u32,
    pub IC_SS_SCL_LCNT: u32,
    pub IC_FS_SCL_HCNT: u32,
    pub IC_FS_SCL_LCNT: u32,
    pub IC_HS_SCL_HCNT: u32,
    pub IC_HS_SCL_LCNT: u32,
    pub IC_INTR_STAT: u32,
    pub IC_INTR_MASK: u32,
    pub IC_RAW_INTR_STAT: u32,
    pub IC_RX_TL: u32,
    pub IC_TX_TL: u32,
    pub IC_CLR_INTR: u32,
    pub IC_CLR_RX_UNDER: u32,
    pub IC_CLR_RX_OVER: u32,
    pub IC_CLR_TX_OVER: u32,
    pub IC_CLR_RD_REQ: u32,
    pub IC_CLR_TX_ABRT: u32,
    pub IC_CLR_RX_DONE: u32,
    pub IC_CLR_ACTIVITY: u32,
    pub IC_CLR_STOP_DET: u32,
    pub IC_CLR_START_DET: u32,
    pub IC_CLR_GEN_CALL: u32,
    pub IC_ENABLE: u32,
    pub IC_STATUS: u32,
    pub IC_TXFLR: u32,
    pub IC_RXFLR: u32,
    pub IC_SDA_HOLD: u32,
    pub IC_TX_ABRT_SOURCE: u32,
    pub IC_SLV_DATA_NACK_ONLY: u32,
    pub IC_DMA_CR: u32,
    pub IC_DMA_TDLR: u32,
    pub IC_DMA_RDLR: u32,
    pub IC_SDA_SETUP: u32,
    pub IC_ACK_GENERAL_CALL: u32,
    pub IC_ENABLE_STATUS: u32,
    pub IC_DMA_CMD: u32,
    pub IC_DMA_DAT_LEN: u32,
    pub IC_DMA_MOD: u32,
    pub IC_SLEEP: u32,
    pub IC_RSVD1: [u32; 4usize],
    pub IC_RSVD2: [u32; 4usize],
    pub IC_RSVD3: [u32; 4usize],
    pub IC_RSVD4: u32,
    pub IC_CLR_ADDR_MATCH: u32,
    pub IC_CLR_DMA_I2C_DONE: u32,
    pub IC_FILTER: u32,
    pub IC_RSVD5: u32,
    pub IC_SAR1: u32,
    pub IC_DATA_S1: u32,
    pub IC_COMP_VERSION: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct I2S_TypeDef {
    pub IS_CTL: u32,
    pub IS_TX_PAGE_PTR: u32,
    pub IS_RX_PAGE_PTR: u32,
    pub IS_SETTING: u32,
    pub IS_TX_MASK_INT: u32,
    pub IS_TX_STATUS_INT: u32,
    pub IS_RX_MASK_INT: u32,
    pub IS_RX_STATUS_INT: u32,
    pub IS_TX_PAGE_OWN: [u32; 4usize],
    pub IS_RX_PAGE_OWN: [u32; 4usize],
    pub IS_VERSION_ID: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AUDIO_SI_TypeDef {
    pub SI_CTRLR: u32,
    pub SI_CLK_EN: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AUDIO_SPORT_TypeDef {
    pub SP_TX_DR: u32,
    pub SP_CTRLR0: u32,
    pub SP_CTRLR1: u32,
    pub SP_DSP_INT_CR: u32,
    pub SP_RX_DR: u32,
    pub SP_FIFO_SR: u32,
    pub SP_ERROR_CNT_SR: u32,
    pub SP_CLK_DIV: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct RTIM_CCR_TypeDef {
    pub CCRx: u16,
    pub RSVD: u8,
    pub CCMRx: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct RTIM_TypeDef {
    pub EN: u32,
    pub CR: u32,
    pub DIER: u32,
    pub SR: u32,
    pub EGR: u32,
    pub CNT: u32,
    pub PSC: u32,
    pub ARR: u32,
    pub CCMRx: [u32; 18usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct RTC_TypeDef {
    pub TR: u32,
    pub CR: u32,
    pub ISR: u32,
    pub PRER: u32,
    pub CALIBR: u32,
    pub ALMR1L: u32,
    pub ALMR1H: u32,
    pub WPR: u32,
    pub CLKACALR: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PINMUX_TypeDef {
    pub PADCTR: [u32; 64usize],
}
impl Default for PINMUX_TypeDef {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for PINMUX_TypeDef {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "PINMUX_TypeDef {{ PADCTR: [...] }}")
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GPIO_Port_TypeDef {
    pub DR: u32,
    pub DDR: u32,
    pub CTRL: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GPIO_TypeDef {
    pub PORT: [GPIO_Port_TypeDef; 4usize],
    pub INT_EN: u32,
    pub INT_MASK: u32,
    pub INT_TYPE: u32,
    pub INT_POLARITY: u32,
    pub INT_STATUS: u32,
    pub INT_RAWSTATUS: u32,
    pub DEBOUNCE: u32,
    pub PORTA_EOI: u32,
    pub EXT_PORT: [u32; 4usize],
    pub LSSYNC: u32,
    pub IDCODE: u32,
    pub INT_BOTHEDGE: u32,
    pub VERIDCODE: u32,
    pub CONFIG2: u32,
    pub CONFIG1: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IPSEC_TypeDef {
    pub SDSR: u32,
    pub SDFW: u32,
    pub SDSW: u32,
    pub RSVD0: u32,
    pub RST_ISR_CON: u32,
    pub IMR: u32,
    pub DEBUG: u32,
    pub ERR_STAT: u32,
    pub A2EO_SUM: u32,
    pub ENL_SUM: u32,
    pub APL_SUM: u32,
    pub EPL_SUM: u32,
    pub SWAP_BURST: u32,
    pub RSVD1: [u32; 3usize],
    pub ENG_DBG: u32,
    pub DMA_LX_DBG: u32,
    pub DMA_RX_DBG: u32,
    pub DMA_TX_DBG: u32,
    pub STA_SDES_CFG: u32,
    pub STA_SDES_PTR: u32,
    pub STA_SDES_CMD1: u32,
    pub STA_SDES_CMD2: u32,
    pub STA_SDES_CMD3: u32,
    pub STA_DDES_CFG: u32,
    pub STA_DDES_PTR: u32,
    pub RSVD2: [u32; 3usize],
    pub CFG_SSET_ADDR_L_LIMIT: u32,
    pub CFG_SSET_ADDR_H_LIMIT: u32,
    pub CFG_SDATA_ADDR_L_LIMIT: u32,
    pub CFG_SDATA_ADDR_H_LIMIT: u32,
    pub RSVD3: [u32; 2usize],
    pub CFG_DDATA_ADDR_L_LIMIT: u32,
    pub CFG_DDATA_ADDR_H_LIMIT: u32,
    pub RSVD4: [u32; 2usize],
    pub SK0_R0: u32,
    pub SK0_R1: u32,
    pub SK0_R2: u32,
    pub SK0_R3: u32,
    pub SK0_R4: u32,
    pub SK0_R5: u32,
    pub SK0_R6: u32,
    pub SK0_R7: u32,
    pub SK1_R0: u32,
    pub SK1_R1: u32,
    pub SK1_R2: u32,
    pub SK1_R3: u32,
    pub SK1_R4: u32,
    pub SK1_R5: u32,
    pub SK1_R6: u32,
    pub SK1_R7: u32,
    pub SK2_R0: u32,
    pub SK2_R1: u32,
    pub SK2_R2: u32,
    pub SK2_R3: u32,
    pub SK2_R4: u32,
    pub SK2_R5: u32,
    pub SK2_R6: u32,
    pub SK2_R7: u32,
    pub CRC_RSVD: [u32; 10usize],
    pub RSVD5: [u32; 472usize],
    pub DBG_VERSION: u32,
    pub RSVD6: [u32; 477usize],
    pub DDSR: u32,
    pub DDFW: u32,
    pub DDSW: u32,
    pub DESC_PKT_CONF: u32,
    pub DBG_SD: u32,
    pub DBG_DD: u32,
}
impl Default for IPSEC_TypeDef {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for IPSEC_TypeDef {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "IPSEC_TypeDef {{ SDSR: {:?}, SDFW: {:?}, SDSW: {:?}, RSVD0: {:?}, RST_ISR_CON: {:?}, IMR: {:?}, DEBUG: {:?}, ERR_STAT: {:?}, A2EO_SUM: {:?}, ENL_SUM: {:?}, APL_SUM: {:?}, EPL_SUM: {:?}, SWAP_BURST: {:?}, RSVD1: {:?}, ENG_DBG: {:?}, DMA_LX_DBG: {:?}, DMA_RX_DBG: {:?}, DMA_TX_DBG: {:?}, STA_SDES_CFG: {:?}, STA_SDES_PTR: {:?}, STA_SDES_CMD1: {:?}, STA_SDES_CMD2: {:?}, STA_SDES_CMD3: {:?}, STA_DDES_CFG: {:?}, STA_DDES_PTR: {:?}, RSVD2: {:?}, CFG_SSET_ADDR_L_LIMIT: {:?}, CFG_SSET_ADDR_H_LIMIT: {:?}, CFG_SDATA_ADDR_L_LIMIT: {:?}, CFG_SDATA_ADDR_H_LIMIT: {:?}, RSVD3: {:?}, CFG_DDATA_ADDR_L_LIMIT: {:?}, CFG_DDATA_ADDR_H_LIMIT: {:?}, RSVD4: {:?}, SK0_R0: {:?}, SK0_R1: {:?}, SK0_R2: {:?}, SK0_R3: {:?}, SK0_R4: {:?}, SK0_R5: {:?}, SK0_R6: {:?}, SK0_R7: {:?}, SK1_R0: {:?}, SK1_R1: {:?}, SK1_R2: {:?}, SK1_R3: {:?}, SK1_R4: {:?}, SK1_R5: {:?}, SK1_R6: {:?}, SK1_R7: {:?}, SK2_R0: {:?}, SK2_R1: {:?}, SK2_R2: {:?}, SK2_R3: {:?}, SK2_R4: {:?}, SK2_R5: {:?}, SK2_R6: {:?}, SK2_R7: {:?}, CRC_RSVD: {:?}, RSVD5: [...], DBG_VERSION: {:?}, RSVD6: [...], DDSR: {:?}, DDFW: {:?}, DDSW: {:?}, DESC_PKT_CONF: {:?}, DBG_SD: {:?}, DBG_DD: {:?} }}" , self . SDSR , self . SDFW , self . SDSW , self . RSVD0 , self . RST_ISR_CON , self . IMR , self . DEBUG , self . ERR_STAT , self . A2EO_SUM , self . ENL_SUM , self . APL_SUM , self . EPL_SUM , self . SWAP_BURST , self . RSVD1 , self . ENG_DBG , self . DMA_LX_DBG , self . DMA_RX_DBG , self . DMA_TX_DBG , self . STA_SDES_CFG , self . STA_SDES_PTR , self . STA_SDES_CMD1 , self . STA_SDES_CMD2 , self . STA_SDES_CMD3 , self . STA_DDES_CFG , self . STA_DDES_PTR , self . RSVD2 , self . CFG_SSET_ADDR_L_LIMIT , self . CFG_SSET_ADDR_H_LIMIT , self . CFG_SDATA_ADDR_L_LIMIT , self . CFG_SDATA_ADDR_H_LIMIT , self . RSVD3 , self . CFG_DDATA_ADDR_L_LIMIT , self . CFG_DDATA_ADDR_H_LIMIT , self . RSVD4 , self . SK0_R0 , self . SK0_R1 , self . SK0_R2 , self . SK0_R3 , self . SK0_R4 , self . SK0_R5 , self . SK0_R6 , self . SK0_R7 , self . SK1_R0 , self . SK1_R1 , self . SK1_R2 , self . SK1_R3 , self . SK1_R4 , self . SK1_R5 , self . SK1_R6 , self . SK1_R7 , self . SK2_R0 , self . SK2_R1 , self . SK2_R2 , self . SK2_R3 , self . SK2_R4 , self . SK2_R5 , self . SK2_R6 , self . SK2_R7 , self . CRC_RSVD , self . DBG_VERSION , self . DDSR , self . DDFW , self . DDSW , self . DESC_PKT_CONF , self . DBG_SD , self . DBG_DD)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CRC_TypeDef {
    pub CRC_RST: u32,
    pub CRC_OP: u32,
    pub CRC_POLY: u32,
    pub CRC_IV: u32,
    pub CRC_OXOR: u32,
    pub CRC_DATA: u32,
    pub CRC_STAT: u32,
    pub CRC_RESULT: u32,
    pub CRC_CNT: u32,
    pub CRC_DMA_RX_DBG: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct KEYSCAN_TypeDef {
    pub KS_CLK_DIV: u32,
    pub KS_TIM_CFG0: u32,
    pub KS_TIM_CFG1: u32,
    pub KS_CTRL: u32,
    pub KS_FIFO_CFG: u32,
    pub KS_COL_CFG: u32,
    pub KS_ROW_CFG: u32,
    pub KS_DATA_NUM: u32,
    pub KS_DATA_ENTRY: u32,
    pub KS_IMR: u32,
    pub KS_ICR: u32,
    pub KS_ISR: u32,
    pub KS_ISR_RAW: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SGPIO_TypeDef {
    pub SGPIO_RXTMR_CTRL: u32,
    pub SGPIO_RXPRVAL: u32,
    pub SGPIO_RXPRTC: u32,
    pub SGPIO_RXTC: u32,
    pub SGPIO_RXMC_CTRL: u32,
    pub SGPIO_RXMR0: u32,
    pub SGPIO_RXMR1: u32,
    pub SGPIO_RXMR2: u32,
    pub SGPIO_CAP_CTRL: u32,
    pub SGPIO_CAPR: u32,
    pub SGPIO_MULTMR_CTRL: u32,
    pub SGPIO_MULPRVAL: u32,
    pub SGPIO_MULPRTC: u32,
    pub SGPIO_MULTC: u32,
    pub SGPIO_MULMC_CTRL: u32,
    pub SGPIO_MULMR01GP0: u32,
    pub SGPIO_MULMR23GP0: u32,
    pub SGPIO_MULMR01GP1: u32,
    pub SGPIO_MULMR23GP1: u32,
    pub SGPIO_MUL_MCNT: u32,
    pub SGPIO_MULEMR: u32,
    pub SGPIO_DATA_CTRL: u32,
    pub SGPIO_RXDATA: u32,
    pub SGPIO_RXDATA_DP: u32,
    pub SGPIO_RXPOSR: u32,
    pub SGPIO_RXDATAMASK: u32,
    pub SGPIO_MULDATA: u32,
    pub SGPIO_MULDATA_DP: u32,
    pub SGPIO_MULPOSR: u32,
    pub SGPIO_MULFDATA: u32,
    pub SGPIO_ISR: u32,
    pub SGPIO_GF: u32,
    pub SGPIO_OUTPUT: u32,
    pub SGPIO_IMR: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PCTL_TypeDef {
    pub CCR: u32,
    pub DCR: u32,
    pub IOCR0: u32,
    pub CSR: u32,
    pub DRR: u32,
    pub RSVD0: [u32; 4usize],
    pub CMD_DPIN_NDGE: u32,
    pub CMD_DPIN: u32,
    pub CR_TDPIN: u32,
    pub MR_INFO: u32,
    pub MR0: u32,
    pub MR1: u32,
    pub RSVD1: [u32; 9usize],
    pub DPDRI: u32,
    pub DPDR: u32,
    pub RSVD2: [u32; 35usize],
    pub PCTL_SVN_ID: u32,
    pub PCTL_IDR: u32,
    pub RSVD3: [u32; 193usize],
    pub USER0_INDEX: u32,
    pub USER0_DATA: u32,
}
impl Default for PCTL_TypeDef {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for PCTL_TypeDef {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "PCTL_TypeDef {{ CCR: {:?}, DCR: {:?}, IOCR0: {:?}, CSR: {:?}, DRR: {:?}, RSVD0: {:?}, CMD_DPIN_NDGE: {:?}, CMD_DPIN: {:?}, CR_TDPIN: {:?}, MR_INFO: {:?}, MR0: {:?}, MR1: {:?}, RSVD1: {:?}, DPDRI: {:?}, DPDR: {:?}, RSVD2: [...], PCTL_SVN_ID: {:?}, PCTL_IDR: {:?}, RSVD3: [...], USER0_INDEX: {:?}, USER0_DATA: {:?} }}" , self . CCR , self . DCR , self . IOCR0 , self . CSR , self . DRR , self . RSVD0 , self . CMD_DPIN_NDGE , self . CMD_DPIN , self . CR_TDPIN , self . MR_INFO , self . MR0 , self . MR1 , self . RSVD1 , self . DPDRI , self . DPDR , self . PCTL_SVN_ID , self . PCTL_IDR , self . USER0_INDEX , self . USER0_DATA)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GDMA_ChannelTypeDef {
    pub SAR: u32,
    pub RSVD0: u32,
    pub DAR: u32,
    pub RSVD1: u32,
    pub LLP: u32,
    pub RSVD2: u32,
    pub CTL_LOW: u32,
    pub CTL_HIGH: u32,
    pub SSTAT: u32,
    pub RSVD4: u32,
    pub DSTAT: u32,
    pub RSVD5: u32,
    pub SSTATAR: u32,
    pub RSVD6: u32,
    pub DSTATAR: u32,
    pub RSVD7: u32,
    pub CFG_LOW: u32,
    pub CFG_HIGH: u32,
    pub SGR: u32,
    pub RSVD9: u32,
    pub DSR: u32,
    pub RSVD10: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GDMA_TypeDef {
    pub CH: [GDMA_ChannelTypeDef; 8usize],
    pub RAW_TFR: u32,
    pub RSVD0: u32,
    pub RAW_BLOCK: u32,
    pub RSVD1: u32,
    pub RAW_SRC_TRAN: u32,
    pub RSVD2: u32,
    pub RAW_DST_TRAN: u32,
    pub RSVD3: u32,
    pub RAW_ERR: u32,
    pub RSVD4: u32,
    pub STATUS_TFR: u32,
    pub RSVD5: u32,
    pub STATUS_BLOCK: u32,
    pub RSVD6: u32,
    pub STATUS_SRC_TRAN: u32,
    pub RSVD7: u32,
    pub STATUS_DST_TRAN: u32,
    pub RSVD8: u32,
    pub STATUS_ERR: u32,
    pub RSVD9: u32,
    pub MASK_TFR: u32,
    pub RSVD10: u32,
    pub MASK_BLOCK: u32,
    pub RSVD11: u32,
    pub MASK_SRC_TRAN: u32,
    pub RSVD12: u32,
    pub MASK_DST_TRAN: u32,
    pub RSVD13: u32,
    pub MASK_ERR: u32,
    pub RSVD14: u32,
    pub CLEAR_TFR: u32,
    pub RSVD15: u32,
    pub CLEAR_BLOCK: u32,
    pub RSVD16: u32,
    pub CLEAR_SRC_TRAN: u32,
    pub RSVD17: u32,
    pub CLEAR_DST_TRAN: u32,
    pub RSVD18: u32,
    pub CLEAR_ERR: u32,
    pub RSVD19: u32,
    pub StatusInt: u32,
    pub RSVD191: u32,
    pub ReqSrcReg: u32,
    pub RSVD20: u32,
    pub ReqDstReg: u32,
    pub RSVD21: u32,
    pub SglReqSrcReg: u32,
    pub RSVD22: u32,
    pub SglReqDstReg: u32,
    pub RSVD23: u32,
    pub LstSrcReg: u32,
    pub RSVD24: u32,
    pub LstDstReg: u32,
    pub RSVD25: u32,
    pub DmaCfgReg: u32,
    pub RSVD26: u32,
    pub ChEnReg: u32,
    pub RSVD27: u32,
    pub DmaIdReg: u32,
    pub RSVD28: u32,
    pub DmaTestReg: u32,
    pub RSVD29: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDIOH_TypeDef {
    pub RSVD1: [u32; 256usize],
    pub SRAM_CRL: u32,
    pub DMA_CRL1: u32,
    pub DMA_CRL2: u32,
    pub DMA_CRL3: u32,
    pub SYS_LOW_PWR: u32,
    pub RSVD2: [u32; 4usize],
    pub SD_ISR: u32,
    pub SD_ISREN: u32,
    pub RSVD3: [u32; 18usize],
    pub PAD_CTL: u32,
    pub CKGEN_CTL: u32,
    pub RSVD4: [u32; 33usize],
    pub RSVD5: u16,
    pub CARD_DRIVER_SEL: u8,
    pub CARD_STOP: u8,
    pub RSVD6: [u32; 2usize],
    pub RSVD7: u16,
    pub CARD_SELECT: u8,
    pub DUMMY1: u8,
    pub RSVD8: [u32; 3usize],
    pub RSVD9: u16,
    pub RSVD10: u8,
    pub CARD_EXIST: u8,
    pub CARD_INT_EN: u8,
    pub CARD_INT_PEND: u8,
    pub RSVD11: u16,
    pub RSVD12: u32,
    pub RSVD13: u8,
    pub CARD_CLK_EN_CTL: u8,
    pub RSVD14: u16,
    pub RSVD15: u32,
    pub CLK_PAD_DRIVE: u8,
    pub CMD_PAD_DRIVE: u8,
    pub DAT_INT_PEND: u8,
    pub RSVD16: u8,
    pub RSVD17: [u32; 19usize],
    pub SD_CONFIG1: u8,
    pub SD_CONFIG2: u8,
    pub SD_CONFIG3: u8,
    pub SD_STATUS1: u8,
    pub SD_STATUS2: u8,
    pub SD_BUS_STATUS: u8,
    pub RSVD18: u16,
    pub RSVD19: u8,
    pub SD_CMD: [u8; 6usize],
    pub SD_BYTE_CNT_L: u8,
    pub SD_BYTE_CNT_H: u8,
    pub SD_BLOCK_CNT_L: u8,
    pub SD_BLOCK_CNT_H: u8,
    pub SD_TRANSFER: u8,
    pub RSVD20: u8,
    pub SD_CMD_STATE: u8,
    pub SD_DATA_STATE: u8,
}
impl Default for SDIOH_TypeDef {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for SDIOH_TypeDef {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "SDIOH_TypeDef {{ RSVD1: [...], SRAM_CRL: {:?}, DMA_CRL1: {:?}, DMA_CRL2: {:?}, DMA_CRL3: {:?}, SYS_LOW_PWR: {:?}, RSVD2: {:?}, SD_ISR: {:?}, SD_ISREN: {:?}, RSVD3: {:?}, PAD_CTL: {:?}, CKGEN_CTL: {:?}, RSVD4: [...], RSVD5: {:?}, CARD_DRIVER_SEL: {:?}, CARD_STOP: {:?}, RSVD6: {:?}, RSVD7: {:?}, CARD_SELECT: {:?}, DUMMY1: {:?}, RSVD8: {:?}, RSVD9: {:?}, RSVD10: {:?}, CARD_EXIST: {:?}, CARD_INT_EN: {:?}, CARD_INT_PEND: {:?}, RSVD11: {:?}, RSVD12: {:?}, RSVD13: {:?}, CARD_CLK_EN_CTL: {:?}, RSVD14: {:?}, RSVD15: {:?}, CLK_PAD_DRIVE: {:?}, CMD_PAD_DRIVE: {:?}, DAT_INT_PEND: {:?}, RSVD16: {:?}, RSVD17: {:?}, SD_CONFIG1: {:?}, SD_CONFIG2: {:?}, SD_CONFIG3: {:?}, SD_STATUS1: {:?}, SD_STATUS2: {:?}, SD_BUS_STATUS: {:?}, RSVD18: {:?}, RSVD19: {:?}, SD_CMD: {:?}, SD_BYTE_CNT_L: {:?}, SD_BYTE_CNT_H: {:?}, SD_BLOCK_CNT_L: {:?}, SD_BLOCK_CNT_H: {:?}, SD_TRANSFER: {:?}, RSVD20: {:?}, SD_CMD_STATE: {:?}, SD_DATA_STATE: {:?} }}" , self . SRAM_CRL , self . DMA_CRL1 , self . DMA_CRL2 , self . DMA_CRL3 , self . SYS_LOW_PWR , self . RSVD2 , self . SD_ISR , self . SD_ISREN , self . RSVD3 , self . PAD_CTL , self . CKGEN_CTL , self . RSVD5 , self . CARD_DRIVER_SEL , self . CARD_STOP , self . RSVD6 , self . RSVD7 , self . CARD_SELECT , self . DUMMY1 , self . RSVD8 , self . RSVD9 , self . RSVD10 , self . CARD_EXIST , self . CARD_INT_EN , self . CARD_INT_PEND , self . RSVD11 , self . RSVD12 , self . RSVD13 , self . CARD_CLK_EN_CTL , self . RSVD14 , self . RSVD15 , self . CLK_PAD_DRIVE , self . CMD_PAD_DRIVE , self . DAT_INT_PEND , self . RSVD16 , self . RSVD17 , self . SD_CONFIG1 , self . SD_CONFIG2 , self . SD_CONFIG3 , self . SD_STATUS1 , self . SD_STATUS2 , self . SD_BUS_STATUS , self . RSVD18 , self . RSVD19 , self . SD_CMD , self . SD_BYTE_CNT_L , self . SD_BYTE_CNT_H , self . SD_BLOCK_CNT_L , self . SD_BLOCK_CNT_H , self . SD_TRANSFER , self . RSVD20 , self . SD_CMD_STATE , self . SD_DATA_STATE)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IPC_TypeDef {
    pub IPCx_IER: u32,
    pub IPCx_IDR: u32,
    pub IPCx_IRR: u32,
    pub IPCx_ICR: u32,
    pub IPCx_CPUID: u32,
    pub IPCx_ISR: u32,
    pub IPC0_SEM: u32,
    pub IPCx_IER_R: u32,
    pub IPCx_USR: [u32; 12usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct BACKUP_REG_TypeDef {
    pub DWORD: [u32; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RRAM_TypeDef {
    pub RRAM_WIFI_STATUS: u8,
    pub RRAM_WIFI_P_SECURTY: u8,
    pub RRAM_WIFI_G_SECURTY: u8,
    pub RRAM_RSVD1: u8,
    pub RRAM_NET_IP: u32,
    pub RRAM_NET_GW: u32,
    pub RRAM_NET_GW_MASK: u32,
    pub FLASH_ID2: u32,
    pub FLASH_cur_cmd: u32,
    pub FALSH_quad_valid_cmd: u32,
    pub FALSH_dual_valid_cmd: u32,
    pub FLASH_QuadEn_bit: u32,
    pub FLASH_StructInit: u32,
    pub FLASH_phase_shift_idx: u8,
    pub FLASH_rd_sample_phase_cal: u8,
    pub FLASH_class: u8,
    pub FLASH_cur_bitmode: u8,
    pub FLASH_ClockDiv: u8,
    pub FLASH_ReadMode: u8,
    pub FLASH_pseudo_prm_en: u8,
    pub FLASH_addr_phase_len: u8,
    pub FLASH_cmd_wr_status2: u8,
    pub FLASH_rd_dummy_cyle0: u8,
    pub FLASH_rd_dummy_cyle1: u8,
    pub FLASH_rd_dummy_cyle2: u8,
    pub RTC_YEAR: u32,
    pub RRAM_USER_RSVD: [u8; 120usize],
}
impl Default for RRAM_TypeDef {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for RRAM_TypeDef {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "RRAM_TypeDef {{ RRAM_WIFI_STATUS: {:?}, RRAM_WIFI_P_SECURTY: {:?}, RRAM_WIFI_G_SECURTY: {:?}, RRAM_RSVD1: {:?}, RRAM_NET_IP: {:?}, RRAM_NET_GW: {:?}, RRAM_NET_GW_MASK: {:?}, FLASH_ID2: {:?}, FLASH_cur_cmd: {:?}, FALSH_quad_valid_cmd: {:?}, FALSH_dual_valid_cmd: {:?}, FLASH_QuadEn_bit: {:?}, FLASH_StructInit: {:?}, FLASH_phase_shift_idx: {:?}, FLASH_rd_sample_phase_cal: {:?}, FLASH_class: {:?}, FLASH_cur_bitmode: {:?}, FLASH_ClockDiv: {:?}, FLASH_ReadMode: {:?}, FLASH_pseudo_prm_en: {:?}, FLASH_addr_phase_len: {:?}, FLASH_cmd_wr_status2: {:?}, FLASH_rd_dummy_cyle0: {:?}, FLASH_rd_dummy_cyle1: {:?}, FLASH_rd_dummy_cyle2: {:?}, RTC_YEAR: {:?}, RRAM_USER_RSVD: [...] }}" , self . RRAM_WIFI_STATUS , self . RRAM_WIFI_P_SECURTY , self . RRAM_WIFI_G_SECURTY , self . RRAM_RSVD1 , self . RRAM_NET_IP , self . RRAM_NET_GW , self . RRAM_NET_GW_MASK , self . FLASH_ID2 , self . FLASH_cur_cmd , self . FALSH_quad_valid_cmd , self . FALSH_dual_valid_cmd , self . FLASH_QuadEn_bit , self . FLASH_StructInit , self . FLASH_phase_shift_idx , self . FLASH_rd_sample_phase_cal , self . FLASH_class , self . FLASH_cur_bitmode , self . FLASH_ClockDiv , self . FLASH_ReadMode , self . FLASH_pseudo_prm_en , self . FLASH_addr_phase_len , self . FLASH_cmd_wr_status2 , self . FLASH_rd_dummy_cyle0 , self . FLASH_rd_dummy_cyle1 , self . FLASH_rd_dummy_cyle2 , self . RTC_YEAR)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct OTF_Mask_TypeDef {
    pub OTF_MASK_ENTRYx_CTRL: u32,
    pub OTF_MASK_ENTRYx_STRADDR: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct RSIP_MMU_TypeDef {
    pub MMU_ENTRYx_CTRL: u32,
    pub MMU_ENTRYx_STRADDR: u32,
    pub MMU_ENTRYx_ENDADDR: u32,
    pub MMU_ENTRYx_OFFSET: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct RSIP_REG_TypeDef {
    pub REG_OTF_DEC_CTRL: u32,
    pub REG_OTF_DEC_IV_EXT: [u32; 3usize],
    pub OTF_MASK: [OTF_Mask_TypeDef; 4usize],
    pub FLASH_MMU: [RSIP_MMU_TypeDef; 8usize],
}
pub type IRQn_Type = i32;
pub type HAL_VECTOR_FUN = ::core::option::Option<unsafe extern "C" fn()>;
pub type IRQ_FUN =
    ::core::option::Option<unsafe extern "C" fn(Data: *mut ffi::ctypes::c_void) -> u32>;
pub const IRQn_NonMaskableInt_IRQn: IRQn = -14;
pub const IRQn_HardFault_IRQn: IRQn = -13;
pub const IRQn_MemoryManagement_IRQn: IRQn = -12;
pub const IRQn_BusFault_IRQn: IRQn = -11;
pub const IRQn_UsageFault_IRQn: IRQn = -10;
pub const IRQn_SVCall_IRQn: IRQn = -5;
pub const IRQn_DebugMonitor_IRQn: IRQn = -4;
pub const IRQn_PendSV_IRQn: IRQn = -2;
pub const IRQn_SysTick_IRQn: IRQn = -1;
pub const IRQn_SYSTEM_ON_IRQ: IRQn = 0;
pub const IRQn_WDG_IRQ: IRQn = 1;
pub const IRQn_RXI300_IRQ: IRQn = 2;
pub const IRQn_UART_LOG_IRQ: IRQn = 3;
pub const IRQn_GPIOA_IRQ: IRQn = 4;
pub const IRQn_RTC_IRQ: IRQn = 5;
pub const IRQn_I2C0_IRQ: IRQn = 6;
pub const IRQn_SPI_FLASH_IRQ: IRQn = 7;
pub const IRQn_GPIOB_IRQ: IRQn = 8;
pub const IRQn_UARTLP_IRQ: IRQn = 9;
pub const IRQn_KEYSCAN_IRQ: IRQn = 10;
pub const IRQn_CTOUCH_IRQ: IRQn = 11;
pub const IRQn_BOR2_IRQ: IRQn = 12;
pub const IRQn_SGPIO_IRQ: IRQn = 13;
pub const IRQn_IPC_IRQ: IRQn = 14;
pub const IRQn_ADC_IRQ: IRQn = 15;
pub const IRQn_QDECODER_IRQ: IRQn = 16;
pub const IRQn_TIMER0_IRQ: IRQn = 17;
pub const IRQn_TIMER1_IRQ: IRQn = 18;
pub const IRQn_TIMER2_IRQ: IRQn = 19;
pub const IRQn_TIMER3_IRQ: IRQn = 20;
pub const IRQn_TIMER4_IRQ: IRQn = 21;
pub const IRQn_TIMER5_IRQ: IRQn = 22;
pub const IRQn_LCDC_IRQ: IRQn = 23;
pub const IRQn_USB_OTG_IRQ: IRQn = 24;
pub const IRQn_SDIO_DEVICE_IRQ: IRQn = 25;
pub const IRQn_SDIO_HOST_IRQ: IRQn = 26;
pub const IRQn_CRYPTO_IRQ: IRQn = 27;
pub const IRQn_I2S0_PCM0_IRQ: IRQn = 28;
pub const IRQn_PWR_DOWN_IRQ: IRQn = 29;
pub const IRQn_ADC_COMP_IRQ: IRQn = 30;
pub const IRQn_WL_DMA_IRQ: IRQn = 31;
pub const IRQn_WL_PROTOCOL_IRQ: IRQn = 32;
pub const IRQn_PSRAMC_IRQ: IRQn = 33;
pub const IRQn_UART0_IRQ: IRQn = 34;
pub const IRQn_UART1_IRQ: IRQn = 35;
pub const IRQn_SPI0_IRQ: IRQn = 36;
pub const IRQn_SPI1_IRQ: IRQn = 37;
pub const IRQn_USI_IRQ: IRQn = 38;
pub const IRQn_IR_IRQ: IRQn = 39;
pub const IRQn_BT2WL_STS_IRQ: IRQn = 40;
pub const IRQn_GDMA0_CHANNEL0_IRQ: IRQn = 41;
pub const IRQn_GDMA0_CHANNEL1_IRQ: IRQn = 42;
pub const IRQn_GDMA0_CHANNEL2_IRQ: IRQn = 43;
pub const IRQn_GDMA0_CHANNEL3_IRQ: IRQn = 44;
pub const IRQn_GDMA0_CHANNEL4_IRQ: IRQn = 45;
pub const IRQn_GDMA0_CHANNEL5_IRQ: IRQn = 46;
pub const IRQn_CRYPTO_IRQ_S: IRQn = 50;
pub const IRQn_RXI300_IRQ_S: IRQn = 51;
pub const IRQn_GDMA0_CHANNEL0_IRQ_S: IRQn = 52;
pub const IRQn_GDMA0_CHANNEL1_IRQ_S: IRQn = 53;
pub const IRQn_GDMA0_CHANNEL2_IRQ_S: IRQn = 54;
pub const IRQn_GDMA0_CHANNEL3_IRQ_S: IRQn = 55;
pub const IRQn_GDMA0_CHANNEL4_IRQ_S: IRQn = 56;
pub const IRQn_GDMA0_CHANNEL5_IRQ_S: IRQn = 57;
pub type IRQn = ffi::ctypes::c_int;
pub const LPIRQn_NonMaskableInt_IRQn_LP: LPIRQn = -14;
pub const LPIRQn_HardFault_IRQn_LP: LPIRQn = -13;
pub const LPIRQn_MemoryManagement_IRQn_LP: LPIRQn = -12;
pub const LPIRQn_BusFault_IRQn_LP: LPIRQn = -11;
pub const LPIRQn_UsageFault_IRQn_LP: LPIRQn = -10;
pub const LPIRQn_SVCall_IRQn_LP: LPIRQn = -5;
pub const LPIRQn_DebugMonitor_IRQn_LP: LPIRQn = -4;
pub const LPIRQn_PendSV_IRQn_LP: LPIRQn = -2;
pub const LPIRQn_SysTick_IRQn_LP: LPIRQn = -1;
pub const LPIRQn_SYSTEM_ON_IRQ_LP: LPIRQn = 0;
pub const LPIRQn_WDG_IRQ_LP: LPIRQn = 1;
pub const LPIRQn_RXI300_IRQ_LP: LPIRQn = 2;
pub const LPIRQn_UART_LOG_IRQ_LP: LPIRQn = 3;
pub const LPIRQn_GPIOA_IRQ_LP: LPIRQn = 4;
pub const LPIRQn_RTC_IRQ_LP: LPIRQn = 5;
pub const LPIRQn_I2C0_IRQ_LP: LPIRQn = 6;
pub const LPIRQn_SPI_FLASH_IRQ_LP: LPIRQn = 7;
pub const LPIRQn_GPIOB_IRQ_LP: LPIRQn = 8;
pub const LPIRQn_UARTLP_IRQ_LP: LPIRQn = 9;
pub const LPIRQn_KEYSCAN_IRQ_LP: LPIRQn = 10;
pub const LPIRQn_CTOUCH_IRQ_LP: LPIRQn = 11;
pub const LPIRQn_BOR2_IRQ_LP: LPIRQn = 12;
pub const LPIRQn_SGPIO_IRQ_LP: LPIRQn = 13;
pub const LPIRQn_IPC_IRQ_LP: LPIRQn = 14;
pub const LPIRQn_ADC_IRQ_LP: LPIRQn = 15;
pub const LPIRQn_QDECODER_IRQ_LP: LPIRQn = 16;
pub const LPIRQn_TIMER0_IRQ_LP: LPIRQn = 17;
pub const LPIRQn_TIMER1_IRQ_LP: LPIRQn = 18;
pub const LPIRQn_TIMER2_IRQ_LP: LPIRQn = 19;
pub const LPIRQn_TIMER3_IRQ_LP: LPIRQn = 20;
pub const LPIRQn_TIMER4_IRQ_LP: LPIRQn = 21;
pub const LPIRQn_TIMER5_IRQ_LP: LPIRQn = 22;
pub const LPIRQn_GDMA0_CHANNEL0_IRQ_LP: LPIRQn = 23;
pub const LPIRQn_GDMA0_CHANNEL1_IRQ_LP: LPIRQn = 24;
pub const LPIRQn_GDMA0_CHANNEL2_IRQ_LP: LPIRQn = 25;
pub const LPIRQn_WIFI_FISR_FESR: LPIRQn = 26;
pub const LPIRQn_WIFI_FTSR_MAILBOX: LPIRQn = 27;
pub const LPIRQn_GDMA0_CHANNEL3_IRQ_LP: LPIRQn = 28;
pub const LPIRQn_PWR_DOWN_IRQ_LP: LPIRQn = 29;
pub const LPIRQn_ADC_COMP_IRQ_LP: LPIRQn = 30;
pub const LPIRQn_KM4_WAKE_EVENT_IRQ_LP: LPIRQn = 31;
pub type LPIRQn = ffi::ctypes::c_int;
extern "C" {
    pub fn irq_table_init(StackP: u32);
}
extern "C" {
    pub fn irq_register(IrqFun: IRQ_FUN, IrqNum: IRQn_Type, Data: u32, Priority: u32) -> BOOL;
}
extern "C" {
    pub fn irq_unregister(IrqNum: IRQn_Type) -> BOOL;
}
extern "C" {
    pub fn irq_enable(IrqNum: IRQn_Type);
}
extern "C" {
    pub fn irq_disable(IrqNum: IRQn_Type);
}
extern "C" {
    pub static mut UserIrqFunTable: [IRQ_FUN; 0usize];
}
extern "C" {
    pub static mut UserIrqDataTable: [u32; 0usize];
}
extern "C" {
    pub static mut NewVectorTable: [HAL_VECTOR_FUN; 0usize];
}
extern "C" {
    pub fn LOGUART_DiagInit(InitConsol: BOOL);
}
extern "C" {
    pub fn LOGUART_PutChar(c: u8);
}
extern "C" {
    pub fn LOGUART_GetChar(PullMode: BOOL) -> u8;
}
extern "C" {
    pub fn LOGUART_Readable() -> u8;
}
extern "C" {
    pub fn LOGUART_GetIMR() -> u32;
}
extern "C" {
    pub fn LOGUART_SetIMR(SetValue: u32);
}
extern "C" {
    pub fn LOGUART_WaitBusy();
}
extern "C" {
    pub fn LOGUART_SetBaud_FromFlash();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PWRCFG_TypeDef {
    pub Module: u32,
    pub Status: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WAKEPIN_TypeDef {
    pub Pinmux: u32,
    pub Status: u32,
    pub Polarity: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct HSWAKEEVENT_TypeDef {
    pub Module: u32,
    pub Event: u32,
    pub Status: u32,
}
extern "C" {
    pub static mut aon_wakepin: [[u8; 3usize]; 4usize];
}
extern "C" {
    pub static mut sleep_wevent_config: [PWRCFG_TypeDef; 0usize];
}
extern "C" {
    pub static mut sleep_aon_wevent_config: [PWRCFG_TypeDef; 0usize];
}
extern "C" {
    pub static mut sleep_hsram_config: [PWRCFG_TypeDef; 0usize];
}
extern "C" {
    pub static mut sleep_lsram_config: [PWRCFG_TypeDef; 0usize];
}
extern "C" {
    pub static mut dsleep_lsram_config: [PWRCFG_TypeDef; 0usize];
}
extern "C" {
    pub static mut sleep_wakepin_config: [WAKEPIN_TypeDef; 0usize];
}
extern "C" {
    pub static mut km0_pwrmgt_config: [PWRCFG_TypeDef; 0usize];
}
extern "C" {
    pub static mut dsleep_aon_wevent_config: [PWRCFG_TypeDef; 0usize];
}
extern "C" {
    pub static mut hs_wakeevent_config: [HSWAKEEVENT_TypeDef; 0usize];
}
extern "C" {
    pub fn SOCPS_InitSYSIRQ_HP();
}
extern "C" {
    pub fn SOCPS_CPUReset();
}
extern "C" {
    pub fn SOCPS_SleepPG();
}
extern "C" {
    pub fn SOCPS_SleepCG();
}
extern "C" {
    pub fn SOCPS_InitSYSIRQ();
}
extern "C" {
    pub fn SOCPS_SleepInit();
}
extern "C" {
    pub fn SOCPS_DsleepInit();
}
extern "C" {
    pub fn SOCPS_SleepDeInit();
}
extern "C" {
    pub fn SOCPS_DsleepWakeStatusSet(DslpWake: u32);
}
extern "C" {
    pub fn SOCPS_DsleepWakeStatusGet() -> u32;
}
extern "C" {
    pub fn SOCPS_ClearWakeEvent_HP();
}
extern "C" {
    pub fn SOCPS_SetWakeEvent_HP(Option: u32, NewStatus: u32);
}
extern "C" {
    pub fn SOCPS_AONTimerCmd(NewStatus: u32);
}
extern "C" {
    pub fn SOCPS_AONWakeReason() -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn SOCPS_AONWakeClear(BitMask: u32);
}
extern "C" {
    pub fn SOCPS_AONTimer(SDuration: u32);
}
extern "C" {
    pub fn SOCPS_AONTSF(EarlyBcnUs: u32, WakeIntvalUs: u32);
}
extern "C" {
    pub fn SOCPS_MMUReFill();
}
extern "C" {
    pub fn SOCPS_SetWakeEvent(Option: u32, NewStatus: u32);
}
extern "C" {
    pub fn SOCPS_SetWakeEventAON(Option: u32, NewStatus: u32);
}
extern "C" {
    pub fn SOCPS_ClearWakePin();
}
extern "C" {
    pub fn SOCPS_ClearWakeEvent();
}
extern "C" {
    pub fn SOCPS_AudioLDO(NewStatus: u32);
}
extern "C" {
    pub fn SOCPS_SWRLDO_Suspend(new_status: u32);
}
extern "C" {
    pub fn SOCPS_OSC2M_Cmd(new_status: u32);
}
extern "C" {
    pub fn SOCPS_SleepCG_RAM();
}
extern "C" {
    pub fn SOCPS_SleepPG_RAM();
}
extern "C" {
    pub fn SOCPS_DeepSleep_RAM();
}
extern "C" {
    pub fn SOCPS_WakePinCheck() -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn LOG_PRINTF_BUFFER(fmt: *const ffi::ctypes::c_char) -> u32;
}
extern "C" {
    pub fn LOG_PRINTF_BUFFER_INIT(thread_init: u32) -> u32;
}
extern "C" {
    pub fn LOG_BUFF_SUSPEND() -> u32;
}
extern "C" {
    pub fn LOG_BUFF_RESUME() -> u32;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct log_buffer_t {
    pub buffer: [ffi::ctypes::c_char; 512usize],
}
impl Default for log_buffer_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for log_buffer_t {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "log_buffer_t {{ buffer: [...] }}")
    }
}
extern "C" {
    pub static mut log_buffer: [log_buffer_t; 0usize];
}
pub type DIAG_PRINT_BUF_FUNC =
    ::core::option::Option<unsafe extern "C" fn(fmt: *const ffi::ctypes::c_char) -> u32>;
extern "C" {
    pub static mut ConfigDebugBufferGet: DIAG_PRINT_BUF_FUNC;
}
extern "C" {
    pub fn DiagPrintf(fmt: *const ffi::ctypes::c_char, ...) -> u32;
}
extern "C" {
    pub fn DiagPrintfD(fmt: *const ffi::ctypes::c_char, ...) -> u32;
}
extern "C" {
    pub fn DiagVSprintf(
        buf: *mut ffi::ctypes::c_char,
        fmt: *const ffi::ctypes::c_char,
        dp: *const ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
pub const MODULE_DEFINE_MODULE_OS: MODULE_DEFINE = 0;
pub const MODULE_DEFINE_MODULE_BOOT: MODULE_DEFINE = 1;
pub const MODULE_DEFINE_MODULE_GDMA: MODULE_DEFINE = 2;
pub const MODULE_DEFINE_MODULE_GPIO: MODULE_DEFINE = 3;
pub const MODULE_DEFINE_MODULE_TIMER: MODULE_DEFINE = 4;
pub const MODULE_DEFINE_MODULE_I2C: MODULE_DEFINE = 5;
pub const MODULE_DEFINE_MODULE_I2S: MODULE_DEFINE = 6;
pub const MODULE_DEFINE_MODULE_PWM: MODULE_DEFINE = 7;
pub const MODULE_DEFINE_MODULE_SDIO: MODULE_DEFINE = 8;
pub const MODULE_DEFINE_MODULE_SPI: MODULE_DEFINE = 9;
pub const MODULE_DEFINE_MODULE_FLASH: MODULE_DEFINE = 10;
pub const MODULE_DEFINE_MODULE_UART: MODULE_DEFINE = 11;
pub const MODULE_DEFINE_MODULE_USB_OTG: MODULE_DEFINE = 12;
pub const MODULE_DEFINE_MODULE_IPSEC: MODULE_DEFINE = 13;
pub const MODULE_DEFINE_MODULE_ADC: MODULE_DEFINE = 14;
pub const MODULE_DEFINE_MODULE_EFUSE: MODULE_DEFINE = 15;
pub const MODULE_DEFINE_MODULE_MONIT: MODULE_DEFINE = 16;
pub const MODULE_DEFINE_MODULE_MISC: MODULE_DEFINE = 17;
pub const MODULE_DEFINE_MODULE_IR: MODULE_DEFINE = 18;
pub const MODULE_DEFINE_MODULE_QDECODE: MODULE_DEFINE = 19;
pub const MODULE_DEFINE_MODULE_KEYSCAN: MODULE_DEFINE = 20;
pub const MODULE_DEFINE_MODULE_SGPIO: MODULE_DEFINE = 21;
pub const MODULE_DEFINE_MODULE_AUDIO: MODULE_DEFINE = 22;
pub const MODULE_DEFINE_MODULE_LCD: MODULE_DEFINE = 23;
pub const MODULE_DEFINE_MODULE_WIFIFW: MODULE_DEFINE = 24;
pub const MODULE_DEFINE_MODULE_BT: MODULE_DEFINE = 25;
pub const MODULE_DEFINE_MODULE_IPC: MODULE_DEFINE = 26;
pub const MODULE_DEFINE_MODULE_KM4: MODULE_DEFINE = 27;
pub const MODULE_DEFINE_MODULE_NUMs: MODULE_DEFINE = 32;
pub type MODULE_DEFINE = ffi::ctypes::c_uint;
pub const LEVEL_DEFINE_LEVEL_ERROR: LEVEL_DEFINE = 0;
pub const LEVEL_DEFINE_LEVEL_WARN: LEVEL_DEFINE = 1;
pub const LEVEL_DEFINE_LEVEL_INFO: LEVEL_DEFINE = 2;
pub const LEVEL_DEFINE_LEVEL_TRACE: LEVEL_DEFINE = 3;
pub const LEVEL_DEFINE_LEVEL_NUMs: LEVEL_DEFINE = 4;
pub type LEVEL_DEFINE = ffi::ctypes::c_uint;
extern "C" {
    pub static mut ConfigDebug: [u32; 0usize];
}
extern "C" {
    pub static mut ConfigDebugBuffer: u32;
}
extern "C" {
    pub static mut ConfigDebugClose: u32;
}
pub type ECHOFUNC = ::core::option::Option<unsafe extern "C" fn(arg1: *mut u8, ...) -> u32>;
pub type monitor_cmd_handler =
    ::core::option::Option<unsafe extern "C" fn(argc: u16, argv: *mut *mut u8) -> u32>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct UART_LOG_BUF {
    pub BufCount: u8,
    pub UARTLogBuf: [u8; 127usize],
}
impl Default for UART_LOG_BUF {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for UART_LOG_BUF {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "UART_LOG_BUF {{ BufCount: {:?}, UARTLogBuf: [...] }}",
            self.BufCount
        )
    }
}
pub type PUART_LOG_BUF = *mut UART_LOG_BUF;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _COMMAND_TABLE_ {
    pub cmd: *const u8,
    pub ArgvCnt: u16,
    pub func: ::core::option::Option<unsafe extern "C" fn(argc: u16, argv: *mut *mut u8) -> u32>,
    pub msg: *const u8,
}
impl Default for _COMMAND_TABLE_ {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type COMMAND_TABLE = _COMMAND_TABLE_;
pub type PCOMMAND_TABLE = *mut _COMMAND_TABLE_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UART_LOG_CTL {
    pub NewIdx: u8,
    pub SeeIdx: u8,
    pub RevdNo: u8,
    pub EscSTS: u8,
    pub ExecuteCmd: u8,
    pub ExecuteEsc: u8,
    pub BootRdy: u8,
    pub Resvd: u8,
    pub pTmpLogBuf: PUART_LOG_BUF,
    pub pfINPUT: *mut ffi::ctypes::c_void,
    pub pCmdTbl: PCOMMAND_TABLE,
    pub CmdTblSz: u32,
    pub CRSTS: u32,
    pub GiveSema: ::core::option::Option<unsafe extern "C" fn()>,
    pub shell_task_rdy: u32,
}
impl Default for UART_LOG_CTL {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type PUART_LOG_CTL = *mut UART_LOG_CTL;
extern "C" {
    pub fn shell_init_rom(TBLSz: u32, pTBL: *mut ffi::ctypes::c_void);
}
extern "C" {
    pub fn shell_task_rom(Data: *mut ffi::ctypes::c_void);
}
extern "C" {
    pub fn shell_rom(MaxWaitCount: u32);
}
extern "C" {
    pub fn shell_uart_irq_rom(Data: *mut ffi::ctypes::c_void);
}
extern "C" {
    pub fn shell_cmd_history(RevData: u8, prvUartLogCtl: *mut UART_LOG_CTL, EchoFlag: u8);
}
extern "C" {
    pub fn shell_cmd_chk(RevData: u8, prvUartLogCtl: *mut UART_LOG_CTL, EchoFlag: u8) -> u8;
}
extern "C" {
    pub fn shell_array_init(pArrayToInit: *mut u8, ArrayLen: u8, InitValue: u8);
}
extern "C" {
    pub fn shell_get_argv(string: *const u8) -> *mut *mut u8;
}
extern "C" {
    pub fn shell_get_argc(string: *const u8) -> u8;
}
extern "C" {
    pub fn shell_init_ram();
}
extern "C" {
    pub fn shell_switch_ipc_int(Data: *mut ffi::ctypes::c_void, IrqStatus: u32, ChanNum: u32);
}
extern "C" {
    pub static mut shell_recv_all_data_onetime: u32;
}
extern "C" {
    pub static mut shell_interrupt_on: u32;
}
extern "C" {
    pub static mut rand_seed: [u32; 4usize];
}
extern "C" {
    pub static mut rand_first: u32;
}
extern "C" {
    pub fn Rand() -> u32;
}
extern "C" {
    pub fn cmd_dump_word(argc: u16, argv: *mut *mut u8) -> u32;
}
extern "C" {
    pub fn cmd_write_word(argc: u16, argv: *mut *mut u8) -> u32;
}
extern "C" {
    pub fn cmd_flash(argc: u16, argv: *mut *mut u8) -> u32;
}
extern "C" {
    pub fn cmd_efuse(argc: u16, argv: *mut *mut u8) -> u32;
}
extern "C" {
    pub fn cmd_rom_table(PTable: *mut *mut ffi::ctypes::c_void) -> u32;
}
extern "C" {
    pub fn SYSCFG_GetChipInfo() -> u32;
}
extern "C" {
    pub fn SYSCFG_TRP_LDOMode() -> u32;
}
extern "C" {
    pub fn SYSCFG_TRP_UARTImage() -> u32;
}
extern "C" {
    pub fn SYSCFG_TRP_ICFG() -> u32;
}
extern "C" {
    pub fn SYSCFG_ROMINFO_Get() -> u32;
}
extern "C" {
    pub fn SYSCFG_ROMINFO_Set();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PSCFG_TypeDef {
    pub km0_config_wifi_enable: u32,
    pub km0_enable_key_touch: u32,
    pub km0_tickles_debug: u32,
    pub km0_osc2m_close: u32,
    pub km0_pg_enable: u32,
    pub km0_rtc_calibration: u32,
    pub km0_audio_pad_enable: u32,
    pub km0_fw_idle_time: u32,
    pub km0_clk_down_time: u32,
    pub km0_rf_off_time: u32,
    pub km0_gating_time: u32,
    pub km0_rf_on_time: u32,
    pub km0_wake_time: u32,
    pub km0_dur1: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WIFICFG_TypeDef {
    pub wifi_app_ctrl_tdma: u32,
    pub wifi_ultra_low_power: u32,
    pub km4_cache_enable: u32,
    pub km0_dslp_force_reinit: u32,
}
extern "C" {
    pub static mut ps_config: PSCFG_TypeDef;
}
extern "C" {
    pub static mut wifi_config: WIFICFG_TypeDef;
}
extern "C" {
    pub fn SOCPS_SWR_PFMForce(NewStatus: u32);
}
extern "C" {
    pub fn SOCPS_WakeEvent() -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn SDM32K_Enable(AutoCalibration: u32);
}
extern "C" {
    pub fn SDM32K_RTCCalEnable(RTCCalibration: u32);
}
extern "C" {
    pub fn EXT32K_Cmd(NewStatus: u32);
}
extern "C" {
    pub fn CPU_ClkGet(Is_FPGA: u8) -> u32;
}
extern "C" {
    pub fn CPU_ClkSet(CpuType: u8);
}
extern "C" {
    pub fn XTAL_ClkGet() -> u32;
}
extern "C" {
    pub fn NCO2M_Init(clk_out_Hz: u32);
}
extern "C" {
    pub fn NCO2M_Cmd(NewState: u32);
}
extern "C" {
    pub fn PLL_I2S_Set(new_state: u32);
}
extern "C" {
    pub fn PLL_PCM_Set(new_state: u32);
}
extern "C" {
    pub fn PLL2_Set(BitMask: u32, NewState: u32);
}
extern "C" {
    pub fn PLL3_Set(BitMask: u32, NewState: u32);
}
extern "C" {
    pub fn OSC2M_Calibration(cal_osc_cycles: u32, ppm_limit: u32) -> u32;
}
extern "C" {
    pub fn OSC131K_Calibration(ppm_limit: u32) -> u32;
}
extern "C" {
    pub fn OSC4M_Init();
}
extern "C" {
    pub fn BOR_ThresholdSet(Thres_Low: u32, Thres_High: u32);
}
extern "C" {
    pub fn BOR_DbncSet(Option: u32, Dbnc_Value: u32);
}
extern "C" {
    pub fn BOR_ClearINT();
}
extern "C" {
    pub fn BOR_ModeSet(Option: u32, NewStatus: u32);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtl_crypto_srcdesc_t {
    pub b: rtl_crypto_srcdesc_t__bindgen_ty_1,
    pub d: rtl_crypto_srcdesc_t__bindgen_ty_2,
    pub w: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtl_crypto_srcdesc_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtl_crypto_srcdesc_t__bindgen_ty_1 {
    #[inline]
    pub fn key_len(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_key_len(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn iv_len(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_iv_len(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn keypad_len(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_keypad_len(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn hash_iv_len(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_hash_iv_len(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn ap(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_ap(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn cl(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_cl(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn priv_key(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_priv_key(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn otp_key(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_otp_key(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ls(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ls(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fs(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rs(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rsvd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        key_len: u32,
        iv_len: u32,
        keypad_len: u32,
        hash_iv_len: u32,
        ap: u32,
        cl: u32,
        priv_key: u32,
        otp_key: u32,
        ls: u32,
        fs: u32,
        rs: u32,
        rsvd: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let key_len: u32 = unsafe { ::core::mem::transmute(key_len) };
            key_len as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let iv_len: u32 = unsafe { ::core::mem::transmute(iv_len) };
            iv_len as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let keypad_len: u32 = unsafe { ::core::mem::transmute(keypad_len) };
            keypad_len as u64
        });
        __bindgen_bitfield_unit.set(16usize, 6u8, {
            let hash_iv_len: u32 = unsafe { ::core::mem::transmute(hash_iv_len) };
            hash_iv_len as u64
        });
        __bindgen_bitfield_unit.set(22usize, 2u8, {
            let ap: u32 = unsafe { ::core::mem::transmute(ap) };
            ap as u64
        });
        __bindgen_bitfield_unit.set(24usize, 2u8, {
            let cl: u32 = unsafe { ::core::mem::transmute(cl) };
            cl as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let priv_key: u32 = unsafe { ::core::mem::transmute(priv_key) };
            priv_key as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let otp_key: u32 = unsafe { ::core::mem::transmute(otp_key) };
            otp_key as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let ls: u32 = unsafe { ::core::mem::transmute(ls) };
            ls as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let fs: u32 = unsafe { ::core::mem::transmute(fs) };
            fs as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let rs: u32 = unsafe { ::core::mem::transmute(rs) };
            rs as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let rsvd: u32 = unsafe { ::core::mem::transmute(rsvd) };
            rsvd as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtl_crypto_srcdesc_t__bindgen_ty_2 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtl_crypto_srcdesc_t__bindgen_ty_2 {
    #[inline]
    pub fn apl(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_apl(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn a2eo(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_a2eo(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn zero(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_zero(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enl(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_enl(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn ls(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ls(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fs(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rs(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rsvd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        apl: u32,
        a2eo: u32,
        zero: u32,
        enl: u32,
        ls: u32,
        fs: u32,
        rs: u32,
        rsvd: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let apl: u32 = unsafe { ::core::mem::transmute(apl) };
            apl as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let a2eo: u32 = unsafe { ::core::mem::transmute(a2eo) };
            a2eo as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let zero: u32 = unsafe { ::core::mem::transmute(zero) };
            zero as u64
        });
        __bindgen_bitfield_unit.set(14usize, 14u8, {
            let enl: u32 = unsafe { ::core::mem::transmute(enl) };
            enl as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let ls: u32 = unsafe { ::core::mem::transmute(ls) };
            ls as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let fs: u32 = unsafe { ::core::mem::transmute(fs) };
            fs as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let rs: u32 = unsafe { ::core::mem::transmute(rs) };
            rs as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let rsvd: u32 = unsafe { ::core::mem::transmute(rsvd) };
            rsvd as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtl_crypto_srcdesc_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtl_crypto_srcdesc_t {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtl_crypto_srcdesc_t {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtl_crypto_dstdesc_t {
    pub auth: rtl_crypto_dstdesc_t__bindgen_ty_1,
    pub cipher: rtl_crypto_dstdesc_t__bindgen_ty_2,
    pub w: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtl_crypto_dstdesc_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtl_crypto_dstdesc_t__bindgen_ty_1 {
    #[inline]
    pub fn adl(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_adl(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 19u8) as u32) }
    }
    #[inline]
    pub fn set_rsvd1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 19u8, val as u64)
        }
    }
    #[inline]
    pub fn enc(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ls(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ls(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fs(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ws(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ws(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rsvd2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        adl: u32,
        rsvd1: u32,
        enc: u32,
        ls: u32,
        fs: u32,
        ws: u32,
        rsvd2: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let adl: u32 = unsafe { ::core::mem::transmute(adl) };
            adl as u64
        });
        __bindgen_bitfield_unit.set(8usize, 19u8, {
            let rsvd1: u32 = unsafe { ::core::mem::transmute(rsvd1) };
            rsvd1 as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let enc: u32 = unsafe { ::core::mem::transmute(enc) };
            enc as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let ls: u32 = unsafe { ::core::mem::transmute(ls) };
            ls as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let fs: u32 = unsafe { ::core::mem::transmute(fs) };
            fs as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let ws: u32 = unsafe { ::core::mem::transmute(ws) };
            ws as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let rsvd2: u32 = unsafe { ::core::mem::transmute(rsvd2) };
            rsvd2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtl_crypto_dstdesc_t__bindgen_ty_2 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl rtl_crypto_dstdesc_t__bindgen_ty_2 {
    #[inline]
    pub fn enl(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_enl(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_rsvd1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn enc(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ls(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ls(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fs(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ws(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ws(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rsvd2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enl: u32,
        rsvd1: u32,
        enc: u32,
        ls: u32,
        fs: u32,
        ws: u32,
        rsvd2: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let enl: u32 = unsafe { ::core::mem::transmute(enl) };
            enl as u64
        });
        __bindgen_bitfield_unit.set(24usize, 3u8, {
            let rsvd1: u32 = unsafe { ::core::mem::transmute(rsvd1) };
            rsvd1 as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let enc: u32 = unsafe { ::core::mem::transmute(enc) };
            enc as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let ls: u32 = unsafe { ::core::mem::transmute(ls) };
            ls as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let fs: u32 = unsafe { ::core::mem::transmute(fs) };
            fs as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let ws: u32 = unsafe { ::core::mem::transmute(ws) };
            ws as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let rsvd2: u32 = unsafe { ::core::mem::transmute(rsvd2) };
            rsvd2 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for rtl_crypto_dstdesc_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtl_crypto_dstdesc_t {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtl_crypto_dstdesc_t {{ union }}")
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtl_crypto_cl_struct_s {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 12usize]>,
    pub ap0: u32,
    pub ap1: u32,
    pub ap2: u32,
    pub ap3: u32,
}
impl rtl_crypto_cl_struct_s {
    #[inline]
    pub fn cipher_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_cipher_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn cipher_eng_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_cipher_eng_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rsvd1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cipher_encrypt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cipher_encrypt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn aes_key_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_aes_key_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn des3_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_des3_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn des3_type(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_des3_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ckbs(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ckbs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hmac_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hmac_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hmac_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_hmac_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn hmac_seq_hash_last(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hmac_seq_hash_last(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn engine_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_engine_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn hmac_seq_hash_first(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hmac_seq_hash_first(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hmac_seq_hash(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hmac_seq_hash(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hmac_seq_hash_no_wb(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hmac_seq_hash_no_wb(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn icv_total_length(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_icv_total_length(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn aad_last_data_size(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_aad_last_data_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn enc_last_data_size(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(36usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_enc_last_data_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(36usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn pad_last_data_size(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(40usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_pad_last_data_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(40usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn ckws(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(43usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ckws(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(43usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enc_pad_last_data_size(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(44usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_enc_pad_last_data_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(44usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn hsibs(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(47usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hsibs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(47usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn caws(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(48usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_caws(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(48usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cabs(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(49usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cabs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(49usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ciws(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(50usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ciws(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(50usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cibs(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(51usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cibs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(51usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cows(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(52usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cows(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(52usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cobs(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(53usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cobs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(53usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn codws(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(54usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_codws(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(54usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cidws(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(55usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cidws(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(55usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn haws(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(56usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_haws(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(56usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn habs(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(57usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_habs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(57usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hiws(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(58usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hiws(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(58usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hibs(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(59usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hibs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(59usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hows(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(60usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hows(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(60usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hobs(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(61usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hobs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(61usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hkws(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(62usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hkws(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(62usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hkbs(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hkbs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hash_pad_len(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(64usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_hash_pad_len(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(64usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn header_total_len(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(72usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_header_total_len(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(72usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn apl(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(78usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_apl(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(78usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn enl(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(80usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_enl(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(80usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cipher_mode: u32,
        cipher_eng_sel: u32,
        rsvd1: u32,
        cipher_encrypt: u32,
        aes_key_sel: u32,
        des3_en: u32,
        des3_type: u32,
        ckbs: u32,
        hmac_en: u32,
        hmac_mode: u32,
        hmac_seq_hash_last: u32,
        engine_mode: u32,
        hmac_seq_hash_first: u32,
        hmac_seq_hash: u32,
        hmac_seq_hash_no_wb: u32,
        icv_total_length: u32,
        aad_last_data_size: u32,
        enc_last_data_size: u32,
        pad_last_data_size: u32,
        ckws: u32,
        enc_pad_last_data_size: u32,
        hsibs: u32,
        caws: u32,
        cabs: u32,
        ciws: u32,
        cibs: u32,
        cows: u32,
        cobs: u32,
        codws: u32,
        cidws: u32,
        haws: u32,
        habs: u32,
        hiws: u32,
        hibs: u32,
        hows: u32,
        hobs: u32,
        hkws: u32,
        hkbs: u32,
        hash_pad_len: u32,
        header_total_len: u32,
        apl: u32,
        enl: u32,
    ) -> __BindgenBitfieldUnit<[u8; 12usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 12usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let cipher_mode: u32 = unsafe { ::core::mem::transmute(cipher_mode) };
            cipher_mode as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let cipher_eng_sel: u32 = unsafe { ::core::mem::transmute(cipher_eng_sel) };
            cipher_eng_sel as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let rsvd1: u32 = unsafe { ::core::mem::transmute(rsvd1) };
            rsvd1 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let cipher_encrypt: u32 = unsafe { ::core::mem::transmute(cipher_encrypt) };
            cipher_encrypt as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let aes_key_sel: u32 = unsafe { ::core::mem::transmute(aes_key_sel) };
            aes_key_sel as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let des3_en: u32 = unsafe { ::core::mem::transmute(des3_en) };
            des3_en as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let des3_type: u32 = unsafe { ::core::mem::transmute(des3_type) };
            des3_type as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let ckbs: u32 = unsafe { ::core::mem::transmute(ckbs) };
            ckbs as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let hmac_en: u32 = unsafe { ::core::mem::transmute(hmac_en) };
            hmac_en as u64
        });
        __bindgen_bitfield_unit.set(14usize, 3u8, {
            let hmac_mode: u32 = unsafe { ::core::mem::transmute(hmac_mode) };
            hmac_mode as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let hmac_seq_hash_last: u32 = unsafe { ::core::mem::transmute(hmac_seq_hash_last) };
            hmac_seq_hash_last as u64
        });
        __bindgen_bitfield_unit.set(18usize, 3u8, {
            let engine_mode: u32 = unsafe { ::core::mem::transmute(engine_mode) };
            engine_mode as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let hmac_seq_hash_first: u32 = unsafe { ::core::mem::transmute(hmac_seq_hash_first) };
            hmac_seq_hash_first as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let hmac_seq_hash: u32 = unsafe { ::core::mem::transmute(hmac_seq_hash) };
            hmac_seq_hash as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let hmac_seq_hash_no_wb: u32 = unsafe { ::core::mem::transmute(hmac_seq_hash_no_wb) };
            hmac_seq_hash_no_wb as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let icv_total_length: u32 = unsafe { ::core::mem::transmute(icv_total_length) };
            icv_total_length as u64
        });
        __bindgen_bitfield_unit.set(32usize, 4u8, {
            let aad_last_data_size: u32 = unsafe { ::core::mem::transmute(aad_last_data_size) };
            aad_last_data_size as u64
        });
        __bindgen_bitfield_unit.set(36usize, 4u8, {
            let enc_last_data_size: u32 = unsafe { ::core::mem::transmute(enc_last_data_size) };
            enc_last_data_size as u64
        });
        __bindgen_bitfield_unit.set(40usize, 3u8, {
            let pad_last_data_size: u32 = unsafe { ::core::mem::transmute(pad_last_data_size) };
            pad_last_data_size as u64
        });
        __bindgen_bitfield_unit.set(43usize, 1u8, {
            let ckws: u32 = unsafe { ::core::mem::transmute(ckws) };
            ckws as u64
        });
        __bindgen_bitfield_unit.set(44usize, 3u8, {
            let enc_pad_last_data_size: u32 =
                unsafe { ::core::mem::transmute(enc_pad_last_data_size) };
            enc_pad_last_data_size as u64
        });
        __bindgen_bitfield_unit.set(47usize, 1u8, {
            let hsibs: u32 = unsafe { ::core::mem::transmute(hsibs) };
            hsibs as u64
        });
        __bindgen_bitfield_unit.set(48usize, 1u8, {
            let caws: u32 = unsafe { ::core::mem::transmute(caws) };
            caws as u64
        });
        __bindgen_bitfield_unit.set(49usize, 1u8, {
            let cabs: u32 = unsafe { ::core::mem::transmute(cabs) };
            cabs as u64
        });
        __bindgen_bitfield_unit.set(50usize, 1u8, {
            let ciws: u32 = unsafe { ::core::mem::transmute(ciws) };
            ciws as u64
        });
        __bindgen_bitfield_unit.set(51usize, 1u8, {
            let cibs: u32 = unsafe { ::core::mem::transmute(cibs) };
            cibs as u64
        });
        __bindgen_bitfield_unit.set(52usize, 1u8, {
            let cows: u32 = unsafe { ::core::mem::transmute(cows) };
            cows as u64
        });
        __bindgen_bitfield_unit.set(53usize, 1u8, {
            let cobs: u32 = unsafe { ::core::mem::transmute(cobs) };
            cobs as u64
        });
        __bindgen_bitfield_unit.set(54usize, 1u8, {
            let codws: u32 = unsafe { ::core::mem::transmute(codws) };
            codws as u64
        });
        __bindgen_bitfield_unit.set(55usize, 1u8, {
            let cidws: u32 = unsafe { ::core::mem::transmute(cidws) };
            cidws as u64
        });
        __bindgen_bitfield_unit.set(56usize, 1u8, {
            let haws: u32 = unsafe { ::core::mem::transmute(haws) };
            haws as u64
        });
        __bindgen_bitfield_unit.set(57usize, 1u8, {
            let habs: u32 = unsafe { ::core::mem::transmute(habs) };
            habs as u64
        });
        __bindgen_bitfield_unit.set(58usize, 1u8, {
            let hiws: u32 = unsafe { ::core::mem::transmute(hiws) };
            hiws as u64
        });
        __bindgen_bitfield_unit.set(59usize, 1u8, {
            let hibs: u32 = unsafe { ::core::mem::transmute(hibs) };
            hibs as u64
        });
        __bindgen_bitfield_unit.set(60usize, 1u8, {
            let hows: u32 = unsafe { ::core::mem::transmute(hows) };
            hows as u64
        });
        __bindgen_bitfield_unit.set(61usize, 1u8, {
            let hobs: u32 = unsafe { ::core::mem::transmute(hobs) };
            hobs as u64
        });
        __bindgen_bitfield_unit.set(62usize, 1u8, {
            let hkws: u32 = unsafe { ::core::mem::transmute(hkws) };
            hkws as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let hkbs: u32 = unsafe { ::core::mem::transmute(hkbs) };
            hkbs as u64
        });
        __bindgen_bitfield_unit.set(64usize, 8u8, {
            let hash_pad_len: u32 = unsafe { ::core::mem::transmute(hash_pad_len) };
            hash_pad_len as u64
        });
        __bindgen_bitfield_unit.set(72usize, 6u8, {
            let header_total_len: u32 = unsafe { ::core::mem::transmute(header_total_len) };
            header_total_len as u64
        });
        __bindgen_bitfield_unit.set(78usize, 2u8, {
            let apl: u32 = unsafe { ::core::mem::transmute(apl) };
            apl as u64
        });
        __bindgen_bitfield_unit.set(80usize, 16u8, {
            let enl: u32 = unsafe { ::core::mem::transmute(enl) };
            enl as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type rtl_crypto_cl_t = rtl_crypto_cl_struct_s;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HAL_CRYPTO_ADAPTER_ {
    pub isInit: u8,
    pub isIntMode: u8,
    pub cipher_type: u32,
    pub des: u8,
    pub trides: u8,
    pub aes: u8,
    pub chacha: u8,
    pub isDecrypt: u8,
    pub auth_type: u32,
    pub isHMAC: u8,
    pub isMD5: u8,
    pub isSHA1: u8,
    pub isSHA2: u8,
    pub sha2type: u8,
    pub enc_last_data_size: u32,
    pub aad_last_data_size: u32,
    pub lenAuthKey: u32,
    pub pAuthKey: *const u8,
    pub digestlen: u32,
    pub hmac_seq_hash_first: u8,
    pub hmac_seq_hash_last: u8,
    pub hmac_seq_hash_total_len: u32,
    pub hmac_seq_is_recorded: u8,
    pub hmac_seq_last_message: *mut u8,
    pub hmac_seq_last_msglen: u32,
    pub hmac_seq_buf_is_used_bytes: u8,
    pub lenCipherKey: u32,
    pub pCipherKey: *const u8,
    pub a2eo: u32,
    pub apl_aad: u32,
    pub enl: u32,
    pub apl: u32,
    pub ipad: *mut u8,
    pub opad: *mut u8,
    pub g_IOPAD: [u8; 132usize],
    pub gcm_iv: [u8; 32usize],
    pub cl_buffer: [u8; 32usize],
    pub hmac_seq_buf: [u8; 64usize],
}
impl Default for _HAL_CRYPTO_ADAPTER_ {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for _HAL_CRYPTO_ADAPTER_ {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "_HAL_CRYPTO_ADAPTER_ {{ isInit: {:?}, isIntMode: {:?}, cipher_type: {:?}, des: {:?}, trides: {:?}, aes: {:?}, chacha: {:?}, isDecrypt: {:?}, auth_type: {:?}, isHMAC: {:?}, isMD5: {:?}, isSHA1: {:?}, isSHA2: {:?}, sha2type: {:?}, enc_last_data_size: {:?}, aad_last_data_size: {:?}, lenAuthKey: {:?}, pAuthKey: {:?}, digestlen: {:?}, hmac_seq_hash_first: {:?}, hmac_seq_hash_last: {:?}, hmac_seq_hash_total_len: {:?}, hmac_seq_is_recorded: {:?}, hmac_seq_last_message: {:?}, hmac_seq_last_msglen: {:?}, hmac_seq_buf_is_used_bytes: {:?}, lenCipherKey: {:?}, pCipherKey: {:?}, a2eo: {:?}, apl_aad: {:?}, enl: {:?}, apl: {:?}, ipad: {:?}, opad: {:?}, g_IOPAD: [...], gcm_iv: [...], cl_buffer: [...], hmac_seq_buf: [...] }}" , self . isInit , self . isIntMode , self . cipher_type , self . des , self . trides , self . aes , self . chacha , self . isDecrypt , self . auth_type , self . isHMAC , self . isMD5 , self . isSHA1 , self . isSHA2 , self . sha2type , self . enc_last_data_size , self . aad_last_data_size , self . lenAuthKey , self . pAuthKey , self . digestlen , self . hmac_seq_hash_first , self . hmac_seq_hash_last , self . hmac_seq_hash_total_len , self . hmac_seq_is_recorded , self . hmac_seq_last_message , self . hmac_seq_last_msglen , self . hmac_seq_buf_is_used_bytes , self . lenCipherKey , self . pCipherKey , self . a2eo , self . apl_aad , self . enl , self . apl , self . ipad , self . opad)
    }
}
pub type HAL_CRYPTO_ADAPTER = _HAL_CRYPTO_ADAPTER_;
pub type PHAL_CRYPTO_ADAPTER = *mut _HAL_CRYPTO_ADAPTER_;
pub const _SHA2_TYPE__SHA2_NONE: _SHA2_TYPE_ = 0;
pub const _SHA2_TYPE__SHA2_224: _SHA2_TYPE_ = 28;
pub const _SHA2_TYPE__SHA2_256: _SHA2_TYPE_ = 32;
pub const _SHA2_TYPE__SHA2_384: _SHA2_TYPE_ = 48;
pub const _SHA2_TYPE__SHA2_512: _SHA2_TYPE_ = 64;
pub type _SHA2_TYPE_ = ffi::ctypes::c_uint;
pub use self::_SHA2_TYPE_ as SHA2_TYPE;
extern "C" {
    pub fn CRYPTO_MemDump(start: *const u8, size: u32, strHeader: *mut ffi::ctypes::c_char);
}
extern "C" {
    pub fn CRYPTO_RegDump();
}
extern "C" {
    pub fn CRYPTO_CleanCmdOk();
}
extern "C" {
    pub fn CRYPTO_ClearAllINT();
}
extern "C" {
    pub fn CRYPTO_Reset(pIE: *mut HAL_CRYPTO_ADAPTER);
}
extern "C" {
    pub fn CRYPTO_SetSecurityModeAD(
        pIE: *mut HAL_CRYPTO_ADAPTER,
        cipher_type: u32,
        auth_type: u32,
        pCipherKey: *const ffi::ctypes::c_void,
        lenCipherKey: u32,
        pAuthKey: *const ffi::ctypes::c_void,
        lenAuthKey: u32,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn CRYPTO_Init(pIE: *mut HAL_CRYPTO_ADAPTER) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn CRYPTO_ProcessAD(
        pIE: *mut HAL_CRYPTO_ADAPTER,
        message: *const u8,
        msglen: u32,
        pIv: *const u8,
        ivlen: u32,
        paad: *const u8,
        aadlen: u32,
        pResult: *mut u8,
        pTag: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn CRYPTO_CipherInit(
        pIE: *mut HAL_CRYPTO_ADAPTER,
        cipher_type: u32,
        key: *const u8,
        keylen: u32,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn CRYPTO_CipherEncryptAD(
        pIE: *mut HAL_CRYPTO_ADAPTER,
        message: *const u8,
        msglen: u32,
        piv: *const u8,
        ivlen: u32,
        paad: *const u8,
        aadlen: u32,
        pResult: *mut u8,
        pTag: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn CRYPTO_CipherDecryptAD(
        pIE: *mut HAL_CRYPTO_ADAPTER,
        message: *const u8,
        msglen: u32,
        piv: *const u8,
        ivlen: u32,
        paad: *const u8,
        aadlen: u32,
        pResult: *mut u8,
        pTag: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn CRYPTO_SendSeqBuf(pDigest: *mut u8) -> ffi::ctypes::c_int;
}
extern "C" {
    pub static mut crypto_engine: HAL_CRYPTO_ADAPTER;
}
extern "C" {
    pub static mut driver_call_os_func_map: _driver_call_os_func_map;
}
extern "C" {
    pub fn rtl_crypto_md5(message: *const u8, msglen: u32, pDigest: *mut u8) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_md5_init() -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_md5_process(
        message: *const u8,
        msglen: u32,
        pDigest: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_md5_update(message: *const u8, msglen: u32) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_md5_final(pDigest: *mut u8) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_sha1(message: *const u8, msglen: u32, pDigest: *mut u8)
        -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_sha1_init() -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_sha1_process(
        message: *const u8,
        msglen: u32,
        pDigest: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_sha1_update(message: *const u8, msglen: u32) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_sha1_final(pDigest: *mut u8) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_sha2(
        sha2type: SHA2_TYPE,
        message: *const u8,
        msglen: u32,
        pDigest: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_sha2_init(sha2type: SHA2_TYPE) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_sha2_process(
        message: *const u8,
        msglen: u32,
        pDigest: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_sha2_update(message: *const u8, msglen: u32) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_sha2_final(pDigest: *mut u8) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_hmac_md5(
        message: *const u8,
        msglen: u32,
        key: *const u8,
        keylen: u32,
        pDigest: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_hmac_md5_init(key: *const u8, keylen: u32) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_hmac_md5_process(
        message: *const u8,
        msglen: u32,
        pDigest: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_hmac_md5_update(message: *const u8, msglen: u32) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_hmac_md5_final(pDigest: *mut u8) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_hmac_sha1(
        message: *const u8,
        msglen: u32,
        key: *const u8,
        keylen: u32,
        pDigest: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_hmac_sha1_start(key: *const u8, keylen: u32) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_hmac_sha1_init(key: *const u8, keylen: u32) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_hmac_sha1_process(
        message: *const u8,
        msglen: u32,
        pDigest: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_hmac_sha1_update(message: *const u8, msglen: u32) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_hmac_sha1_final(pDigest: *mut u8) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_hmac_sha2(
        sha2type: SHA2_TYPE,
        message: *const u8,
        msglen: u32,
        key: *const u8,
        keylen: u32,
        pDigest: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_hmac_sha2_start(key: *const u8, keylen: u32) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_hmac_sha2_init(
        sha2type: SHA2_TYPE,
        key: *const u8,
        keylen: u32,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_hmac_sha2_process(
        message: *const u8,
        msglen: u32,
        pDigest: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_hmac_sha2_update(message: *const u8, msglen: u32) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_hmac_sha2_final(pDigest: *mut u8) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_aes_cbc_init(key: *const u8, keylen: u32) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_aes_cbc_encrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_aes_cbc_decrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_aes_ecb_init(key: *const u8, keylen: u32) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_aes_ecb_encrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_aes_ecb_decrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_aes_ctr_init(key: *const u8, keylen: u32) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_aes_ctr_encrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_aes_ctr_decrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_aes_cfb_init(key: *const u8, keylen: u32) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_aes_cfb_encrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_aes_cfb_decrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_aes_ofb_init(key: *const u8, keylen: u32) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_aes_ofb_encrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_aes_ofb_decrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_aes_gcm_init(key: *const u8, keylen: u32) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_aes_gcm_encrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        aad: *const u8,
        aadlen: u32,
        pResult: *mut u8,
        pTag: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_aes_gcm_decrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        aad: *const u8,
        aadlen: u32,
        pResult: *mut u8,
        pTag: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_3des_cbc_init(key: *const u8, keylen: u32) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_3des_cbc_encrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_3des_cbc_decrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_3des_ecb_init(key: *const u8, keylen: u32) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_3des_ecb_encrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_3des_ecb_decrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_3des_ctr_init(key: *const u8, keylen: u32) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_3des_ctr_encrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_3des_ctr_decrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_3des_cfb_init(key: *const u8, keylen: u32) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_3des_cfb_encrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_3des_cfb_decrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_3des_ofb_init(key: *const u8, keylen: u32) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_3des_ofb_encrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_3des_ofb_decrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_des_cbc_init(key: *const u8, keylen: u32) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_des_cbc_encrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_des_cbc_decrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_des_ecb_init(key: *const u8, keylen: u32) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_des_ecb_encrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_des_ecb_decrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_des_ctr_init(key: *const u8, keylen: u32) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_des_ctr_encrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_des_ctr_decrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_des_cfb_init(key: *const u8, keylen: u32) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_des_cfb_encrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_des_cfb_decrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_des_ofb_init(key: *const u8, keylen: u32) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_des_ofb_encrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_des_ofb_decrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        ivlen: u32,
        pResult: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_poly1305_init(key: *const u8) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_poly1305_process(
        message: *const u8,
        msglen: u32,
        pDigest: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_poly1305(
        message: *const u8,
        msglen: u32,
        key: *const u8,
        pDigest: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_chacha_init(key: *const u8) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_chacha_encrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        count: u32,
        pResult: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_chacha_decrypt(
        message: *const u8,
        msglen: u32,
        iv: *const u8,
        count: u32,
        pResult: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_chacha_poly1305_init(key: *const u8) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_chacha_poly1305_encrypt(
        message: *const u8,
        msglen: u32,
        nonce: *const u8,
        aad: *const u8,
        aadlen: u32,
        pResult: *mut u8,
        pTag: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtl_crypto_chacha_poly1305_decrypt(
        message: *const u8,
        msglen: u32,
        nonce: *const u8,
        aad: *const u8,
        aadlen: u32,
        pResult: *mut u8,
        pTag: *mut u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub static mut __image1_validate_code__: [u8; 0usize];
}
extern "C" {
    pub static mut __image1_bss_start__: [u8; 0usize];
}
extern "C" {
    pub static mut __image1_bss_end__: [u8; 0usize];
}
extern "C" {
    pub static mut __image2_entry_func__: [u8; 0usize];
}
extern "C" {
    pub static mut __bss_start__: [u8; 0usize];
}
extern "C" {
    pub static mut __bss_end__: [u8; 0usize];
}
extern "C" {
    pub static mut __cmd_table_start__: [u8; 0usize];
}
extern "C" {
    pub static mut __cmd_table_end__: [u8; 0usize];
}
extern "C" {
    pub static mut __psram_bss_start__: [u8; 0usize];
}
extern "C" {
    pub static mut __psram_bss_end__: [u8; 0usize];
}
extern "C" {
    pub static mut __ram_nocache_start__: [u8; 0usize];
}
extern "C" {
    pub static mut __ram_nocache_end__: [u8; 0usize];
}
extern "C" {
    pub static mut __image3_bss_start__: [u8; 0usize];
}
extern "C" {
    pub static mut __image3_bss_end__: [u8; 0usize];
}
extern "C" {
    pub static mut __rom_bss_start__: [u8; 0usize];
}
extern "C" {
    pub static mut __rom_bss_end__: [u8; 0usize];
}
extern "C" {
    pub static mut __rom_bss_start_s__: [u8; 0usize];
}
extern "C" {
    pub static mut __rom_bss_end_s__: [u8; 0usize];
}
extern "C" {
    pub static mut __rom_bss_start_ns__: [u8; 0usize];
}
extern "C" {
    pub static mut __rom_bss_end_ns__: [u8; 0usize];
}
extern "C" {
    pub static mut __ram_image3_start__: [u8; 0usize];
}
extern "C" {
    pub static mut __ram_image3_end__: [u8; 0usize];
}
extern "C" {
    pub static mut __psram_image3_start__: [u8; 0usize];
}
extern "C" {
    pub static mut __psram_image3_end__: [u8; 0usize];
}
extern "C" {
    pub static mut __flash_text_start__: [u8; 0usize];
}
extern "C" {
    pub static mut __flash_img2_end__: [u8; 0usize];
}
extern "C" {
    pub static mut __flash_sec_text_start__: [u8; 0usize];
}
extern "C" {
    pub static mut __ram_start_table_start__: [u8; 0usize];
}
extern "C" {
    pub static mut __rom_top_4k_start_: [u8; 0usize];
}
extern "C" {
    pub static mut __rom_entry_ns_start__: [u8; 0usize];
}
extern "C" {
    pub static mut __retention_entry_func__: [u8; 0usize];
}
pub const _BOOT_TYPE__BOOT_FROM_FLASH: _BOOT_TYPE_ = 0;
pub const _BOOT_TYPE__BOOT_FROM_SDIO: _BOOT_TYPE_ = 1;
pub const _BOOT_TYPE__BOOT_FROM_USB: _BOOT_TYPE_ = 2;
pub const _BOOT_TYPE__BOOT_FROM_UART0: _BOOT_TYPE_ = 3;
pub const _BOOT_TYPE__BOOT_FROM_UART1: _BOOT_TYPE_ = 4;
pub const _BOOT_TYPE__BOOT_FROM_SPI: _BOOT_TYPE_ = 5;
pub const _BOOT_TYPE__BOOT_FROM_RSVD: _BOOT_TYPE_ = 6;
pub type _BOOT_TYPE_ = ffi::ctypes::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ROM_SECURE_CALL_NS_ENTRY {
    pub ed25519_verify_signature: ::core::option::Option<
        unsafe extern "C" fn(
            sig: *const ffi::ctypes::c_uchar,
            m: *const ffi::ctypes::c_uchar,
            mlen: ffi::ctypes::c_ulonglong,
            pk: *const ffi::ctypes::c_uchar,
        ) -> ffi::ctypes::c_int,
    >,
    pub clear_ns_rom_bss: ::core::option::Option<unsafe extern "C" fn()>,
}
pub const _CPU_PWRSEQ__CPU_PWRSEQ_CMD_READ: _CPU_PWRSEQ_ = 4294967040;
pub const _CPU_PWRSEQ__CPU_PWRSEQ_CMD_WRITE: _CPU_PWRSEQ_ = 4294967041;
pub const _CPU_PWRSEQ__CPU_PWRSEQ_CMD_POLLING: _CPU_PWRSEQ_ = 4294967042;
pub const _CPU_PWRSEQ__CPU_PWRSEQ_CMD_DELAY: _CPU_PWRSEQ_ = 4294967043;
pub const _CPU_PWRSEQ__CPU_PWRSEQ_CMD_LOGE: _CPU_PWRSEQ_ = 4294967048;
pub const _CPU_PWRSEQ__CPU_PWRSEQ_CMD_END: _CPU_PWRSEQ_ = 4294967295;
pub type _CPU_PWRSEQ_ = ffi::ctypes::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CPU_PWR_SEQ {
    pub address: u32,
    pub cmd: u32,
    pub bitsc: u32,
    pub bitss: u32,
}
pub const Image_Type_IMG_LS_BOOT: Image_Type = 0;
pub const Image_Type_IMG_BACKUP: Image_Type = 1;
pub const Image_Type_IMG_SYSDATA: Image_Type = 2;
pub const Image_Type_IMG_HS_BOOT: Image_Type = 3;
pub const Image_Type_IMG_LS_IMG2_OTA1: Image_Type = 4;
pub const Image_Type_IMG_HS_IMG_COMB_OTA1: Image_Type = 5;
pub const Image_Type_IMG_LS_IMG2_OTA2: Image_Type = 6;
pub const Image_Type_IMG_HS_IMG_COMB_OTA2: Image_Type = 7;
pub type Image_Type = ffi::ctypes::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MMU_ConfDef {
    pub VAddrStart: u32,
    pub VAddrEnd: u32,
    pub PAddrStart: u32,
    pub PAddrEnd: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct RSIP_MaskDef {
    pub MaskAddr: u32,
    pub MaskSize: u16,
}
pub type FuncPtr = ::core::option::Option<unsafe extern "C" fn() -> u8>;
extern "C" {
    pub fn SysTick_Handler();
}
extern "C" {
    pub fn SVC_Handler();
}
extern "C" {
    pub fn PendSV_Handler();
}
extern "C" {
    pub fn BOOT_ROM_CM4PON(pwr_cmd_addr: u32) -> u32;
}
extern "C" {
    pub fn BOOT_FLASH_Image1();
}
extern "C" {
    pub fn BOOT_FLASH_WakeFromPG();
}
extern "C" {
    pub fn BOOT_RAM_FuncEnable();
}
extern "C" {
    pub fn BOOT_RAM_FLASH_Calibration(read_mode: u8) -> u32;
}
extern "C" {
    pub fn BOOT_RAM_SectionInit() -> PRAM_START_FUNCTION;
}
extern "C" {
    pub static mut ROM_SIM_ENABLE: u32;
}
extern "C" {
    pub static mut IS_FPGA_VERIF: u32;
}
extern "C" {
    pub static mut Img2EntryFun0: RAM_START_FUNCTION;
}
extern "C" {
    pub fn RSIP_Cmd(NewStatus: u32);
}
extern "C" {
    pub fn RSIP_OTF_init(IV: *mut u8);
}
extern "C" {
    pub fn RSIP_OTF_Cmd(NewStatus: u32);
}
extern "C" {
    pub fn RSIP_OTF_Mask(MaskIdx: u32, Addr: u32, Len: u32, NewStatus: u32);
}
extern "C" {
    pub fn RSIP_KEY_Request(KeyTypeBit: u32) -> u32;
}
extern "C" {
    pub fn RSIP_MMU_Config(
        MMUIdx: u32,
        AddrStart: u32,
        AddrEnd: u32,
        IsMinus: u32,
        AddrOffset: u32,
    );
}
extern "C" {
    pub fn RSIP_MMU_Cmd(MMUIdx: u32, NewStatus: u32);
}
pub const FlashClass_FlashClass1: FlashClass = 0;
pub const FlashClass_FlashClass2: FlashClass = 1;
pub const FlashClass_FlashClass3: FlashClass = 2;
pub const FlashClass_FlashClass4: FlashClass = 3;
pub const FlashClass_FlashClass5: FlashClass = 4;
pub const FlashClass_FlashClass6: FlashClass = 5;
pub const FlashClass_FlashClassUser: FlashClass = 254;
pub const FlashClass_FlashClassNone: FlashClass = 255;
pub type FlashClass = ffi::ctypes::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FlashInfo_TypeDef {
    pub flash_id: u32,
    pub id_mask: u32,
    pub flash_class: u8,
    pub sta_mask: u32,
    pub FlashInitHandler: ::core::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FLASH_CLK_Phase {
    pub phase_int: u8,
    pub phase_frac: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FLASH_CLK_Div {
    pub div_int: u8,
    pub div_frac: u8,
}
extern "C" {
    pub static mut NEW_CALIBREATION_END: [u8; 0usize];
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FLASH_InitTypeDef {
    pub FLASH_Id: u32,
    pub FLASH_cur_bitmode: u8,
    pub FLASH_baud_rate: u8,
    pub FLASH_baud_boot: u8,
    pub FLASH_cur_cmd: u32,
    pub FLASH_QuadEn_bit: u32,
    pub FLASH_Busy_bit: u32,
    pub FLASH_WLE_bit: u32,
    pub FLASH_Status2_exist: u32,
    pub FLASH_rd_sample_phase_cal: u8,
    pub FLASH_rd_sample_phase: u8,
    pub FLASH_rd_dummy_cyle: [u8; 3usize],
    pub FLASH_rd_dual_o: u32,
    pub FLASH_rd_dual_io: u32,
    pub FLASH_rd_quad_o: u32,
    pub FLASH_rd_quad_io: u32,
    pub FLASH_wr_dual_i: u32,
    pub FLASH_wr_dual_ii: u32,
    pub FLASH_wr_quad_i: u32,
    pub FLASH_wr_quad_ii: u32,
    pub FALSH_dual_valid_cmd: u32,
    pub FALSH_quad_valid_cmd: u32,
    pub FLASH_cmd_wr_en: u8,
    pub FLASH_cmd_rd_id: u8,
    pub FLASH_cmd_rd_status: u8,
    pub FLASH_cmd_rd_status2: u8,
    pub FLASH_cmd_wr_status: u8,
    pub FLASH_cmd_wr_status2: u8,
    pub FLASH_cmd_chip_e: u8,
    pub FLASH_cmd_block_e: u8,
    pub FLASH_cmd_sector_e: u8,
    pub FLASH_cmd_pwdn_release: u8,
    pub FLASH_cmd_pwdn: u8,
    pub debug: u8,
    pub phase_shift_idx: u8,
    pub FLASH_addr_phase_len: u8,
    pub FLASH_pseudo_prm_en: u8,
    pub FLASH_pinmux: u8,
    pub FLASH_rd_fast_single: u32,
}
extern "C" {
    pub fn FLASH_Erase(EraseType: u32, Address: u32);
}
extern "C" {
    pub fn FLASH_SetStatus(Cmd: u8, Len: u32, Status: *mut u8);
}
extern "C" {
    pub fn FLASH_SetStatusBits(SetBits: u32, NewState: u32);
}
extern "C" {
    pub fn FLASH_WaitBusy(WaitType: u32);
}
extern "C" {
    pub fn FLASH_WriteEn();
}
extern "C" {
    pub fn FLASH_TxCmd(cmd: u8, DataPhaseLen: u8, pData: *mut u8);
}
extern "C" {
    pub fn FLASH_RxCmd(cmd: u8, read_len: u32, read_data: *mut u8);
}
extern "C" {
    pub fn FLASH_StructInit(FLASH_InitStruct: *mut FLASH_InitTypeDef);
}
extern "C" {
    pub fn FLASH_StructInit_Micron(FLASH_InitStruct: *mut FLASH_InitTypeDef);
}
extern "C" {
    pub fn FLASH_StructInit_MXIC(FLASH_InitStruct: *mut FLASH_InitTypeDef);
}
extern "C" {
    pub fn FLASH_StructInit_GD(FLASH_InitStruct: *mut FLASH_InitTypeDef);
}
extern "C" {
    pub fn FLASH_Init(SpicBitMode: u8) -> u8;
}
extern "C" {
    pub fn FLASH_SetSpiMode(FLASH_InitStruct: *mut FLASH_InitTypeDef, SpicBitMode: u8);
}
extern "C" {
    pub fn FLASH_DeepPowerDown(NewState: u32);
}
extern "C" {
    pub fn FLASH_TxData256B(StartAddr: u32, DataPhaseLen: u32, pData: *mut u8);
}
extern "C" {
    pub fn FLASH_TxData12B(StartAddr: u32, DataPhaseLen: u8, pData: *mut u8);
}
extern "C" {
    pub fn FLASH_RxData(cmd: u8, StartAddr: u32, read_len: u32, read_data: *mut u8);
}
extern "C" {
    pub fn FLASH_Calibration(
        FLASH_InitStruct: *mut FLASH_InitTypeDef,
        SpicBitMode: u8,
        LineDelay: u8,
    ) -> u32;
}
extern "C" {
    pub fn FLASH_ClockDiv(Div: u8) -> u32;
}
extern "C" {
    pub fn FLASH_CalibrationNew(
        FLASH_InitStruct: *mut FLASH_InitTypeDef,
        SpicBitMode: u8,
        Div: u8,
        CalStep: u8,
        LineDelay: u8,
        StartIdx: u8,
    ) -> u32;
}
extern "C" {
    pub fn FLASH_CalibrationNewCmd(NewStatus: u32) -> u32;
}
extern "C" {
    pub fn FLASH_CalibrationPhaseIdx(phase_idx: u8) -> u32;
}
extern "C" {
    pub fn FLASH_CalibrationPhase(phase_int: u8, phase_sel: u8) -> u32;
}
extern "C" {
    pub fn FLASH_Calibration500MPSCmd(NewStatus: u32) -> u32;
}
extern "C" {
    pub fn FLASH_CalibrationInit(CalibrationEnd: u8) -> u32;
}
extern "C" {
    pub fn FLASH_ClockSwitch(Source: u32, Protection: u32);
}
extern "C" {
    pub fn FLASH_WriteStream(address: u32, len: u32, data: *mut u8) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn FLASH_Write_Lock();
}
extern "C" {
    pub fn FLASH_Write_Unlock();
}
extern "C" {
    pub fn FLASH_RxCmdXIP(cmd: u8, read_len: u32, read_data: *mut u8);
}
extern "C" {
    pub fn FLASH_SetStatusXIP(Cmd: u8, Len: u32, Status: *mut u8);
}
extern "C" {
    pub fn FLASH_SetStatusBitsXIP(SetBits: u32, NewState: u32);
}
extern "C" {
    pub fn FLASH_TxData12BXIP(StartAddr: u32, DataPhaseLen: u8, pData: *mut u8);
}
extern "C" {
    pub fn FLASH_TxData256BXIP(StartAddr: u32, DataPhaseLen: u32, pData: *mut u8);
}
extern "C" {
    pub fn FLASH_EraseXIP(EraseType: u32, Address: u32);
}
extern "C" {
    pub fn FLASH_EreaseDwordsXIP(address: u32, dword_num: u32);
}
extern "C" {
    pub fn FLASH_Write_IPC_Int(Data: *mut ffi::ctypes::c_void, IrqStatus: u32, ChanNum: u32);
}
extern "C" {
    pub static mut flash_init_para: FLASH_InitTypeDef;
}
extern "C" {
    pub static mut SPIC_CALIB_PATTERN: [u32; 2usize];
}
pub type FLASH_STRUCT_INIT_FUNC =
    ::core::option::Option<unsafe extern "C" fn(FLASH_InitStruct: *mut FLASH_InitTypeDef)>;
extern "C" {
    pub fn BKUP_Write(DwordIdx: u32, WriteVal: u32);
}
extern "C" {
    pub fn BKUP_Read(DwordIdx: u32) -> u32;
}
extern "C" {
    pub fn BKUP_Set(DwordIdx: u32, BitMask: u32);
}
extern "C" {
    pub fn BKUP_Clear(DwordIdx: u32, BitMask: u32);
}
extern "C" {
    pub fn BOOT_Reason() -> u32;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PMAP_TypeDef {
    pub PinName: u32,
    pub FuncPuPd: u32,
    pub SleepPuPd: u32,
    pub DSleepPuPd: u32,
    pub LowPowerPin: u32,
}
extern "C" {
    pub fn pinmap_init();
}
extern "C" {
    pub fn pinmap_sleep();
}
extern "C" {
    pub fn pinmap_deepsleep();
}
extern "C" {
    pub fn pinmap_wake();
}
extern "C" {
    pub fn IPC_INTConfig(IPCx: *mut IPC_TypeDef, IPC_ChNum: u8, NewState: u32);
}
extern "C" {
    pub fn IPC_IERSet(IPCx: *mut IPC_TypeDef, IPC_Chs: u32);
}
extern "C" {
    pub fn IPC_IERGet(IPCx: *mut IPC_TypeDef) -> u32;
}
extern "C" {
    pub fn IPC_INTRequest(IPCx: *mut IPC_TypeDef, IPC_ChNum: u8);
}
extern "C" {
    pub fn IPC_INTClear(IPCx: *mut IPC_TypeDef, IPC_ChNum: u8);
}
extern "C" {
    pub fn IPC_INTGet(IPCx: *mut IPC_TypeDef) -> u32;
}
extern "C" {
    pub fn IPC_CPUID() -> u32;
}
extern "C" {
    pub fn IPC_INTHandler(Data: *mut ffi::ctypes::c_void) -> u32;
}
extern "C" {
    pub fn IPC_INTUserHandler(
        IPC_ChNum: u8,
        IrqHandler: *mut ffi::ctypes::c_void,
        IrqData: *mut ffi::ctypes::c_void,
    );
}
pub type IPC_IRQ_FUN = ::core::option::Option<
    unsafe extern "C" fn(Data: *mut ffi::ctypes::c_void, IrqStatus: u32, ChanNum: u32),
>;
pub const USER_MSG_TYP_DEF_IPC_USER_POINT: USER_MSG_TYP_DEF = 0;
pub const USER_MSG_TYP_DEF_IPC_USER_DATA: USER_MSG_TYP_DEF = 1;
pub type USER_MSG_TYP_DEF = ffi::ctypes::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IPC_INIT_TABLE_ {
    pub USER_MSG_TYPE: u32,
    pub func: ::core::option::Option<
        unsafe extern "C" fn(Data: *mut ffi::ctypes::c_void, IrqStatus: u32, ChanNum: u32),
    >,
    pub IrqData: *mut ffi::ctypes::c_void,
}
impl Default for _IPC_INIT_TABLE_ {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type IPC_INIT_TABLE = _IPC_INIT_TABLE_;
pub type PIPC_INIT_TABLE = *mut _IPC_INIT_TABLE_;
extern "C" {
    pub static mut ipc_init_config: [IPC_INIT_TABLE; 0usize];
}
extern "C" {
    pub fn PAD_CMD(PinName: u8, NewStatus: u8);
}
extern "C" {
    pub fn PAD_DrvStrength(PinName: u8, DrvStrength: u32);
}
extern "C" {
    pub fn PAD_PullCtrl(PinName: u8, PullType: u8);
}
extern "C" {
    pub fn Pinmux_Config(PinName: u8, PinFunc: u32);
}
extern "C" {
    pub fn Pinmux_ConfigGet(PinName: u8) -> u32;
}
extern "C" {
    pub fn Pinmux_UartLogCtrl(PinLocation: u32, Operation: BOOL);
}
extern "C" {
    pub fn Pinmux_SpicCtrl(PinLocation: u32, Operation: BOOL);
}
extern "C" {
    pub fn ipc_table_init();
}
extern "C" {
    pub fn ipc_send_message(IPC_ChNum: u8, Message: u32);
}
extern "C" {
    pub fn ipc_get_message(IPC_ChNum: u8) -> u32;
}
extern "C" {
    pub fn xmodem_img_write(
        ptr: *mut ffi::ctypes::c_char,
        wr_offset: ffi::ctypes::c_uint,
        frame_size: ffi::ctypes::c_uint,
    );
}
extern "C" {
    pub fn xmodem_img_download(uart_idx: u8);
}
extern "C" {
    pub fn RCC_PeriphClockCmd(APBPeriph: u32, APBPeriph_Clock: u32, NewState: u8);
}
extern "C" {
    pub fn RCC_WIFIClockCmd(NewState: u8);
}
extern "C" {
    pub fn RCC_PeriphClockSource_RTC(Xtal: u32);
}
extern "C" {
    pub fn RCC_PeriphClockSource_I2C(Idx: u32, Source: u32);
}
extern "C" {
    pub fn RCC_PeriphClockSource_QDEC(Idx: u32, Source: u32);
}
extern "C" {
    pub fn RCC_PeriphClockSource_UART(UARTx: *mut UART_TypeDef, Source: u32);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cmse_address_info_t {
    pub flags: cmse_address_info_t_cmse_address_info,
    pub value: ffi::ctypes::c_uint,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct cmse_address_info_t_cmse_address_info {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl cmse_address_info_t_cmse_address_info {
    #[inline]
    pub fn mpu_region(&self) -> ffi::ctypes::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_mpu_region(&mut self, val: ffi::ctypes::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn sau_region(&self) -> ffi::ctypes::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sau_region(&mut self, val: ffi::ctypes::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn mpu_region_valid(&self) -> ffi::ctypes::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mpu_region_valid(&mut self, val: ffi::ctypes::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sau_region_valid(&self) -> ffi::ctypes::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sau_region_valid(&mut self, val: ffi::ctypes::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn read_ok(&self) -> ffi::ctypes::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_read_ok(&mut self, val: ffi::ctypes::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn readwrite_ok(&self) -> ffi::ctypes::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_readwrite_ok(&mut self, val: ffi::ctypes::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nonsecure_read_ok(&self) -> ffi::ctypes::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nonsecure_read_ok(&mut self, val: ffi::ctypes::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nonsecure_readwrite_ok(&self) -> ffi::ctypes::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nonsecure_readwrite_ok(&mut self, val: ffi::ctypes::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn secure(&self) -> ffi::ctypes::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_secure(&mut self, val: ffi::ctypes::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn idau_region_valid(&self) -> ffi::ctypes::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_idau_region_valid(&mut self, val: ffi::ctypes::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn idau_region(&self) -> ffi::ctypes::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_idau_region(&mut self, val: ffi::ctypes::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mpu_region: ffi::ctypes::c_uint,
        sau_region: ffi::ctypes::c_uint,
        mpu_region_valid: ffi::ctypes::c_uint,
        sau_region_valid: ffi::ctypes::c_uint,
        read_ok: ffi::ctypes::c_uint,
        readwrite_ok: ffi::ctypes::c_uint,
        nonsecure_read_ok: ffi::ctypes::c_uint,
        nonsecure_readwrite_ok: ffi::ctypes::c_uint,
        secure: ffi::ctypes::c_uint,
        idau_region_valid: ffi::ctypes::c_uint,
        idau_region: ffi::ctypes::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let mpu_region: u32 = unsafe { ::core::mem::transmute(mpu_region) };
            mpu_region as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let sau_region: u32 = unsafe { ::core::mem::transmute(sau_region) };
            sau_region as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let mpu_region_valid: u32 = unsafe { ::core::mem::transmute(mpu_region_valid) };
            mpu_region_valid as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let sau_region_valid: u32 = unsafe { ::core::mem::transmute(sau_region_valid) };
            sau_region_valid as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let read_ok: u32 = unsafe { ::core::mem::transmute(read_ok) };
            read_ok as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let readwrite_ok: u32 = unsafe { ::core::mem::transmute(readwrite_ok) };
            readwrite_ok as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let nonsecure_read_ok: u32 = unsafe { ::core::mem::transmute(nonsecure_read_ok) };
            nonsecure_read_ok as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let nonsecure_readwrite_ok: u32 =
                unsafe { ::core::mem::transmute(nonsecure_readwrite_ok) };
            nonsecure_readwrite_ok as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let secure: u32 = unsafe { ::core::mem::transmute(secure) };
            secure as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let idau_region_valid: u32 = unsafe { ::core::mem::transmute(idau_region_valid) };
            idau_region_valid as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let idau_region: u32 = unsafe { ::core::mem::transmute(idau_region) };
            idau_region as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for cmse_address_info_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for cmse_address_info_t {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "cmse_address_info_t {{ union }}")
    }
}
pub type __cmse_fptr = ::core::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub fn cmse_check_address_range(
        arg1: *mut ffi::ctypes::c_void,
        arg2: size_t,
        arg3: ffi::ctypes::c_int,
    ) -> *mut ffi::ctypes::c_void;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union APSR_Type {
    pub b: APSR_Type__bindgen_ty_1,
    pub w: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct APSR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl APSR_Type__bindgen_ty_1 {
    #[inline]
    pub fn _reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set__reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn GE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_GE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn _reserved1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set__reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn Q(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Q(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn V(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_V(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn C(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_C(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Z(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Z(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn N(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_N(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        _reserved0: u32,
        GE: u32,
        _reserved1: u32,
        Q: u32,
        V: u32,
        C: u32,
        Z: u32,
        N: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let _reserved0: u32 = unsafe { ::core::mem::transmute(_reserved0) };
            _reserved0 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let GE: u32 = unsafe { ::core::mem::transmute(GE) };
            GE as u64
        });
        __bindgen_bitfield_unit.set(20usize, 7u8, {
            let _reserved1: u32 = unsafe { ::core::mem::transmute(_reserved1) };
            _reserved1 as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let Q: u32 = unsafe { ::core::mem::transmute(Q) };
            Q as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let V: u32 = unsafe { ::core::mem::transmute(V) };
            V as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let C: u32 = unsafe { ::core::mem::transmute(C) };
            C as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let Z: u32 = unsafe { ::core::mem::transmute(Z) };
            Z as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let N: u32 = unsafe { ::core::mem::transmute(N) };
            N as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for APSR_Type {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for APSR_Type {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "APSR_Type {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IPSR_Type {
    pub b: IPSR_Type__bindgen_ty_1,
    pub w: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct IPSR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl IPSR_Type__bindgen_ty_1 {
    #[inline]
    pub fn ISR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_ISR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn _reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set__reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ISR: u32, _reserved0: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 9u8, {
            let ISR: u32 = unsafe { ::core::mem::transmute(ISR) };
            ISR as u64
        });
        __bindgen_bitfield_unit.set(9usize, 23u8, {
            let _reserved0: u32 = unsafe { ::core::mem::transmute(_reserved0) };
            _reserved0 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for IPSR_Type {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for IPSR_Type {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "IPSR_Type {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xPSR_Type {
    pub b: xPSR_Type__bindgen_ty_1,
    pub w: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct xPSR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl xPSR_Type__bindgen_ty_1 {
    #[inline]
    pub fn ISR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_ISR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn _reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set__reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn GE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_GE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn _reserved1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set__reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn T(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_T(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_IT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn Q(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Q(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn V(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_V(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn C(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_C(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Z(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Z(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn N(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_N(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ISR: u32,
        _reserved0: u32,
        GE: u32,
        _reserved1: u32,
        T: u32,
        IT: u32,
        Q: u32,
        V: u32,
        C: u32,
        Z: u32,
        N: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 9u8, {
            let ISR: u32 = unsafe { ::core::mem::transmute(ISR) };
            ISR as u64
        });
        __bindgen_bitfield_unit.set(9usize, 7u8, {
            let _reserved0: u32 = unsafe { ::core::mem::transmute(_reserved0) };
            _reserved0 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let GE: u32 = unsafe { ::core::mem::transmute(GE) };
            GE as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let _reserved1: u32 = unsafe { ::core::mem::transmute(_reserved1) };
            _reserved1 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let T: u32 = unsafe { ::core::mem::transmute(T) };
            T as u64
        });
        __bindgen_bitfield_unit.set(25usize, 2u8, {
            let IT: u32 = unsafe { ::core::mem::transmute(IT) };
            IT as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let Q: u32 = unsafe { ::core::mem::transmute(Q) };
            Q as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let V: u32 = unsafe { ::core::mem::transmute(V) };
            V as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let C: u32 = unsafe { ::core::mem::transmute(C) };
            C as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let Z: u32 = unsafe { ::core::mem::transmute(Z) };
            Z as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let N: u32 = unsafe { ::core::mem::transmute(N) };
            N as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for xPSR_Type {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for xPSR_Type {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "xPSR_Type {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CONTROL_Type {
    pub b: CONTROL_Type__bindgen_ty_1,
    pub w: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct CONTROL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl CONTROL_Type__bindgen_ty_1 {
    #[inline]
    pub fn nPRIV(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nPRIV(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SPSEL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SPSEL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FPCA(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FPCA(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SFPA(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SFPA(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _reserved1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set__reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        nPRIV: u32,
        SPSEL: u32,
        FPCA: u32,
        SFPA: u32,
        _reserved1: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let nPRIV: u32 = unsafe { ::core::mem::transmute(nPRIV) };
            nPRIV as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let SPSEL: u32 = unsafe { ::core::mem::transmute(SPSEL) };
            SPSEL as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let FPCA: u32 = unsafe { ::core::mem::transmute(FPCA) };
            FPCA as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let SFPA: u32 = unsafe { ::core::mem::transmute(SFPA) };
            SFPA as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let _reserved1: u32 = unsafe { ::core::mem::transmute(_reserved1) };
            _reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for CONTROL_Type {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for CONTROL_Type {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "CONTROL_Type {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NVIC_Type {
    pub ISER: [u32; 16usize],
    pub RESERVED0: [u32; 16usize],
    pub ICER: [u32; 16usize],
    pub RSERVED1: [u32; 16usize],
    pub ISPR: [u32; 16usize],
    pub RESERVED2: [u32; 16usize],
    pub ICPR: [u32; 16usize],
    pub RESERVED3: [u32; 16usize],
    pub IABR: [u32; 16usize],
    pub RESERVED4: [u32; 16usize],
    pub ITNS: [u32; 16usize],
    pub RESERVED5: [u32; 16usize],
    pub IPR: [u8; 496usize],
    pub RESERVED6: [u32; 580usize],
    pub STIR: u32,
}
impl Default for NVIC_Type {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for NVIC_Type {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "NVIC_Type {{ ISER: {:?}, RESERVED0: {:?}, ICER: {:?}, RSERVED1: {:?}, ISPR: {:?}, RESERVED2: {:?}, ICPR: {:?}, RESERVED3: {:?}, IABR: {:?}, RESERVED4: {:?}, ITNS: {:?}, RESERVED5: {:?}, IPR: [...], RESERVED6: [...], STIR: {:?} }}" , self . ISER , self . RESERVED0 , self . ICER , self . RSERVED1 , self . ISPR , self . RESERVED2 , self . ICPR , self . RESERVED3 , self . IABR , self . RESERVED4 , self . ITNS , self . RESERVED5 , self . STIR)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SCB_Type {
    pub CPUID: u32,
    pub ICSR: u32,
    pub VTOR: u32,
    pub AIRCR: u32,
    pub SCR: u32,
    pub CCR: u32,
    pub SHPR: [u8; 12usize],
    pub SHCSR: u32,
    pub CFSR: u32,
    pub HFSR: u32,
    pub DFSR: u32,
    pub MMFAR: u32,
    pub BFAR: u32,
    pub AFSR: u32,
    pub ID_PFR: [u32; 2usize],
    pub ID_DFR: u32,
    pub ID_ADR: u32,
    pub ID_MMFR: [u32; 4usize],
    pub ID_ISAR: [u32; 6usize],
    pub CLIDR: u32,
    pub CTR: u32,
    pub CCSIDR: u32,
    pub CSSELR: u32,
    pub CPACR: u32,
    pub NSACR: u32,
    pub RESERVED3: [u32; 92usize],
    pub STIR: u32,
    pub RESERVED4: [u32; 15usize],
    pub MVFR0: u32,
    pub MVFR1: u32,
    pub MVFR2: u32,
    pub RESERVED5: [u32; 1usize],
    pub ICIALLU: u32,
    pub RESERVED6: [u32; 1usize],
    pub ICIMVAU: u32,
    pub DCIMVAC: u32,
    pub DCISW: u32,
    pub DCCMVAU: u32,
    pub DCCMVAC: u32,
    pub DCCSW: u32,
    pub DCCIMVAC: u32,
    pub DCCISW: u32,
    pub RESERVED7: [u32; 6usize],
    pub ITCMCR: u32,
    pub DTCMCR: u32,
    pub AHBPCR: u32,
    pub CACR: u32,
    pub AHBSCR: u32,
    pub RESERVED8: [u32; 1usize],
    pub ABFSR: u32,
}
impl Default for SCB_Type {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for SCB_Type {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "SCB_Type {{ CPUID: {:?}, ICSR: {:?}, VTOR: {:?}, AIRCR: {:?}, SCR: {:?}, CCR: {:?}, SHPR: {:?}, SHCSR: {:?}, CFSR: {:?}, HFSR: {:?}, DFSR: {:?}, MMFAR: {:?}, BFAR: {:?}, AFSR: {:?}, ID_PFR: {:?}, ID_DFR: {:?}, ID_ADR: {:?}, ID_MMFR: {:?}, ID_ISAR: {:?}, CLIDR: {:?}, CTR: {:?}, CCSIDR: {:?}, CSSELR: {:?}, CPACR: {:?}, NSACR: {:?}, RESERVED3: [...], STIR: {:?}, RESERVED4: {:?}, MVFR0: {:?}, MVFR1: {:?}, MVFR2: {:?}, RESERVED5: {:?}, ICIALLU: {:?}, RESERVED6: {:?}, ICIMVAU: {:?}, DCIMVAC: {:?}, DCISW: {:?}, DCCMVAU: {:?}, DCCMVAC: {:?}, DCCSW: {:?}, DCCIMVAC: {:?}, DCCISW: {:?}, RESERVED7: {:?}, ITCMCR: {:?}, DTCMCR: {:?}, AHBPCR: {:?}, CACR: {:?}, AHBSCR: {:?}, RESERVED8: {:?}, ABFSR: {:?} }}" , self . CPUID , self . ICSR , self . VTOR , self . AIRCR , self . SCR , self . CCR , self . SHPR , self . SHCSR , self . CFSR , self . HFSR , self . DFSR , self . MMFAR , self . BFAR , self . AFSR , self . ID_PFR , self . ID_DFR , self . ID_ADR , self . ID_MMFR , self . ID_ISAR , self . CLIDR , self . CTR , self . CCSIDR , self . CSSELR , self . CPACR , self . NSACR , self . STIR , self . RESERVED4 , self . MVFR0 , self . MVFR1 , self . MVFR2 , self . RESERVED5 , self . ICIALLU , self . RESERVED6 , self . ICIMVAU , self . DCIMVAC , self . DCISW , self . DCCMVAU , self . DCCMVAC , self . DCCSW , self . DCCIMVAC , self . DCCISW , self . RESERVED7 , self . ITCMCR , self . DTCMCR , self . AHBPCR , self . CACR , self . AHBSCR , self . RESERVED8 , self . ABFSR)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SCnSCB_Type {
    pub RESERVED0: [u32; 1usize],
    pub ICTR: u32,
    pub ACTLR: u32,
    pub CPPWR: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SysTick_Type {
    pub CTRL: u32,
    pub LOAD: u32,
    pub VAL: u32,
    pub CALIB: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ITM_Type {
    pub PORT: [ITM_Type__bindgen_ty_1; 32usize],
    pub RESERVED0: [u32; 864usize],
    pub TER: u32,
    pub RESERVED1: [u32; 15usize],
    pub TPR: u32,
    pub RESERVED2: [u32; 15usize],
    pub TCR: u32,
    pub RESERVED3: [u32; 29usize],
    pub IWR: u32,
    pub IRR: u32,
    pub IMCR: u32,
    pub RESERVED4: [u32; 43usize],
    pub LAR: u32,
    pub LSR: u32,
    pub RESERVED5: [u32; 1usize],
    pub DEVARCH: u32,
    pub RESERVED6: [u32; 4usize],
    pub PID4: u32,
    pub PID5: u32,
    pub PID6: u32,
    pub PID7: u32,
    pub PID0: u32,
    pub PID1: u32,
    pub PID2: u32,
    pub PID3: u32,
    pub CID0: u32,
    pub CID1: u32,
    pub CID2: u32,
    pub CID3: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ITM_Type__bindgen_ty_1 {
    pub uint8_t: u8,
    pub uint16_t: u16,
    pub uint32_t: u32,
    _bindgen_union_align: u32,
}
impl Default for ITM_Type__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for ITM_Type__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "ITM_Type__bindgen_ty_1 {{ union }}")
    }
}
impl Default for ITM_Type {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for ITM_Type {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "ITM_Type {{ PORT: [...], RESERVED0: [...], TER: {:?}, RESERVED1: {:?}, TPR: {:?}, RESERVED2: {:?}, TCR: {:?}, RESERVED3: {:?}, IWR: {:?}, IRR: {:?}, IMCR: {:?}, RESERVED4: [...], LAR: {:?}, LSR: {:?}, RESERVED5: {:?}, DEVARCH: {:?}, RESERVED6: {:?}, PID4: {:?}, PID5: {:?}, PID6: {:?}, PID7: {:?}, PID0: {:?}, PID1: {:?}, PID2: {:?}, PID3: {:?}, CID0: {:?}, CID1: {:?}, CID2: {:?}, CID3: {:?} }}" , self . TER , self . RESERVED1 , self . TPR , self . RESERVED2 , self . TCR , self . RESERVED3 , self . IWR , self . IRR , self . IMCR , self . LAR , self . LSR , self . RESERVED5 , self . DEVARCH , self . RESERVED6 , self . PID4 , self . PID5 , self . PID6 , self . PID7 , self . PID0 , self . PID1 , self . PID2 , self . PID3 , self . CID0 , self . CID1 , self . CID2 , self . CID3)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DWT_Type {
    pub CTRL: u32,
    pub CYCCNT: u32,
    pub CPICNT: u32,
    pub EXCCNT: u32,
    pub SLEEPCNT: u32,
    pub LSUCNT: u32,
    pub FOLDCNT: u32,
    pub PCSR: u32,
    pub COMP0: u32,
    pub RESERVED1: [u32; 1usize],
    pub FUNCTION0: u32,
    pub RESERVED2: [u32; 1usize],
    pub COMP1: u32,
    pub RESERVED3: [u32; 1usize],
    pub FUNCTION1: u32,
    pub RESERVED4: [u32; 1usize],
    pub COMP2: u32,
    pub RESERVED5: [u32; 1usize],
    pub FUNCTION2: u32,
    pub RESERVED6: [u32; 1usize],
    pub COMP3: u32,
    pub RESERVED7: [u32; 1usize],
    pub FUNCTION3: u32,
    pub RESERVED8: [u32; 1usize],
    pub COMP4: u32,
    pub RESERVED9: [u32; 1usize],
    pub FUNCTION4: u32,
    pub RESERVED10: [u32; 1usize],
    pub COMP5: u32,
    pub RESERVED11: [u32; 1usize],
    pub FUNCTION5: u32,
    pub RESERVED12: [u32; 1usize],
    pub COMP6: u32,
    pub RESERVED13: [u32; 1usize],
    pub FUNCTION6: u32,
    pub RESERVED14: [u32; 1usize],
    pub COMP7: u32,
    pub RESERVED15: [u32; 1usize],
    pub FUNCTION7: u32,
    pub RESERVED16: [u32; 1usize],
    pub COMP8: u32,
    pub RESERVED17: [u32; 1usize],
    pub FUNCTION8: u32,
    pub RESERVED18: [u32; 1usize],
    pub COMP9: u32,
    pub RESERVED19: [u32; 1usize],
    pub FUNCTION9: u32,
    pub RESERVED20: [u32; 1usize],
    pub COMP10: u32,
    pub RESERVED21: [u32; 1usize],
    pub FUNCTION10: u32,
    pub RESERVED22: [u32; 1usize],
    pub COMP11: u32,
    pub RESERVED23: [u32; 1usize],
    pub FUNCTION11: u32,
    pub RESERVED24: [u32; 1usize],
    pub COMP12: u32,
    pub RESERVED25: [u32; 1usize],
    pub FUNCTION12: u32,
    pub RESERVED26: [u32; 1usize],
    pub COMP13: u32,
    pub RESERVED27: [u32; 1usize],
    pub FUNCTION13: u32,
    pub RESERVED28: [u32; 1usize],
    pub COMP14: u32,
    pub RESERVED29: [u32; 1usize],
    pub FUNCTION14: u32,
    pub RESERVED30: [u32; 1usize],
    pub COMP15: u32,
    pub RESERVED31: [u32; 1usize],
    pub FUNCTION15: u32,
    pub RESERVED32: [u32; 934usize],
    pub LSR: u32,
    pub RESERVED33: [u32; 1usize],
    pub DEVARCH: u32,
}
impl Default for DWT_Type {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for DWT_Type {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "DWT_Type {{ CTRL: {:?}, CYCCNT: {:?}, CPICNT: {:?}, EXCCNT: {:?}, SLEEPCNT: {:?}, LSUCNT: {:?}, FOLDCNT: {:?}, PCSR: {:?}, COMP0: {:?}, RESERVED1: {:?}, FUNCTION0: {:?}, RESERVED2: {:?}, COMP1: {:?}, RESERVED3: {:?}, FUNCTION1: {:?}, RESERVED4: {:?}, COMP2: {:?}, RESERVED5: {:?}, FUNCTION2: {:?}, RESERVED6: {:?}, COMP3: {:?}, RESERVED7: {:?}, FUNCTION3: {:?}, RESERVED8: {:?}, COMP4: {:?}, RESERVED9: {:?}, FUNCTION4: {:?}, RESERVED10: {:?}, COMP5: {:?}, RESERVED11: {:?}, FUNCTION5: {:?}, RESERVED12: {:?}, COMP6: {:?}, RESERVED13: {:?}, FUNCTION6: {:?}, RESERVED14: {:?}, COMP7: {:?}, RESERVED15: {:?}, FUNCTION7: {:?}, RESERVED16: {:?}, COMP8: {:?}, RESERVED17: {:?}, FUNCTION8: {:?}, RESERVED18: {:?}, COMP9: {:?}, RESERVED19: {:?}, FUNCTION9: {:?}, RESERVED20: {:?}, COMP10: {:?}, RESERVED21: {:?}, FUNCTION10: {:?}, RESERVED22: {:?}, COMP11: {:?}, RESERVED23: {:?}, FUNCTION11: {:?}, RESERVED24: {:?}, COMP12: {:?}, RESERVED25: {:?}, FUNCTION12: {:?}, RESERVED26: {:?}, COMP13: {:?}, RESERVED27: {:?}, FUNCTION13: {:?}, RESERVED28: {:?}, COMP14: {:?}, RESERVED29: {:?}, FUNCTION14: {:?}, RESERVED30: {:?}, COMP15: {:?}, RESERVED31: {:?}, FUNCTION15: {:?}, RESERVED32: [...], LSR: {:?}, RESERVED33: {:?}, DEVARCH: {:?} }}" , self . CTRL , self . CYCCNT , self . CPICNT , self . EXCCNT , self . SLEEPCNT , self . LSUCNT , self . FOLDCNT , self . PCSR , self . COMP0 , self . RESERVED1 , self . FUNCTION0 , self . RESERVED2 , self . COMP1 , self . RESERVED3 , self . FUNCTION1 , self . RESERVED4 , self . COMP2 , self . RESERVED5 , self . FUNCTION2 , self . RESERVED6 , self . COMP3 , self . RESERVED7 , self . FUNCTION3 , self . RESERVED8 , self . COMP4 , self . RESERVED9 , self . FUNCTION4 , self . RESERVED10 , self . COMP5 , self . RESERVED11 , self . FUNCTION5 , self . RESERVED12 , self . COMP6 , self . RESERVED13 , self . FUNCTION6 , self . RESERVED14 , self . COMP7 , self . RESERVED15 , self . FUNCTION7 , self . RESERVED16 , self . COMP8 , self . RESERVED17 , self . FUNCTION8 , self . RESERVED18 , self . COMP9 , self . RESERVED19 , self . FUNCTION9 , self . RESERVED20 , self . COMP10 , self . RESERVED21 , self . FUNCTION10 , self . RESERVED22 , self . COMP11 , self . RESERVED23 , self . FUNCTION11 , self . RESERVED24 , self . COMP12 , self . RESERVED25 , self . FUNCTION12 , self . RESERVED26 , self . COMP13 , self . RESERVED27 , self . FUNCTION13 , self . RESERVED28 , self . COMP14 , self . RESERVED29 , self . FUNCTION14 , self . RESERVED30 , self . COMP15 , self . RESERVED31 , self . FUNCTION15 , self . LSR , self . RESERVED33 , self . DEVARCH)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPI_Type {
    pub SSPSR: u32,
    pub CSPSR: u32,
    pub RESERVED0: [u32; 2usize],
    pub ACPR: u32,
    pub RESERVED1: [u32; 55usize],
    pub SPPR: u32,
    pub RESERVED2: [u32; 131usize],
    pub FFSR: u32,
    pub FFCR: u32,
    pub FSCR: u32,
    pub RESERVED3: [u32; 759usize],
    pub TRIGGER: u32,
    pub FIFO0: u32,
    pub ITATBCTR2: u32,
    pub RESERVED4: [u32; 1usize],
    pub ITATBCTR0: u32,
    pub FIFO1: u32,
    pub ITCTRL: u32,
    pub RESERVED5: [u32; 39usize],
    pub CLAIMSET: u32,
    pub CLAIMCLR: u32,
    pub RESERVED7: [u32; 8usize],
    pub DEVID: u32,
    pub DEVTYPE: u32,
}
impl Default for TPI_Type {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for TPI_Type {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "TPI_Type {{ SSPSR: {:?}, CSPSR: {:?}, RESERVED0: {:?}, ACPR: {:?}, RESERVED1: [...], SPPR: {:?}, RESERVED2: [...], FFSR: {:?}, FFCR: {:?}, FSCR: {:?}, RESERVED3: [...], TRIGGER: {:?}, FIFO0: {:?}, ITATBCTR2: {:?}, RESERVED4: {:?}, ITATBCTR0: {:?}, FIFO1: {:?}, ITCTRL: {:?}, RESERVED5: [...], CLAIMSET: {:?}, CLAIMCLR: {:?}, RESERVED7: {:?}, DEVID: {:?}, DEVTYPE: {:?} }}" , self . SSPSR , self . CSPSR , self . RESERVED0 , self . ACPR , self . SPPR , self . FFSR , self . FFCR , self . FSCR , self . TRIGGER , self . FIFO0 , self . ITATBCTR2 , self . RESERVED4 , self . ITATBCTR0 , self . FIFO1 , self . ITCTRL , self . CLAIMSET , self . CLAIMCLR , self . RESERVED7 , self . DEVID , self . DEVTYPE)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MPU_Type {
    pub TYPE: u32,
    pub CTRL: u32,
    pub RNR: u32,
    pub RBAR: u32,
    pub RLAR: u32,
    pub RBAR_A1: u32,
    pub RLAR_A1: u32,
    pub RBAR_A2: u32,
    pub RLAR_A2: u32,
    pub RBAR_A3: u32,
    pub RLAR_A3: u32,
    pub RESERVED0: [u32; 1usize],
    pub MAIR0: u32,
    pub MAIR1: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SAU_Type {
    pub CTRL: u32,
    pub TYPE: u32,
    pub RNR: u32,
    pub RBAR: u32,
    pub RLAR: u32,
    pub SFSR: u32,
    pub SFAR: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FPU_Type {
    pub RESERVED0: [u32; 1usize],
    pub FPCCR: u32,
    pub FPCAR: u32,
    pub FPDSCR: u32,
    pub MVFR0: u32,
    pub MVFR1: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CoreDebug_Type {
    pub DHCSR: u32,
    pub DCRSR: u32,
    pub DCRDR: u32,
    pub DEMCR: u32,
    pub RESERVED4: [u32; 1usize],
    pub DAUTHCTRL: u32,
    pub DSCSR: u32,
}
extern "C" {
    pub static mut ITM_RxBuffer: i32;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mpu_region_config {
    pub region_base: u32,
    pub region_size: u32,
    pub xn: u8,
    pub ap: u8,
    pub sh: u8,
    pub attr_idx: u8,
}
extern "C" {
    pub fn mpu_init();
}
extern "C" {
    pub fn mpu_set_mem_attr(attr_idx: u8, mem_attr: u8);
}
extern "C" {
    pub fn mpu_region_cfg(region_num: u8, pmpu_cfg: *mut mpu_region_config);
}
extern "C" {
    pub fn mpu_enable();
}
extern "C" {
    pub fn mpu_disable();
}
extern "C" {
    pub fn mpu_entry_free(entry_index: u32);
}
extern "C" {
    pub fn mpu_entry_alloc() -> ffi::ctypes::c_char;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GDMA_InitTypeDef {
    pub GDMA_Index: u8,
    pub GDMA_ChNum: u8,
    pub GDMA_DIR: u32,
    pub GDMA_DstDataWidth: u32,
    pub GDMA_SrcDataWidth: u32,
    pub GDMA_DstInc: u32,
    pub GDMA_SrcInc: u32,
    pub GDMA_DstMsize: u32,
    pub GDMA_SrcMsize: u32,
    pub GDMA_SrcAddr: u32,
    pub GDMA_DstAddr: u32,
    pub GDMA_BlockSize: u16,
    pub GDMA_IsrType: u32,
    pub GDMA_ReloadSrc: u32,
    pub GDMA_ReloadDst: u32,
    pub GDMA_LlpDstEn: u32,
    pub GDMA_LlpSrcEn: u32,
    pub GDMA_SrcHandshakeInterface: u32,
    pub GDMA_DstHandshakeInterface: u32,
    pub MuliBlockCunt: u32,
    pub MaxMuliBlock: u32,
    pub SecureTransfer: u32,
}
pub type PGDMA_InitTypeDef = *mut GDMA_InitTypeDef;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GDMA_CH_LLI_ELE {
    pub Sarx: u32,
    pub Darx: u32,
    pub Llpx: u32,
    pub CtlxLow: u32,
    pub CtlxUp: u32,
    pub Temp: u32,
}
pub type PGDMA_CH_LLI_ELE = *mut GDMA_CH_LLI_ELE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDMA_CH_LLI {
    pub LliEle: GDMA_CH_LLI_ELE,
    pub BlockSize: u32,
    pub pNextLli: *mut GDMA_CH_LLI,
}
impl Default for GDMA_CH_LLI {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn GDMA_StructInit(GDMA_InitStruct: PGDMA_InitTypeDef);
}
extern "C" {
    pub fn GDMA_Init(GDMA_Index: u8, GDMA_ChNum: u8, GDMA_InitStruct: PGDMA_InitTypeDef);
}
extern "C" {
    pub fn GDMA_SetLLP(
        GDMA_Index: u8,
        GDMA_ChNum: u8,
        MultiBlockCount: u32,
        pGdmaChLli: *mut GDMA_CH_LLI,
    );
}
extern "C" {
    pub fn GDMA_Cmd(GDMA_Index: u8, GDMA_ChNum: u8, NewState: u32);
}
extern "C" {
    pub fn GDMA_INTConfig(GDMA_Index: u8, GDMA_ChNum: u8, GDMA_IT: u32, NewState: u32);
}
extern "C" {
    pub fn GDMA_ClearINTPendingBit(GDMA_Index: u8, GDMA_ChNum: u8, GDMA_IT: u32) -> u32;
}
extern "C" {
    pub fn GDMA_ClearINT(GDMA_Index: u8, GDMA_ChNum: u8) -> u32;
}
extern "C" {
    pub fn GDMA_ChCleanAutoReload(GDMA_Index: u8, GDMA_ChNum: u8, CleanType: u32);
}
extern "C" {
    pub fn GDMA_SetSrcAddr(GDMA_Index: u8, GDMA_ChNum: u8, SrcAddr: u32);
}
extern "C" {
    pub fn GDMA_GetSrcAddr(GDMA_Index: u8, GDMA_ChNum: u8) -> u32;
}
extern "C" {
    pub fn GDMA_GetDstAddr(GDMA_Index: u8, GDMA_ChNum: u8) -> u32;
}
extern "C" {
    pub fn GDMA_SetDstAddr(GDMA_Index: u8, GDMA_ChNum: u8, DstAddr: u32);
}
extern "C" {
    pub fn GDMA_SetBlkSize(GDMA_Index: u8, GDMA_ChNum: u8, BlkSize: u32);
}
extern "C" {
    pub fn GDMA_GetBlkSize(GDMA_Index: u8, GDMA_ChNum: u8) -> u32;
}
extern "C" {
    pub fn GDMA_ChnlRegister(GDMA_Index: u8, GDMA_ChNum: u8) -> BOOL;
}
extern "C" {
    pub fn GDMA_ChnlUnRegister(GDMA_Index: u8, GDMA_ChNum: u8);
}
extern "C" {
    pub fn GDMA_ChnlAlloc(GDMA_Index: u32, IrqFun: IRQ_FUN, IrqData: u32, IrqPriority: u32) -> u8;
}
extern "C" {
    pub fn GDMA_ChnlFree(GDMA_Index: u8, GDMA_ChNum: u8);
}
extern "C" {
    pub fn GDMA_GetIrqNum(GDMA_Index: u8, GDMA_ChNum: u8) -> u8;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct RTIM_TimeBaseInitTypeDef {
    pub TIM_Prescaler: u32,
    pub TIM_Period: u32,
    pub TIM_UpdateEvent: u32,
    pub TIM_UpdateSource: u32,
    pub TIM_ARRProtection: u32,
    pub TIM_Idx: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TIM_CCInitTypeDef {
    pub TIM_CCMode: u32,
    pub TIM_CCPolarity: u32,
    pub TIM_OCProtection: u32,
    pub TIM_OCPulse: u32,
    pub TIM_ICPulseMode: u32,
}
extern "C" {
    pub fn RTIM_TimeBaseStructInit(TIM_InitStruct: *mut RTIM_TimeBaseInitTypeDef);
}
extern "C" {
    pub fn RTIM_TimeBaseInit(
        TIMx: *mut RTIM_TypeDef,
        TIM_InitStruct: *mut RTIM_TimeBaseInitTypeDef,
        IrqNum: IRQn_Type,
        UserCB: IRQ_FUN,
        UserCBData: u32,
    );
}
extern "C" {
    pub fn RTIM_Cmd(TIMx: *mut RTIM_TypeDef, NewState: u32);
}
extern "C" {
    pub fn RTIM_DeInit(TIMx: *mut RTIM_TypeDef);
}
extern "C" {
    pub fn RTIM_GetCount(TIMx: *mut RTIM_TypeDef) -> u32;
}
extern "C" {
    pub fn RTIM_UpdateDisableConfig(TIMx: *mut RTIM_TypeDef, NewState: u32);
}
extern "C" {
    pub fn RTIM_ARRPreloadConfig(TIMx: *mut RTIM_TypeDef, NewState: u32);
}
extern "C" {
    pub fn RTIM_UpdateRequestConfig(TIMx: *mut RTIM_TypeDef, TIM_UpdateSource: u32);
}
extern "C" {
    pub fn RTIM_PrescalerConfig(TIMx: *mut RTIM_TypeDef, Prescaler: u32, TIM_PSCReloadMode: u32);
}
extern "C" {
    pub fn RTIM_GenerateEvent(TIMx: *mut RTIM_TypeDef, TIM_EventSource: u32);
}
extern "C" {
    pub fn RTIM_ChangePeriod(TIMx: *mut RTIM_TypeDef, Autoreload: u32);
}
extern "C" {
    pub fn RTIM_ChangePeriodImmediate(TIMx: *mut RTIM_TypeDef, Autoreload: u32);
}
extern "C" {
    pub fn RTIM_Reset(TIMx: *mut RTIM_TypeDef);
}
extern "C" {
    pub fn RTIM_CCStructInit(TIM_CCInitStruct: *mut TIM_CCInitTypeDef);
}
extern "C" {
    pub fn RTIM_CCxInit(
        TIMx: *mut RTIM_TypeDef,
        TIM_CCInitStruct: *mut TIM_CCInitTypeDef,
        TIM_Channel: u16,
    );
}
extern "C" {
    pub fn RTIM_CCRxMode(TIMx: *mut RTIM_TypeDef, TIM_Channel: u16, TIM_CCMode: u32);
}
extern "C" {
    pub fn RTIM_CCRxSet(TIMx: *mut RTIM_TypeDef, Compare: u32, TIM_Channel: u16);
}
extern "C" {
    pub fn RTIM_CCRxGet(TIMx: *mut RTIM_TypeDef, TIM_Channel: u16) -> u32;
}
extern "C" {
    pub fn RTIM_OCxPreloadConfig(TIMx: *mut RTIM_TypeDef, TIM_OCProtection: u32, TIM_Channel: u16);
}
extern "C" {
    pub fn RTIM_CCxPolarityConfig(TIMx: *mut RTIM_TypeDef, TIM_OCPolarity: u32, TIM_Channel: u16);
}
extern "C" {
    pub fn RTIM_CCxCmd(TIMx: *mut RTIM_TypeDef, TIM_Channel: u16, TIM_CCx: u32);
}
extern "C" {
    pub fn RTIM_SetOnePulseOutputMode(
        TIMx: *mut RTIM_TypeDef,
        TIM_OPMode: u32,
        TrigerPolarity: u32,
    );
}
extern "C" {
    pub fn RTIM_INTConfig(TIMx: *mut RTIM_TypeDef, TIM_IT: u32, NewState: u32);
}
extern "C" {
    pub fn RTIM_INTClear(TIMx: *mut RTIM_TypeDef);
}
extern "C" {
    pub fn RTIM_INTClearPendingBit(TIMx: *mut RTIM_TypeDef, TIM_IT: u16);
}
extern "C" {
    pub fn RTIM_GetFlagStatus(TIMx: *mut RTIM_TypeDef, TIM_FLAG: u32) -> u32;
}
extern "C" {
    pub fn RTIM_GetINTStatus(TIMx: *mut RTIM_TypeDef, TIM_IT: u32) -> u32;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PWMCHANCFG_TypeDef {
    pub PWM_CHANNEL: u32,
    pub KM0_CHAN_STATUS: u32,
    pub KM4_CHAN_STATUS: u32,
}
extern "C" {
    pub static mut pwmchannel_config: [PWMCHANCFG_TypeDef; 0usize];
}
extern "C" {
    pub static mut TIMx_irq: [ffi::ctypes::c_int; 6usize];
}
extern "C" {
    pub static mut TIMx_irq_LP: [ffi::ctypes::c_int; 6usize];
}
extern "C" {
    pub static mut TIMx: [*mut RTIM_TypeDef; 6usize];
}
extern "C" {
    pub static mut TIMx_LP: [*mut RTIM_TypeDef; 6usize];
}
extern "C" {
    pub static mut TIM_IT_CCx_LP: [u32; 6usize];
}
extern "C" {
    pub static mut TIM_IT_CCx: [u32; 18usize];
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GPIO_InitTypeDef {
    pub GPIO_Mode: u32,
    pub GPIO_PuPd: u32,
    pub GPIO_ITTrigger: u32,
    pub GPIO_ITPolarity: u32,
    pub GPIO_ITDebounce: u32,
    pub GPIO_Pin: u32,
}
extern "C" {
    pub fn GPIO_WriteBit(GPIO_Pin: u32, BitVal: u32);
}
extern "C" {
    pub fn GPIO_ReadDataBit(GPIO_Pin: u32) -> u32;
}
extern "C" {
    pub fn GPIO_DeInit(GPIO_Pin: u32);
}
extern "C" {
    pub fn GPIO_UserRegIrq(
        GPIO_Pin: u32,
        IrqHandler: *mut ffi::ctypes::c_void,
        IrqData: *mut ffi::ctypes::c_void,
    );
}
extern "C" {
    pub fn GPIO_INTMode(
        GPIO_Pin: u32,
        NewState: u32,
        GPIO_ITTrigger: u32,
        GPIO_ITPolarity: u32,
        GPIO_ITDebounce: u32,
    );
}
extern "C" {
    pub fn GPIO_INTConfig(GPIO_Pin: u32, NewState: u32);
}
extern "C" {
    pub fn GPIO_Init(GPIO_InitStruct: *mut GPIO_InitTypeDef);
}
extern "C" {
    pub fn GPIO_INTHandler(pData: *mut ffi::ctypes::c_void) -> u32;
}
extern "C" {
    pub fn GPIO_Direction(GPIO_Pin: u32, data_direction: u32);
}
extern "C" {
    pub fn GPIO_PortRead(GPIO_Port: u32, GPIO_Mask: u32) -> u32;
}
extern "C" {
    pub fn GPIO_PortWrite(GPIO_Port: u32, GPIO_Mask: u32, Port_State: u32);
}
extern "C" {
    pub fn GPIO_PortDirection(GPIO_Port: u32, GPIO_Mask: u32, data_direction: u32);
}
pub type GPIO_IRQ_FUN =
    ::core::option::Option<unsafe extern "C" fn(Data: *mut ffi::ctypes::c_void, Id: u32)>;
pub type GPIO_USER_IRQ_FUN = ::core::option::Option<unsafe extern "C" fn(Id: u32)>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SSI_InitTypeDef {
    pub SPI_DmaRxDataLevel: u32,
    pub SPI_DmaTxDataLevel: u32,
    pub SPI_RxThresholdLevel: u32,
    pub SPI_TxThresholdLevel: u32,
    pub SPI_SlaveSelectEnable: u32,
    pub SPI_ClockDivider: u32,
    pub SPI_DataFrameNumber: u32,
    pub SPI_DataFrameFormat: u32,
    pub SPI_DataFrameSize: u32,
    pub SPI_InterruptMask: u32,
    pub SPI_Role: u32,
    pub SPI_SclkPhase: u32,
    pub SPI_SclkPolarity: u32,
    pub SPI_TransferMode: u32,
    pub SPI_MicrowireControlFrameSize: u32,
    pub SPI_MicrowireDirection: u32,
    pub SPI_MicrowireHandshaking: u32,
    pub SPI_MicrowireTransferMode: u32,
}
extern "C" {
    pub fn SSI_Cmd(spi_dev: *mut SPI_TypeDef, NewStaus: u32);
}
extern "C" {
    pub fn SSI_SetSclkPolarity(spi_dev: *mut SPI_TypeDef, SclkPolarity: u32);
}
extern "C" {
    pub fn SSI_SetSclkPhase(spi_dev: *mut SPI_TypeDef, SclkPhase: u32);
}
extern "C" {
    pub fn SSI_WriteData(spi_dev: *mut SPI_TypeDef, value: u32);
}
extern "C" {
    pub fn SSI_INTConfig(spi_dev: *mut SPI_TypeDef, SSI_IT: u32, newState: u32);
}
extern "C" {
    pub fn SSI_SetRxFifoLevel(spi_dev: *mut SPI_TypeDef, RxThresholdLevel: u32);
}
extern "C" {
    pub fn SSI_SetTxFifoLevel(spi_dev: *mut SPI_TypeDef, TxThresholdLevel: u32);
}
extern "C" {
    pub fn SSI_SetSlaveEnable(spi_dev: *mut SPI_TypeDef, SlaveIndex: u32);
}
extern "C" {
    pub fn SSI_Busy(spi_dev: *mut SPI_TypeDef) -> u32;
}
extern "C" {
    pub fn SSI_Writeable(spi_dev: *mut SPI_TypeDef) -> u32;
}
extern "C" {
    pub fn SSI_Readable(spi_dev: *mut SPI_TypeDef) -> u32;
}
extern "C" {
    pub fn SSI_GetRxCount(spi_dev: *mut SPI_TypeDef) -> u32;
}
extern "C" {
    pub fn SSI_GetTxCount(spi_dev: *mut SPI_TypeDef) -> u32;
}
extern "C" {
    pub fn SSI_GetStatus(spi_dev: *mut SPI_TypeDef) -> u32;
}
extern "C" {
    pub fn SSI_GetIsr(spi_dev: *mut SPI_TypeDef) -> u32;
}
extern "C" {
    pub fn SSI_ReadData(spi_dev: *mut SPI_TypeDef) -> u32;
}
extern "C" {
    pub fn SSI_ReceiveData(
        spi_dev: *mut SPI_TypeDef,
        RxData: *mut ffi::ctypes::c_void,
        Length: u32,
    ) -> u32;
}
extern "C" {
    pub fn SSI_SendData(
        spi_dev: *mut SPI_TypeDef,
        TxData: *mut ffi::ctypes::c_void,
        Length: u32,
        Role: u32,
    ) -> u32;
}
extern "C" {
    pub fn SSI_GetRawIsr(spi_dev: *mut SPI_TypeDef) -> u32;
}
extern "C" {
    pub fn SSI_GetSlaveEnable(spi_dev: *mut SPI_TypeDef) -> u32;
}
extern "C" {
    pub fn SSI_GetDataFrameSize(spi_dev: *mut SPI_TypeDef) -> u32;
}
extern "C" {
    pub fn SSI_SetSampleDelay(spi_dev: *mut SPI_TypeDef, SampleDelay: u32);
}
extern "C" {
    pub fn SSI_Init(spi_dev: *mut SPI_TypeDef, SSI_InitStruct: *mut SSI_InitTypeDef);
}
extern "C" {
    pub fn SSI_StructInit(SSI_InitStruct: *mut SSI_InitTypeDef);
}
extern "C" {
    pub fn SSI_SetDataFrameSize(spi_dev: *mut SPI_TypeDef, DataFrameSize: u32);
}
extern "C" {
    pub fn SSI_SetBaud(SPIx: *mut SPI_TypeDef, BaudRate: u32, IpClk: u32);
}
extern "C" {
    pub fn SSI_SetIsrClean(spi_dev: *mut SPI_TypeDef, InterruptStatus: u32);
}
extern "C" {
    pub fn SSI_SetReadLen(spi_dev: *mut SPI_TypeDef, DataFrameNumber: u32);
}
extern "C" {
    pub fn SSI_TXGDMA_Init(
        Index: u32,
        GDMA_InitStruct: PGDMA_InitTypeDef,
        CallbackData: *mut ffi::ctypes::c_void,
        CallbackFunc: IRQ_FUN,
        pTxData: *mut u8,
        Length: u32,
    ) -> BOOL;
}
extern "C" {
    pub fn SSI_RXGDMA_Init(
        Index: u8,
        GDMA_InitStruct: *mut GDMA_InitTypeDef,
        CallbackData: *mut ffi::ctypes::c_void,
        CallbackFunc: IRQ_FUN,
        pRxData: *mut u8,
        Length: u32,
    ) -> BOOL;
}
extern "C" {
    pub fn SSI_SetDmaEnable(spi_dev: *mut SPI_TypeDef, newState: u32, Mask: u32);
}
extern "C" {
    pub fn SSI_SetDmaLevel(spi_dev: *mut SPI_TypeDef, TxLeve: u32, RxLevel: u32);
}
extern "C" {
    pub fn SSI_SetBaudDiv(spi_dev: *mut SPI_TypeDef, ClockDivider: u32);
}
extern "C" {
    pub fn SSI_SetRole(spi_dev: *mut SPI_TypeDef, role: u32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPI_DevTable {
    pub SPIx: *mut SPI_TypeDef,
    pub Tx_HandshakeInterface: u32,
    pub Rx_HandshakeInterface: u32,
    pub IrqNum: IRQn_Type,
}
impl Default for SPI_DevTable {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static SPI_DEV_TABLE: [SPI_DevTable; 2usize];
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct UART_InitTypeDef {
    pub DmaModeCtrl: u32,
    pub WordLen: u32,
    pub StopBit: u32,
    pub Parity: u32,
    pub ParityType: u32,
    pub StickParity: u32,
    pub FlowControl: u32,
    pub RxFifoTrigLevel: u32,
    pub RxErReportCtrl: u32,
    pub RxTimeOutCnt: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IrDA_InitTypeDef {
    pub UART_IrDARxInv: u32,
    pub UART_IrDATxInv: u32,
    pub UART_UpperShift: u32,
    pub UART_UpperShiftVal: u32,
    pub UART_LowShift: u32,
    pub UART_LowShiftVal: u32,
    pub UART_RxFilterThres: u32,
    pub UART_RxFilterCmd: u32,
}
extern "C" {
    pub fn UART_DeInit(UARTx: *mut UART_TypeDef);
}
extern "C" {
    pub fn UART_StructInit(UART_InitStruct: *mut UART_InitTypeDef);
}
extern "C" {
    pub fn UART_Init(UARTx: *mut UART_TypeDef, UART_InitStruct: *mut UART_InitTypeDef);
}
extern "C" {
    pub fn UART_BaudParaGet(baudrate: u32, ovsr: *mut u32, ovsr_adj: *mut u32) -> u32;
}
extern "C" {
    pub fn UART_BaudParaGetFull(IPclk: u32, baudrate: u32, ovsr: *mut u32, ovsr_adj: *mut u32);
}
extern "C" {
    pub fn UART_SetBaudExt(UARTx: *mut UART_TypeDef, Ovsr: u32, Ovsr_adj: u32);
}
extern "C" {
    pub fn UART_SetBaud(UARTx: *mut UART_TypeDef, BaudRate: u32);
}
extern "C" {
    pub fn UART_SetRxLevel(UARTx: *mut UART_TypeDef, FifoLv: u32);
}
extern "C" {
    pub fn UART_RxCmd(UARTx: *mut UART_TypeDef, NewState: u32);
}
extern "C" {
    pub fn UART_Writable(UARTx: *mut UART_TypeDef) -> u32;
}
extern "C" {
    pub fn UART_Readable(UARTx: *mut UART_TypeDef) -> u32;
}
extern "C" {
    pub fn UART_CharPut(UARTx: *mut UART_TypeDef, TxData: u8);
}
extern "C" {
    pub fn UART_CharGet(UARTx: *mut UART_TypeDef, pRxByte: *mut u8);
}
extern "C" {
    pub fn UART_ReceiveData(UARTx: *mut UART_TypeDef, OutBuf: *mut u8, Count: u32);
}
extern "C" {
    pub fn UART_SendData(UARTx: *mut UART_TypeDef, InBuf: *mut u8, Count: u32);
}
extern "C" {
    pub fn UART_ReceiveDataTO(
        UARTx: *mut UART_TypeDef,
        OutBuf: *mut u8,
        Count: u32,
        Times: u32,
    ) -> u32;
}
extern "C" {
    pub fn UART_SendDataTO(UARTx: *mut UART_TypeDef, InBuf: *mut u8, Count: u32, Times: u32)
        -> u32;
}
extern "C" {
    pub fn UART_RxByteCntClear(UARTx: *mut UART_TypeDef);
}
extern "C" {
    pub fn UART_RxByteCntGet(UARTx: *mut UART_TypeDef) -> u32;
}
extern "C" {
    pub fn UART_BreakCtl(UARTx: *mut UART_TypeDef, NewState: u32);
}
extern "C" {
    pub fn UART_ClearRxFifo(UARTx: *mut UART_TypeDef) -> u32;
}
extern "C" {
    pub fn UART_ClearTxFifo(UARTx: *mut UART_TypeDef);
}
extern "C" {
    pub fn UART_INTConfig(UARTx: *mut UART_TypeDef, UART_IT: u32, newState: u32);
}
extern "C" {
    pub fn UART_IntStatus(UARTx: *mut UART_TypeDef) -> u32;
}
extern "C" {
    pub fn UART_ModemStatusGet(UARTx: *mut UART_TypeDef) -> u32;
}
extern "C" {
    pub fn UART_LineStatusGet(UARTx: *mut UART_TypeDef) -> u32;
}
extern "C" {
    pub fn UART_WaitBusy(UARTx: *mut UART_TypeDef, PollTimes: u32);
}
extern "C" {
    pub fn UART_TXDMAConfig(UARTx: *mut UART_TypeDef, TxDmaBurstSize: u32);
}
extern "C" {
    pub fn UART_RXDMAConfig(UARTx: *mut UART_TypeDef, RxDmaBurstSize: u32);
}
extern "C" {
    pub fn UART_TXDMACmd(UARTx: *mut UART_TypeDef, NewState: u32);
}
extern "C" {
    pub fn UART_RXDMACmd(UARTx: *mut UART_TypeDef, NewState: u32);
}
extern "C" {
    pub fn UART_TXGDMA_Init(
        UartIndex: u8,
        GDMA_InitStruct: *mut GDMA_InitTypeDef,
        CallbackData: *mut ffi::ctypes::c_void,
        CallbackFunc: IRQ_FUN,
        pTxBuf: *mut u8,
        TxCount: ffi::ctypes::c_int,
    ) -> BOOL;
}
extern "C" {
    pub fn UART_RXGDMA_Init(
        UartIndex: u8,
        GDMA_InitStruct: *mut GDMA_InitTypeDef,
        CallbackData: *mut ffi::ctypes::c_void,
        CallbackFunc: IRQ_FUN,
        pRxBuf: *mut u8,
        RxCount: ffi::ctypes::c_int,
    ) -> BOOL;
}
extern "C" {
    pub fn UART_MonitorParaConfig(
        UARTx: *mut UART_TypeDef,
        BitNumThres: u32,
        OscPerbitUpdCtrl: u32,
    );
}
extern "C" {
    pub fn UART_LPRxBaudSet(UARTx: *mut UART_TypeDef, BaudRate: u32, RxIPClockHz: u32);
}
extern "C" {
    pub fn UART_RxMonitorCmd(UARTx: *mut UART_TypeDef, NewState: u32);
}
extern "C" {
    pub fn UART_RxMonBaudCtrlRegGet(UARTx: *mut UART_TypeDef) -> u32;
}
extern "C" {
    pub fn UART_RxMonitorSatusGet(UARTx: *mut UART_TypeDef) -> u32;
}
extern "C" {
    pub fn UART_IrDAStructInit(IrDA_InitStruct: *mut IrDA_InitTypeDef);
}
extern "C" {
    pub fn UART_IrDAInit(UARTx: *mut UART_TypeDef, IrDA_InitStruct: *mut IrDA_InitTypeDef);
}
extern "C" {
    pub fn UART_IrDACmd(UARTx: *mut UART_TypeDef, NewState: u32);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct UARTCFG_TypeDef {
    pub LOW_POWER_RX_ENABLE: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UART_DevTable {
    pub UARTx: *mut UART_TypeDef,
    pub Tx_HandshakeInterface: u32,
    pub Rx_HandshakeInterface: u32,
    pub IrqNum: IRQn_Type,
}
impl Default for UART_DevTable {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static mut uart_config: [UARTCFG_TypeDef; 0usize];
}
extern "C" {
    pub static UART_DEV_TABLE: [UART_DevTable; 4usize];
}
extern "C" {
    pub static mut UART_StateTx: [u32; 4usize];
}
extern "C" {
    pub static mut UART_StateRx: [u32; 4usize];
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct I2C_InitTypeDef {
    pub I2CIdx: u32,
    pub I2CMaster: u32,
    pub I2CAddrMod: u32,
    pub I2CSpdMod: u32,
    pub I2CRXTL: u32,
    pub I2CTXTL: u32,
    pub I2CMstReSTR: u32,
    pub I2CMstGC: u32,
    pub I2CMstStartB: u32,
    pub I2CSlvNoAck: u32,
    pub I2CSlvAckGC: u32,
    pub I2CAckAddr: u32,
    pub I2CSlvSetup: u32,
    pub I2CSdaHd: u32,
    pub I2CClk: u32,
    pub I2CIPClk: u32,
    pub I2CFilter: u32,
    pub I2CTxDMARqLv: u32,
    pub I2CRxDMARqLv: u32,
    pub I2CDMAMod: u32,
    pub I2CAckAddr1: u32,
}
extern "C" {
    pub fn I2C_Init(I2Cx: *mut I2C_TypeDef, I2C_InitStruct: *mut I2C_InitTypeDef);
}
extern "C" {
    pub fn I2C_Cmd(I2Cx: *mut I2C_TypeDef, NewState: u8);
}
extern "C" {
    pub fn I2C_ClearAllINT(I2Cx: *mut I2C_TypeDef);
}
extern "C" {
    pub fn I2C_GetRawINT(I2Cx: *mut I2C_TypeDef) -> u32;
}
extern "C" {
    pub fn I2C_GetINT(I2Cx: *mut I2C_TypeDef) -> u32;
}
extern "C" {
    pub fn I2C_CheckFlagState(I2Cx: *mut I2C_TypeDef, I2C_FLAG: u32) -> u8;
}
extern "C" {
    pub fn I2C_INTConfig(I2Cx: *mut I2C_TypeDef, I2C_IT: u32, NewState: u32);
}
extern "C" {
    pub fn I2C_ClearINT(I2Cx: *mut I2C_TypeDef, INTrAddr: u32);
}
extern "C" {
    pub fn I2C_SetSpeed(I2Cx: *mut I2C_TypeDef, SpdMd: u32, I2Clk: u32, I2CIPClk: u32);
}
extern "C" {
    pub fn I2C_StructInit(I2C_InitStruct: *mut I2C_InitTypeDef);
}
extern "C" {
    pub fn I2C_ReceiveData(I2Cx: *mut I2C_TypeDef) -> u8;
}
extern "C" {
    pub fn I2C_MasterSendNullData(
        I2Cx: *mut I2C_TypeDef,
        pBuf: *mut u8,
        I2CCmd: u8,
        I2CStop: u8,
        I2CReSTR: u8,
    );
}
extern "C" {
    pub fn I2C_MasterSend(
        I2Cx: *mut I2C_TypeDef,
        pBuf: *mut u8,
        I2CCmd: u8,
        I2CStop: u8,
        I2CReSTR: u8,
    );
}
extern "C" {
    pub fn I2C_MasterWrite(I2Cx: *mut I2C_TypeDef, pBuf: *mut u8, len: u8);
}
extern "C" {
    pub fn I2C_MasterReadDW(I2Cx: *mut I2C_TypeDef, pBuf: *mut u8, len: u8);
}
extern "C" {
    pub fn I2C_MasterRead(I2Cx: *mut I2C_TypeDef, pBuf: *mut u8, len: u8) -> u8;
}
extern "C" {
    pub fn I2C_MasterRepeatRead(
        I2Cx: *mut I2C_TypeDef,
        pWriteBuf: *mut u8,
        Writelen: u8,
        pReadBuf: *mut u8,
        Readlen: u8,
    );
}
extern "C" {
    pub fn I2C_SetSlaveAddress(I2Cx: *mut I2C_TypeDef, Address: u16);
}
extern "C" {
    pub fn I2C_SlaveWrite(I2Cx: *mut I2C_TypeDef, pBuf: *mut u8, len: u8);
}
extern "C" {
    pub fn I2C_SlaveRead(I2Cx: *mut I2C_TypeDef, pBuf: *mut u8, len: u8);
}
extern "C" {
    pub fn I2C_SlaveSend(I2Cx: *mut I2C_TypeDef, Data: u8);
}
extern "C" {
    pub fn I2C_DMAControl(I2Cx: *mut I2C_TypeDef, DmaCtrl: u32, NewState: u8);
}
extern "C" {
    pub fn I2C_DmaMode1Config(I2Cx: *mut I2C_TypeDef, I2C_DmaCmd: u32, I2C_DmaBLen: u32);
}
extern "C" {
    pub fn I2C_DmaMode2Config(I2Cx: *mut I2C_TypeDef, I2C_DmaCmd: u32, I2C_DmaBLen: u32);
}
extern "C" {
    pub fn I2C_TXGDMA_Init(
        Index: u8,
        GDMA_InitStruct: *mut GDMA_InitTypeDef,
        CallbackData: *mut ffi::ctypes::c_void,
        CallbackFunc: IRQ_FUN,
        pTxBuf: *mut u8,
        TxCount: ffi::ctypes::c_int,
    ) -> BOOL;
}
extern "C" {
    pub fn I2C_RXGDMA_Init(
        Index: u8,
        GDMA_InitStruct: *mut GDMA_InitTypeDef,
        CallbackData: *mut ffi::ctypes::c_void,
        CallbackFunc: IRQ_FUN,
        pRxBuf: *mut u8,
        RxCount: ffi::ctypes::c_int,
    ) -> BOOL;
}
extern "C" {
    pub fn I2C_Sleep_Cmd(I2Cx: *mut I2C_TypeDef, NewStatus: u32);
}
extern "C" {
    pub fn I2C_WakeUp(I2Cx: *mut I2C_TypeDef);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct I2C_DevTable {
    pub I2Cx: *mut I2C_TypeDef,
    pub Tx_HandshakeInterface: u32,
    pub Rx_HandshakeInterface: u32,
    pub IrqNum: IRQn_Type,
}
impl Default for I2C_DevTable {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static I2C_DEV_TABLE: [I2C_DevTable; 1usize];
}
extern "C" {
    pub static mut I2C_SLAVEWRITE_PATCH: u32;
}
extern "C" {
    pub static mut IC_FS_SCL_HCNT_TRIM: u32;
}
extern "C" {
    pub static mut IC_FS_SCL_LCNT_TRIM: u32;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct I2S_InitTypeDef {
    pub I2S_SlaveMode: u32,
    pub I2S_WordLen: u32,
    pub I2S_Justify: u32,
    pub I2S_EndianSwap: u32,
    pub I2S_ChNum: u32,
    pub I2S_PageNum: u32,
    pub I2S_PageSize: u32,
    pub I2S_Rate: u32,
    pub I2S_TRxAct: u32,
    pub I2S_InterLoopback: u32,
    pub I2S_Mute: u32,
    pub I2S_BurstSize: u32,
    pub I2S_SckSwap: u32,
    pub I2S_WsSwap: u32,
    pub I2S_EdgeSwap: u32,
}
extern "C" {
    pub fn I2S_Init(I2Sx: *mut I2S_TypeDef, I2S_InitStruct: *mut I2S_InitTypeDef);
}
extern "C" {
    pub fn I2S_Cmd(I2Sx: *mut I2S_TypeDef, NewState: u8);
}
extern "C" {
    pub fn I2S_INTConfig(I2Sx: *mut I2S_TypeDef, I2STxIntrMSK: u32, I2SRxIntrMSK: u32);
}
extern "C" {
    pub fn I2S_SetRate(I2Sx: *mut I2S_TypeDef, I2S_Rate: u32);
}
extern "C" {
    pub fn I2S_GetVersion(I2Sx: *mut I2S_TypeDef) -> u32;
}
extern "C" {
    pub fn I2S_SetMute(I2Sx: *mut I2S_TypeDef, NewState: u32);
}
extern "C" {
    pub fn I2S_SetBurstSize(I2Sx: *mut I2S_TypeDef, I2S_BurstSize: u32);
}
extern "C" {
    pub fn I2S_SetWordLen(I2Sx: *mut I2S_TypeDef, I2S_WordLen: u32);
}
extern "C" {
    pub fn I2S_SetChNum(I2Sx: *mut I2S_TypeDef, I2S_ChNum: u32);
}
extern "C" {
    pub fn I2S_SetPageNum(I2Sx: *mut I2S_TypeDef, I2S_PageNum: u32);
}
extern "C" {
    pub fn I2S_SetPageSize(I2Sx: *mut I2S_TypeDef, I2S_PageSize: u32);
}
extern "C" {
    pub fn I2S_SetDirection(I2Sx: *mut I2S_TypeDef, I2S_TRxAct: u32);
}
extern "C" {
    pub fn I2S_INTClear(I2Sx: *mut I2S_TypeDef, I2STxIntrClr: u32, I2SRxIntrClr: u32);
}
extern "C" {
    pub fn I2S_INTClearAll(I2Sx: *mut I2S_TypeDef);
}
extern "C" {
    pub fn I2S_ISRGet(I2Sx: *mut I2S_TypeDef, I2STxIsr: *mut u32, I2SRxIsr: *mut u32);
}
extern "C" {
    pub fn I2S_SetDMABuf(I2Sx: *mut I2S_TypeDef, I2STxData: *mut u8, I2SRxData: *mut u8);
}
extern "C" {
    pub fn I2S_GetTxPage(I2Sx: *mut I2S_TypeDef) -> u32;
}
extern "C" {
    pub fn I2S_TxPageDMA_EN(I2Sx: *mut I2S_TypeDef, I2STxIdx: u32);
}
extern "C" {
    pub fn I2S_RxPageDMA_EN(I2Sx: *mut I2S_TypeDef, I2SRxIdx: u32);
}
extern "C" {
    pub fn I2S_TxDmaCmd(I2Sx: *mut I2S_TypeDef, NewState: u32);
}
extern "C" {
    pub fn I2S_RxDmaCmd(I2Sx: *mut I2S_TypeDef, NewState: u32);
}
extern "C" {
    pub fn I2S_TxPageBusy(I2Sx: *mut I2S_TypeDef, page_index: u32) -> u32;
}
extern "C" {
    pub fn I2S_SetRxPageAddr(page_index: u32, page_address: u32);
}
extern "C" {
    pub fn I2S_SetTxPageAddr(page_index: u32, page_address: u32);
}
extern "C" {
    pub fn I2S_StructInit(I2S_InitStruct: *mut I2S_InitTypeDef);
}
extern "C" {
    pub fn I2S_GetTxPageAddr(page_index: u32) -> u32;
}
extern "C" {
    pub fn I2S_GetRxPageAddr(page_index: u32) -> u32;
}
extern "C" {
    pub fn I2S_GetRxPage(I2Sx: *mut I2S_TypeDef) -> u32;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ADC_InitTypeDef {
    pub ADC_OpMode: u8,
    pub ADC_CvlistLen: u8,
    pub ADC_Cvlist: [u8; 16usize],
    pub ADC_ClkDiv: u8,
    pub ADC_RxThresholdLevel: u8,
    pub ADC_DMAThresholdLevel: u8,
    pub ADC_SpecialCh: u8,
    pub ADC_ChanInType: u32,
    pub ADC_ChIDEn: u8,
}
extern "C" {
    pub fn ADC_StructInit(ADC_InitStruct: *mut ADC_InitTypeDef);
}
extern "C" {
    pub fn ADC_Init(ADC_InitStruct: *mut ADC_InitTypeDef);
}
extern "C" {
    pub fn ADC_Cmd(NewState: u32);
}
extern "C" {
    pub fn ADC_INTConfig(ADC_IT: u32, NewState: u32);
}
extern "C" {
    pub fn ADC_INTClear();
}
extern "C" {
    pub fn ADC_INTClearPendingBits(ADC_IT: u32);
}
extern "C" {
    pub fn ADC_GetISR() -> u32;
}
extern "C" {
    pub fn ADC_GetRawISR() -> u32;
}
extern "C" {
    pub fn ADC_GetCompStatus(ADC_Channel: u8) -> u32;
}
extern "C" {
    pub fn ADC_GetRxCount() -> u32;
}
extern "C" {
    pub fn ADC_GetLastChan() -> u32;
}
extern "C" {
    pub fn ADC_SetComp(ADC_channel: u8, CompThresH: u16, CompThresL: u16, CompCtrl: u8);
}
extern "C" {
    pub fn ADC_ResetCSwList();
}
extern "C" {
    pub fn ADC_Readable() -> u32;
}
extern "C" {
    pub fn ADC_Read() -> u16;
}
extern "C" {
    pub fn ADC_ReceiveBuf(pBuf: *mut u16, len: u32);
}
extern "C" {
    pub fn ADC_ClearFIFO();
}
extern "C" {
    pub fn ADC_GetStatus() -> u32;
}
extern "C" {
    pub fn ADC_SWTrigCmd(NewState: u32);
}
extern "C" {
    pub fn ADC_AutoCSwCmd(NewState: u32);
}
extern "C" {
    pub fn ADC_TimerTrigCmd(Tim_Idx: u8, PeriodMs: u32, NewState: u32);
}
extern "C" {
    pub fn ADC_SetDmaEnable(newState: u32);
}
extern "C" {
    pub fn ADC_RXGDMA_Init(
        GDMA_InitStruct: *mut GDMA_InitTypeDef,
        CallbackData: *mut ffi::ctypes::c_void,
        CallbackFunc: IRQ_FUN,
        pDataBuf: *mut u8,
        DataLen: u32,
    ) -> u32;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CMP_CHTypeDef {
    pub CMP_ChIndex: u8,
    pub CMP_Ref0: u8,
    pub CMP_Ref1: u8,
    pub CMP_WakeType: u8,
    pub CMP_WakeSysCtrl: u8,
    pub CMP_WakeADCCtrl: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CMP_InitTypeDef {
    pub CMP_ChanCtrl: [CMP_CHTypeDef; 4usize],
}
extern "C" {
    pub fn CMP_StructInit(CMP_InitStruct: *mut CMP_InitTypeDef);
}
extern "C" {
    pub fn CMP_Init(CMP_InitStruct: *mut CMP_InitTypeDef);
}
extern "C" {
    pub fn CMP_Cmd(NewState: u32);
}
extern "C" {
    pub fn CMP_Busy() -> u32;
}
extern "C" {
    pub fn CMP_GetISR() -> u32;
}
extern "C" {
    pub fn CMP_INTClearPendingBit(Cmp_IT: u32);
}
extern "C" {
    pub fn CMP_GetCompStatus(channel: u8) -> u32;
}
extern "C" {
    pub fn CMP_GetLastChan() -> u32;
}
extern "C" {
    pub fn CMP_ResetCSwList();
}
extern "C" {
    pub fn CMP_AutoCSwCmd(NewState: u32);
}
extern "C" {
    pub fn CMP_TimerTrigCmd(Tim_Idx: u8, PeriodMs: u32, NewState: u32);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SDIO_InitTypeDef {
    pub TXBD_BAR: u32,
    pub TXBD_RING_SIZE: u32,
    pub TX_BUFFER_SIZE: u32,
    pub RXBD_BAR: u32,
    pub RXBD_RING_SIZE: u32,
    pub RXBD_FREE_TH: u32,
}
extern "C" {
    pub fn SDIO_StructInit(SDIO_InitStruct: *mut SDIO_InitTypeDef);
}
extern "C" {
    pub fn SDIO_Init(SDIOInit_Struct: *mut SDIO_InitTypeDef);
}
extern "C" {
    pub fn SDIO_INTClear();
}
extern "C" {
    pub fn SDIO_INTConfig(IntMask: u16, NewState: u32);
}
extern "C" {
    pub fn SDIO_RPWM1_Get() -> u8;
}
extern "C" {
    pub fn SDIO_RPWM2_Get() -> u16;
}
extern "C" {
    pub fn SDIO_CPWM1_Set(Val: u8);
}
extern "C" {
    pub fn SDIO_CPWM2_Set(Val: u16, Newstate: u32);
}
extern "C" {
    pub fn SDIO_RXBD_RPTR_Get() -> u16;
}
extern "C" {
    pub fn SDIO_RXBD_WPTR_Set(Val: u16);
}
extern "C" {
    pub fn SDIO_TXBD_WPTR_Get() -> u16;
}
extern "C" {
    pub fn SDIO_TXBD_RPTR_Set(Val: u16);
}
extern "C" {
    pub fn SDIO_DMA_Reset();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WDG_InitTypeDef {
    pub CountProcess: u32,
    pub DivFacProcess: u32,
    pub RstAllPERI: u32,
}
extern "C" {
    pub fn WDG_Scalar(Period: u32, pCountProcess: *mut u32, pDivFacProcess: *mut u32);
}
extern "C" {
    pub fn WDG_Init(WDG_InitStruct: *mut WDG_InitTypeDef);
}
extern "C" {
    pub fn WDG_IrqInit(handler: *mut ffi::ctypes::c_void, Id: u32);
}
extern "C" {
    pub fn WDG_Cmd(NewState: u32);
}
extern "C" {
    pub fn WDG_Refresh();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct RTC_InitTypeDef {
    pub RTC_HourFormat: u32,
    pub RTC_AsynchPrediv: u32,
    pub RTC_SynchPrediv: u32,
    pub RTC_DayThreshold: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct RTC_TimeTypeDef {
    pub RTC_Days: u16,
    pub RTC_Hours: u8,
    pub RTC_Minutes: u8,
    pub RTC_Seconds: u8,
    pub RTC_H12_PMAM: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct RTC_AlarmTypeDef {
    pub RTC_AlarmTime: RTC_TimeTypeDef,
    pub RTC_AlarmMask: u32,
    pub RTC_Alarm2Mask: u32,
}
extern "C" {
    pub fn RTC_BypassShadowCmd(NewState: u32) -> u32;
}
extern "C" {
    pub fn RTC_StructInit(RTC_InitStruct: *mut RTC_InitTypeDef);
}
extern "C" {
    pub fn RTC_Init(RTC_InitStruct: *mut RTC_InitTypeDef) -> u32;
}
extern "C" {
    pub fn RTC_TimeStructInit(RTC_TimeStruct: *mut RTC_TimeTypeDef);
}
extern "C" {
    pub fn RTC_SetTime(RTC_Format: u32, RTC_TimeStruct: *mut RTC_TimeTypeDef) -> u32;
}
extern "C" {
    pub fn RTC_GetTime(RTC_Format: u32, RTC_TimeStruct: *mut RTC_TimeTypeDef);
}
extern "C" {
    pub fn RTC_DayIntClear();
}
extern "C" {
    pub fn RTC_DayIntCmd(NewState: u32) -> u32;
}
extern "C" {
    pub fn RTC_DayThresSet(DayThres: u32) -> u32;
}
extern "C" {
    pub fn RTC_DayThresGet() -> u32;
}
extern "C" {
    pub fn RTC_SetAlarm(RTC_Format: u32, RTC_AlarmStruct: *mut RTC_AlarmTypeDef) -> u32;
}
extern "C" {
    pub fn RTC_AlarmStructInit(RTC_AlarmStruct: *mut RTC_AlarmTypeDef);
}
extern "C" {
    pub fn RTC_GetAlarm(RTC_Format: u32, RTC_AlarmStruct: *mut RTC_AlarmTypeDef);
}
extern "C" {
    pub fn RTC_AlarmCmd(NewState: u32);
}
extern "C" {
    pub fn RTC_AlarmClear();
}
extern "C" {
    pub fn RTC_DayLightSavingConfig(RTC_DayLightSaving: u32, RTC_StoreOperation: u32) -> u32;
}
extern "C" {
    pub fn RTC_GetStoreOperation() -> u32;
}
extern "C" {
    pub fn RTC_OutputConfig(RTC_Output: u32) -> u32;
}
extern "C" {
    pub fn RTC_SmoothCalibConfig(
        CalibSign: u32,
        Value: u32,
        CalibPeriod: u32,
        Calib_Enable: u32,
    ) -> u32;
}
extern "C" {
    pub fn RTC_32KAutoCalibConfig(Cal_Period: u32, Unit_Sel: u32) -> u32;
}
extern "C" {
    pub fn SYSTIMER_Init();
}
extern "C" {
    pub fn SYSTIMER_TickGet() -> u32;
}
extern "C" {
    pub fn SYSTIMER_GetPassTime(start: u32) -> u32;
}
extern "C" {
    pub fn DelayUs(us: u32);
}
extern "C" {
    pub fn DelayMs(ms: u32);
}
extern "C" {
    pub fn DelayNop(count: u32);
}
extern "C" {
    pub static mut RBSS_UDELAY_DIV: u32;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IR_InitTypeDef {
    pub IR_Clock: u32,
    pub IR_Freq: u32,
    pub IR_DutyCycle: u32,
    pub IR_Mode: u32,
    pub IR_TxIdleLevel: u32,
    pub IR_TxInverse: u32,
    pub IR_TxFIFOThrLevel: u32,
    pub IR_TxCOMP_CLK: u32,
    pub IR_RxStartMode: u32,
    pub IR_RxFIFOThrLevel: u32,
    pub IR_RxFIFOFullCtrl: u32,
    pub IR_RxTriggerMode: u32,
    pub IR_RxFilterTime: u32,
    pub IR_RxCntThrType: u32,
    pub IR_RxCntThr: u32,
}
pub type PIR_InitTypeDef = *mut IR_InitTypeDef;
extern "C" {
    pub fn IR_DeInit();
}
extern "C" {
    pub fn IR_Init(IRx: *mut IR_TypeDef, IR_InitStruct: *mut IR_InitTypeDef);
}
extern "C" {
    pub fn IR_StructInit(IR_InitStruct: *mut IR_InitTypeDef);
}
extern "C" {
    pub fn IR_Cmd(IRx: *mut IR_TypeDef, mode: u32, NewState: u32);
}
extern "C" {
    pub fn IR_SetRxCounterThreshold(IRx: *mut IR_TypeDef, IR_RxCntThrType: u32, IR_RxCntThr: u32);
}
extern "C" {
    pub fn IR_SendBuf(IRx: *mut IR_TypeDef, pBuf: *mut u32, len: u32, IsLastPacket: u32);
}
extern "C" {
    pub fn IR_ReceiveBuf(IRx: *mut IR_TypeDef, pBuf: *mut u32, len: u32);
}
extern "C" {
    pub fn IR_INTConfig(IRx: *mut IR_TypeDef, IR_INT: u32, newState: u32);
}
extern "C" {
    pub fn IR_MaskINTConfig(IRx: *mut IR_TypeDef, IR_INT: u32, newState: u32);
}
extern "C" {
    pub fn IR_GetINTStatus(IRx: *mut IR_TypeDef) -> u32;
}
extern "C" {
    pub fn IR_GetIMR(IRx: *mut IR_TypeDef) -> u32;
}
extern "C" {
    pub fn IR_FSMRunning(IRx: *mut IR_TypeDef) -> u32;
}
extern "C" {
    pub fn IR_ClearINTPendingBit(IRx: *mut IR_TypeDef, IR_CLEAR_INT: u32);
}
extern "C" {
    pub fn IR_SetTxThreshold(IRx: *mut IR_TypeDef, thd: u8);
}
extern "C" {
    pub fn IR_SetRxThreshold(IRx: *mut IR_TypeDef, thd: u8);
}
extern "C" {
    pub fn IR_GetTxFIFOFreeLen(IRx: *mut IR_TypeDef) -> u32;
}
extern "C" {
    pub fn IR_GetRxDataLen(IRx: *mut IR_TypeDef) -> u32;
}
extern "C" {
    pub fn IR_SendData(IRx: *mut IR_TypeDef, data: u32);
}
extern "C" {
    pub fn IR_StartManualRxTrigger(IRx: *mut IR_TypeDef);
}
extern "C" {
    pub fn IR_ReceiveData(IRx: *mut IR_TypeDef) -> u32;
}
extern "C" {
    pub fn IR_ClearTxFIFO(IRx: *mut IR_TypeDef);
}
extern "C" {
    pub fn IR_ClearRxFIFO(IRx: *mut IR_TypeDef);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct KeyScan_InitTypeDef {
    pub KS_ClkDiv: u32,
    pub KS_WorkMode: u32,
    pub KS_RowSel: u32,
    pub KS_ColSel: u32,
    pub KS_DebounceCnt: u32,
    pub KS_IntervalCnt: u32,
    pub KS_ReleaseCnt: u32,
    pub KS_LimitLevel: u32,
    pub KS_ThreholdLevel: u32,
    pub KS_OverCtrl: u32,
}
extern "C" {
    pub fn KeyScan_StructInit(KeyScan_InitStruct: *mut KeyScan_InitTypeDef);
}
extern "C" {
    pub fn KeyScan_Init(
        KeyScan: *mut KEYSCAN_TypeDef,
        KeyScan_InitStruct: *mut KeyScan_InitTypeDef,
    );
}
extern "C" {
    pub fn KeyScan_INTConfig(KeyScan: *mut KEYSCAN_TypeDef, KeyScan_IT: u32, newState: u8);
}
extern "C" {
    pub fn KeyScan_ClearINT(KeyScan: *mut KEYSCAN_TypeDef, KeyScan_IT: u32);
}
extern "C" {
    pub fn KeyScan_GetRawINT(KeyScan: *mut KEYSCAN_TypeDef) -> u32;
}
extern "C" {
    pub fn KeyScan_GetINT(KeyScan: *mut KEYSCAN_TypeDef) -> u32;
}
extern "C" {
    pub fn KeyScan_GetDataNum(KeyScan: *mut KEYSCAN_TypeDef) -> u8;
}
extern "C" {
    pub fn KeyScan_ClearFIFOData(KeyScan: *mut KEYSCAN_TypeDef);
}
extern "C" {
    pub fn KeyScan_GetFIFOState(KeyScan: *mut KEYSCAN_TypeDef, KeyScan_Flag: u32) -> BOOL;
}
extern "C" {
    pub fn KeyScan_Read(KeyScan: *mut KEYSCAN_TypeDef, outBuf: *mut u32, count: u8);
}
extern "C" {
    pub fn KeyScan_Cmd(KeyScan: *mut KEYSCAN_TypeDef, NewState: u8);
}
extern "C" {
    pub fn KeyScan_SetColRow(KeyScan: *mut KEYSCAN_TypeDef, column_sel: u32, row_sel: u32);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SGPIO_RXInitTypeDef {
    pub RxTimerEdge_Sel: u32,
    pub RxDataSrc_Sel: u32,
    pub RxPRVal: u32,
    pub RxPRTC: u32,
    pub RxTC: u32,
    pub RxData: u32,
    pub RxData_DP: u32,
    pub RxPosTC: u32,
    pub RxData_Dir: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SGPIO_CAPInitTypeDef {
    pub Cap_ValidEn: u32,
    pub Cap_RxTCStop_Ctrl: u32,
    pub Cap_RxTCRst_Ctrl: u32,
    pub CapSrc_Sel: u32,
    pub CapEdge_Sel: u32,
    pub CapI_En: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SGPIO_MULInitTypeDef {
    pub BiOut: u32,
    pub MulMode_Sel: u32,
    pub MulPRVal: u32,
    pub MulPRTC: u32,
    pub MulTC: u32,
    pub MulPosTC: u32,
    pub MulPosRST: u32,
    pub MulData_Dir: u32,
}
extern "C" {
    pub fn SGPIO_RX_StructInit(SGPIO_RXInitStruct: *mut SGPIO_RXInitTypeDef);
}
extern "C" {
    pub fn SGPIO_RX_Init(SGPIOx: *mut SGPIO_TypeDef, SGPIO_RXInitStruct: *mut SGPIO_RXInitTypeDef);
}
extern "C" {
    pub fn SGPIO_RXMR0MULConfig(
        SGPIOx: *mut SGPIO_TypeDef,
        SGPIO_RXMR0Val: u32,
        SGPIO_RXMR0MULCtl: u32,
    );
}
extern "C" {
    pub fn SGPIO_RXPosConfig(SGPIOx: *mut SGPIO_TypeDef, SGPIO_PosRstVal: u32, SGPIO_RXPOSCtl: u32);
}
extern "C" {
    pub fn SGPIO_GetRXData(SGPIOx: *mut SGPIO_TypeDef) -> u32;
}
extern "C" {
    pub fn SGPIO_RXMR0Config(SGPIOx: *mut SGPIO_TypeDef, SGPIO_RXMR0Val: u32, SGPIO_RXMR0Ctl: u32);
}
extern "C" {
    pub fn SGPIO_RXMR1Config(SGPIOx: *mut SGPIO_TypeDef, SGPIO_RXMR1Val: u32, SGPIO_RXMR1Ctl: u32);
}
extern "C" {
    pub fn SGPIO_RXMR2Config(SGPIOx: *mut SGPIO_TypeDef, SGPIO_RXMR2Val: u32, SGPIO_RXMR2Ctl: u32);
}
extern "C" {
    pub fn SGPIO_RXMRxTXConfig(
        SGPIOx: *mut SGPIO_TypeDef,
        SGPIO_RXMR0TXCtl: u32,
        SGPIO_RXMR1TXCtl: u32,
        SGPIO_RXMR2TXCtl: u32,
    );
}
extern "C" {
    pub fn SGPIO_RXTmr_Reset(SGPIOx: *mut SGPIO_TypeDef);
}
extern "C" {
    pub fn SGPIO_RXTmr_Cmd(SGPIOx: *mut SGPIO_TypeDef, NewState: u8);
}
extern "C" {
    pub fn SGPIO_RXPatternMatchConfig(
        SGPIOx: *mut SGPIO_TypeDef,
        RXDATADP: u32,
        RXDATAMask: u32,
        NewState: u8,
    );
}
extern "C" {
    pub fn SGPIO_MUL_StructInit(SGPIO_MULInitStruct: *mut SGPIO_MULInitTypeDef);
}
extern "C" {
    pub fn SGPIO_MUL_Init(
        SGPIOx: *mut SGPIO_TypeDef,
        SGPIO_MULInitStruct: *mut SGPIO_MULInitTypeDef,
    );
}
extern "C" {
    pub fn SGPIO_MULMR0MulConfig(
        SGPIOx: *mut SGPIO_TypeDef,
        SGPIO_MULMR0Val0: u32,
        SGPIO_MULMR0Val1: u32,
        SGPIO_MULMR0Ctl: u32,
    );
}
extern "C" {
    pub fn SGPIO_MULMR0RXConfig(
        SGPIOx: *mut SGPIO_TypeDef,
        SGPIO_MULMR0Val0: u32,
        SGPIO_MULMR0Val1: u32,
        SGPIO_MULMR0RXCtl: u32,
    );
}
extern "C" {
    pub fn SGPIO_MULMRxGP0ValConfig(
        SGPIOx: *mut SGPIO_TypeDef,
        SGPIO_MULMR0GP0: u32,
        SGPIO_MULMR1GP0: u32,
        SGPIO_MULMR2GP0: u32,
        SGPIO_MULMR3GP0: u32,
    );
}
extern "C" {
    pub fn SGPIO_MULMRxGP1ValConfig(
        SGPIOx: *mut SGPIO_TypeDef,
        SGPIO_MULMR0GP1: u32,
        SGPIO_MULMR1GP1: u32,
        SGPIO_MULMR2GP1: u32,
        SGPIO_MULMR3GP1: u32,
    );
}
extern "C" {
    pub fn SGPIO_MULMRxTXCtlConfig(
        SGPIOx: *mut SGPIO_TypeDef,
        SGPIO_MULMR0TXCtl: u32,
        SGPIO_MULMR1TXCtl: u32,
        SGPIO_MULMR2TXCtl: u32,
        SGPIO_MULMR3TXCtl: u32,
    );
}
extern "C" {
    pub fn SGPIO_SetTXData(
        SGPIOx: *mut SGPIO_TypeDef,
        SGPIO_MulDataVal: u32,
        SGPIO_MulDataDPVal: u32,
    );
}
extern "C" {
    pub fn SGPIO_OutputConfig(SGPIOx: *mut SGPIO_TypeDef, SGPIO_OutputCtl: u32);
}
extern "C" {
    pub fn SGPIO_MULTmr_Reset(SGPIOx: *mut SGPIO_TypeDef);
}
extern "C" {
    pub fn SGPIO_MULTmr_Cmd(SGPIOx: *mut SGPIO_TypeDef, NewState: u8);
}
extern "C" {
    pub fn SGPIO_MULMCNTConfig(
        SGPIOx: *mut SGPIO_TypeDef,
        SGPIO_MULMCNTVal: u32,
        SGPIO_MULMCNTCtl: u32,
    );
}
extern "C" {
    pub fn SGPIO_MULMCNT_Cmd(SGPIOx: *mut SGPIO_TypeDef, NewState: u8);
}
extern "C" {
    pub fn SGPIO_CAP_StructInit(SGPIO_CAPInitStruct: *mut SGPIO_CAPInitTypeDef);
}
extern "C" {
    pub fn SGPIO_CAP_Init(
        SGPIOx: *mut SGPIO_TypeDef,
        SGPIO_CAPInitStruct: *mut SGPIO_CAPInitTypeDef,
    );
}
extern "C" {
    pub fn SGPIO_GetCapVal(SGPIOx: *mut SGPIO_TypeDef) -> u32;
}
extern "C" {
    pub fn SGPIO_Cap_CompConfig(SGPIOx: *mut SGPIO_TypeDef, CapComp_Val: u32, CapComp_Mode: u32);
}
extern "C" {
    pub fn SGPIO_Cap_Cmd(SGPIOx: *mut SGPIO_TypeDef, NewState: u8);
}
extern "C" {
    pub fn SGPIO_INTConfig(SGPIOx: *mut SGPIO_TypeDef, SGPIO_IT: u32, NewState: u32);
}
extern "C" {
    pub fn SGPIO_INTMask(SGPIOx: *mut SGPIO_TypeDef, SGPIO_IT: u32, NewState: u32);
}
extern "C" {
    pub fn SGPIO_GetRawINT(SGPIOx: *mut SGPIO_TypeDef) -> u32;
}
extern "C" {
    pub fn SGPIO_ClearRawINT(SGPIOx: *mut SGPIO_TypeDef, SGPIO_IT: u32);
}
extern "C" {
    pub fn SGPIO_MULFIFO_Cmd(SGPIOx: *mut SGPIO_TypeDef, NewState: u8);
}
extern "C" {
    pub fn SGPIO_MULFIFO_Set(SGPIOx: *mut SGPIO_TypeDef, SGPIO_MULFIFOVal: u32);
}
extern "C" {
    pub fn SGPIO_MULDMA_Cmd(SGPIOx: *mut SGPIO_TypeDef, NewState: u8);
}
extern "C" {
    pub fn SGPIO_MULGDMA_Init(
        SGPIOx: *mut SGPIO_TypeDef,
        GDMA_InitStruct: *mut GDMA_InitTypeDef,
        CallbackData: *mut ffi::ctypes::c_void,
        CallbackFunc: IRQ_FUN,
        pTxBuf: *mut u32,
        TxCount: ffi::ctypes::c_int,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct QDEC_InitTypeDef {
    pub QD_SysClk: u32,
    pub QD_SmpClk: u32,
    pub QD_DebounceTmr: u32,
    pub QD_Rc_Mod: u32,
    pub QD_Cnt_Sc: u32,
    pub QD_MPC: u32,
    pub QD_IdxMod: u32,
    pub QD_PC_Rst_Mod: u32,
    pub QD_PC_Rst_Phase: u32,
    pub QD_VTmr: u32,
    pub QD_VCMod: u32,
}
extern "C" {
    pub fn QDEC_DeInit();
}
extern "C" {
    pub fn QDEC_Init(QDec: *mut QDEC_TypeDef, QDEC_InitStruct: *mut QDEC_InitTypeDef);
}
extern "C" {
    pub fn QDEC_StructInit(QDEC_InitStruct: *mut QDEC_InitTypeDef);
}
extern "C" {
    pub fn QDEC_Cmd(QDec: *mut QDEC_TypeDef, NewState: u32);
}
extern "C" {
    pub fn QDEC_RstPC(QDec: *mut QDEC_TypeDef);
}
extern "C" {
    pub fn QDEC_RstRC(QDec: *mut QDEC_TypeDef);
}
extern "C" {
    pub fn QDEC_RstALL(QDec: *mut QDEC_TypeDef);
}
extern "C" {
    pub fn QDEC_SetCntSC(QDec: *mut QDEC_TypeDef, cnt_sc: u32);
}
extern "C" {
    pub fn QDEC_SetPChg(QDec: *mut QDEC_TypeDef, Pchange: u32);
}
extern "C" {
    pub fn QDEC_SetPCC(QDec: *mut QDEC_TypeDef, CmpPC: u32);
}
extern "C" {
    pub fn QDEC_SetMPC(QDec: *mut QDEC_TypeDef, MaxPC: u32);
}
extern "C" {
    pub fn QDEC_SetRCC(QDec: *mut QDEC_TypeDef, CmpRC: u32);
}
extern "C" {
    pub fn QDEC_GetRC(QDec: *mut QDEC_TypeDef) -> u32;
}
extern "C" {
    pub fn QDEC_GetPhase(QDec: *mut QDEC_TypeDef) -> u32;
}
extern "C" {
    pub fn QDEC_GetDir(QDec: *mut QDEC_TypeDef) -> u32;
}
extern "C" {
    pub fn QDEC_GetPC(QDec: *mut QDEC_TypeDef) -> u32;
}
extern "C" {
    pub fn QDEC_Idx_Cmd(QDec: *mut QDEC_TypeDef, NewState: u32);
}
extern "C" {
    pub fn QDEC_SetRstMod(QDec: *mut QDEC_TypeDef, mode: u32, phase: u32);
}
extern "C" {
    pub fn QDEC_SetVTmr(QDec: *mut QDEC_TypeDef, duration: u32);
}
extern "C" {
    pub fn QDEC_SetVcMod(QDec: *mut QDEC_TypeDef, mode: u32);
}
extern "C" {
    pub fn QDEC_VT_Cmd(QDec: *mut QDEC_TypeDef, NewState: u32);
}
extern "C" {
    pub fn QDEC_VtRst(QDec: *mut QDEC_TypeDef);
}
extern "C" {
    pub fn QDEC_SetVcUpLmt(QDec: *mut QDEC_TypeDef, limt: u32);
}
extern "C" {
    pub fn QDEC_SetVcLowLmt(QDec: *mut QDEC_TypeDef, limt: u32);
}
extern "C" {
    pub fn QDEC_GetVT(QDec: *mut QDEC_TypeDef) -> u32;
}
extern "C" {
    pub fn QDEC_GetVC(QDec: *mut QDEC_TypeDef) -> u32;
}
extern "C" {
    pub fn QDEC_GetVCCAP(QDec: *mut QDEC_TypeDef) -> u32;
}
extern "C" {
    pub fn QDEC_GetPCCAP(QDec: *mut QDEC_TypeDef) -> u32;
}
extern "C" {
    pub fn QDEC_INTConfig(QDec: *mut QDEC_TypeDef, INT: u32, newState: u32);
}
extern "C" {
    pub fn QDEC_INTMask(QDec: *mut QDEC_TypeDef, mask: u32, newState: u32);
}
extern "C" {
    pub fn QDEC_ClearINT(QDec: *mut QDEC_TypeDef, INT: u32);
}
extern "C" {
    pub fn QDEC_GetRawINT(QDec: *mut QDEC_TypeDef) -> u32;
}
extern "C" {
    pub fn QDEC_GetIMR(QDec: *mut QDEC_TypeDef) -> u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct USI_DevTable {
    pub USIx: *mut USI_TypeDef,
    pub Tx_HandshakeInterface: u32,
    pub Rx_HandshakeInterface: u32,
    pub IrqNum: IRQn_Type,
}
impl Default for USI_DevTable {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static USI_DEV_TABLE: [USI_DevTable; 1usize];
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct USI_UARTInitTypeDef {
    pub USI_UARTDmaModeCtrl: u32,
    pub USI_UARTWordLen: u32,
    pub USI_UARTStopBit: u32,
    pub USI_UARTParity: u32,
    pub USI_UARTParityType: u32,
    pub USI_UARTStickParity: u32,
    pub USI_UARTFlowControl: u32,
    pub USI_UARTFlwCtrlRxHoldThd: u32,
    pub USI_UARTRxFifoTrigLevel: u32,
    pub USI_UARTTxFifoTrigLevel: u32,
    pub USI_UARTRxTimeOutCnt: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct USI_LPUARTInitTypeDef {
    pub USI_LPUARTOscPerbitUpdCtrl: u32,
    pub USI_LPUARTBitNumThres: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct USI_UartIrDAInitTypeDef {
    pub USI_UARTIrDARxInv: u32,
    pub USI_UARTIrDATxInv: u32,
    pub USI_UARTUpperShift: u32,
    pub USI_UARTUpperShiftVal: u32,
    pub USI_UARTLowShift: u32,
    pub USI_UARTLowShiftVal: u32,
    pub USI_UARTRxFilterThres: u32,
    pub USI_UARTRxFilterCmd: u32,
}
extern "C" {
    pub fn USI_UARTDeInit(USIx: *mut USI_TypeDef);
}
extern "C" {
    pub fn USI_UARTStructInit(USI_UARTInitStruct: *mut USI_UARTInitTypeDef);
}
extern "C" {
    pub fn USI_UARTInit(USIx: *mut USI_TypeDef, USI_UARTInitStruct: *mut USI_UARTInitTypeDef);
}
extern "C" {
    pub fn USI_UARTBaudParaGet(baudrate: u32, ovsr: *mut u32, ovsr_adj: *mut u32) -> u32;
}
extern "C" {
    pub fn USI_UARTBaudParaGetFull(IPclk: u32, baudrate: u32, ovsr: *mut u32, ovsr_adj: *mut u32);
}
extern "C" {
    pub fn USI_UARTSetBaudExt(USIx: *mut USI_TypeDef, Ovsr: u32, Ovsr_adj: u32);
}
extern "C" {
    pub fn USI_UARTSetBaud(USIx: *mut USI_TypeDef, BaudRate: u32);
}
extern "C" {
    pub fn USI_UARTSetRxLevel(USIx: *mut USI_TypeDef, FifoLv: u32);
}
extern "C" {
    pub fn USI_UARTRxCmd(USIx: *mut USI_TypeDef, NewState: u32);
}
extern "C" {
    pub fn USI_UARTWritable(USIx: *mut USI_TypeDef) -> u32;
}
extern "C" {
    pub fn USI_UARTReadable(USIx: *mut USI_TypeDef) -> u32;
}
extern "C" {
    pub fn USI_UARTCharPut(USIx: *mut USI_TypeDef, TxData: u8);
}
extern "C" {
    pub fn USI_UARTCharGet(USIx: *mut USI_TypeDef, pRxByte: *mut u8);
}
extern "C" {
    pub fn USI_UARTReceiveData(USIx: *mut USI_TypeDef, OutBuf: *mut u8, Count: u32);
}
extern "C" {
    pub fn USI_UARTSendData(USIx: *mut USI_TypeDef, InBuf: *mut u8, Count: u32);
}
extern "C" {
    pub fn USI_UARTReceiveDataTO(
        USIx: *mut USI_TypeDef,
        OutBuf: *mut u8,
        Count: u32,
        Times: u32,
    ) -> u32;
}
extern "C" {
    pub fn USI_UARTSendDataTO(
        USIx: *mut USI_TypeDef,
        InBuf: *mut u8,
        Count: u32,
        Times: u32,
    ) -> u32;
}
extern "C" {
    pub fn USI_UARTRxByteCntClear(USIx: *mut USI_TypeDef);
}
extern "C" {
    pub fn USI_UARTRxByteCntGet(USIx: *mut USI_TypeDef) -> u32;
}
extern "C" {
    pub fn USI_UARTBreakCtl(USIx: *mut USI_TypeDef, NewState: u32);
}
extern "C" {
    pub fn USI_UARTClearRxFifo(USIx: *mut USI_TypeDef) -> u32;
}
extern "C" {
    pub fn USI_UARTClearTxFifo(USIx: *mut USI_TypeDef);
}
extern "C" {
    pub fn USI_UARTGetRxFifoValidCnt(USIx: *mut USI_TypeDef) -> u32;
}
extern "C" {
    pub fn USI_UARTGetTxFifoEmptyCnt(USIx: *mut USI_TypeDef) -> u32;
}
extern "C" {
    pub fn USI_UARTINTConfig(USIx: *mut USI_TypeDef, UART_IT: u32, newState: u32);
}
extern "C" {
    pub fn USI_UARTIntStatus(USIx: *mut USI_TypeDef) -> u32;
}
extern "C" {
    pub fn USI_UARTGetRawIntStatus(USIx: *mut USI_TypeDef) -> u32;
}
extern "C" {
    pub fn USI_UARTClearAllIntStatus(USIx: *mut USI_TypeDef);
}
extern "C" {
    pub fn USI_UARTClearIntStatus(USIx: *mut USI_TypeDef, USIUART_IT: u32);
}
extern "C" {
    pub fn USI_UARTWaitBusy(USIx: *mut USI_TypeDef, PollTimes: u32);
}
extern "C" {
    pub fn USI_UARTRxTimeOutConfig(USIx: *mut USI_TypeDef, TimeOutCnt: u32);
}
extern "C" {
    pub fn USI_UARTRxDMAModeConfig(USIx: *mut USI_TypeDef, Mode: u32);
}
extern "C" {
    pub fn USI_UARTRxDMADummyDataConfig(USIx: *mut USI_TypeDef, Byte: u8);
}
extern "C" {
    pub fn USI_UARTGetRxDMADummyFlag(USIx: *mut USI_TypeDef) -> u32;
}
extern "C" {
    pub fn USI_UARTRxClearDMADummyFlag(USIx: *mut USI_TypeDef);
}
extern "C" {
    pub fn USI_UARTTXDMAConfig(USIx: *mut USI_TypeDef, TxDmaBurstSize: u32);
}
extern "C" {
    pub fn USI_UARTRXDMAConfig(USIx: *mut USI_TypeDef, RxDmaBurstSize: u32);
}
extern "C" {
    pub fn USI_UARTTXDMACmd(USIx: *mut USI_TypeDef, NewState: u32);
}
extern "C" {
    pub fn USI_UARTRXDMACmd(USIx: *mut USI_TypeDef, NewState: u32);
}
extern "C" {
    pub fn USI_UARTTXGDMA_Init(
        USIIndex: u8,
        GDMA_InitStruct: *mut GDMA_InitTypeDef,
        CallbackData: *mut ffi::ctypes::c_void,
        CallbackFunc: IRQ_FUN,
        pTxBuf: *mut u8,
        TxCount: ffi::ctypes::c_int,
    ) -> BOOL;
}
extern "C" {
    pub fn USI_UARTRXGDMA_Init(
        USIIndex: u8,
        GDMA_InitStruct: *mut GDMA_InitTypeDef,
        CallbackData: *mut ffi::ctypes::c_void,
        CallbackFunc: IRQ_FUN,
        pRxBuf: *mut u8,
        RxCount: ffi::ctypes::c_int,
    ) -> BOOL;
}
extern "C" {
    pub fn USI_UARTLPRxStructInit(USI_UARTInitStruct: *mut USI_LPUARTInitTypeDef);
}
extern "C" {
    pub fn USI_UARTLPRxInit(USIx: *mut USI_TypeDef, USI_UARTInitStruct: *mut USI_LPUARTInitTypeDef);
}
extern "C" {
    pub fn USI_UARTLPRxBaudSet(USIx: *mut USI_TypeDef, BaudRate: u32, RxIPClockHz: u32);
}
extern "C" {
    pub fn USI_UART_LPRxMonitorCmd(USIx: *mut USI_TypeDef, NewState: u32);
}
extern "C" {
    pub fn USI_UARTLPRxpathSet(USIx: *mut USI_TypeDef, LPRxpath: u32);
}
extern "C" {
    pub fn USI_UARTLPRxIPClockSet(USIx: *mut USI_TypeDef, RxIPClock: u32);
}
extern "C" {
    pub fn USI_UARTLPRxCmd(USIx: *mut USI_TypeDef, NewState: u32);
}
extern "C" {
    pub fn USI_UARTIrDAStructInit(IrDA_InitStruct: *mut USI_UartIrDAInitTypeDef);
}
extern "C" {
    pub fn USI_UARTIrDAInit(USIx: *mut USI_TypeDef, IrDA_InitStruct: *mut USI_UartIrDAInitTypeDef);
}
extern "C" {
    pub fn USI_UARTIrDACmd(USIx: *mut USI_TypeDef, NewState: u32);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct USI_UARTCFG_TypeDef {
    pub LOW_POWER_RX_ENABLE: u32,
}
extern "C" {
    pub static mut usi_uart_config: [USI_UARTCFG_TypeDef; 0usize];
}
extern "C" {
    pub static mut USI_UART_StateTx: [u32; 1usize];
}
extern "C" {
    pub static mut USI_UART_StateRx: [u32; 1usize];
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct USI_SSI_InitTypeDef {
    pub USI_SPI_DmaRxDataLevel: u32,
    pub USI_SPI_DmaTxDataLevel: u32,
    pub USI_SPI_RxThresholdLevel: u32,
    pub USI_SPI_TxThresholdLevel: u32,
    pub USI_SPI_ClockDivider: u32,
    pub USI_SPI_DataFrameNumber: u32,
    pub USI_SPI_DataFrameSize: u32,
    pub USI_SPI_InterruptMask: u32,
    pub USI_SPI_Role: u32,
    pub USI_SPI_SclkPhase: u32,
    pub USI_SPI_SclkPolarity: u32,
    pub USI_SPI_TransferMode: u32,
    pub USI_SPI_RxSampleDelay: u32,
    pub USI_SPI_SSTogglePhase: u32,
}
extern "C" {
    pub fn USI_SSI_StructInit(USI_SSI_InitStruct: *mut USI_SSI_InitTypeDef);
}
extern "C" {
    pub fn USI_SSI_Init(usi_dev: *mut USI_TypeDef, USI_SSI_InitStruct: *mut USI_SSI_InitTypeDef);
}
extern "C" {
    pub fn USI_SSI_Cmd(usi_dev: *mut USI_TypeDef, NewStatus: u32);
}
extern "C" {
    pub fn USI_SSI_TRxPath_Cmd(usi_dev: *mut USI_TypeDef, path: u32, NewStatus: u32);
}
extern "C" {
    pub fn USI_SSI_GetTRxPath(usi_dev: *mut USI_TypeDef) -> u32;
}
extern "C" {
    pub fn USI_SSI_INTConfig(usi_dev: *mut USI_TypeDef, USI_SSI_IT: u32, newState: u32);
}
extern "C" {
    pub fn USI_SSI_SetSclkPolarity(usi_dev: *mut USI_TypeDef, SclkPolarity: u32);
}
extern "C" {
    pub fn USI_SSI_SetSclkPhase(usi_dev: *mut USI_TypeDef, SclkPhase: u32);
}
extern "C" {
    pub fn USI_SSI_SetSSTogglePhase(usi_dev: *mut USI_TypeDef, TogglePhase: u32);
}
extern "C" {
    pub fn USI_SSI_SetDataFrameSize(usi_dev: *mut USI_TypeDef, DataFrameSize: u32);
}
extern "C" {
    pub fn USI_SSI_SetSampleDelay(usi_dev: *mut USI_TypeDef, SampleDelay: u32);
}
extern "C" {
    pub fn USI_SSI_SetReadLen(usi_dev: *mut USI_TypeDef, DataFrameNumber: u32);
}
extern "C" {
    pub fn USI_SSI_SetBaudDiv(usi_dev: *mut USI_TypeDef, ClockDivider: u32);
}
extern "C" {
    pub fn USI_SSI_SetBaud(USIx: *mut USI_TypeDef, BaudRate: u32, IpClk: u32);
}
extern "C" {
    pub fn USI_SSI_SetIsrClean(usi_dev: *mut USI_TypeDef, InterruptStatus: u32);
}
extern "C" {
    pub fn USI_SSI_WriteData(usi_dev: *mut USI_TypeDef, value: u32);
}
extern "C" {
    pub fn USI_SSI_SetRxFifoLevel(usi_dev: *mut USI_TypeDef, RxThresholdLevel: u32);
}
extern "C" {
    pub fn USI_SSI_SetTxFifoLevel(usi_dev: *mut USI_TypeDef, TxThresholdLevel: u32);
}
extern "C" {
    pub fn USI_SSI_Writeable(usi_dev: *mut USI_TypeDef) -> u32;
}
extern "C" {
    pub fn USI_SSI_ReadData(usi_dev: *mut USI_TypeDef) -> u32;
}
extern "C" {
    pub fn USI_SSI_ReceiveData(
        usi_dev: *mut USI_TypeDef,
        RxData: *mut ffi::ctypes::c_void,
        Length: u32,
    ) -> u32;
}
extern "C" {
    pub fn USI_SSI_SendData(
        usi_dev: *mut USI_TypeDef,
        TxData: *mut ffi::ctypes::c_void,
        Length: u32,
        Role: u32,
    ) -> u32;
}
extern "C" {
    pub fn USI_SSI_GetRxCount(usi_dev: *mut USI_TypeDef) -> u32;
}
extern "C" {
    pub fn USI_SSI_GetTxCount(usi_dev: *mut USI_TypeDef) -> u32;
}
extern "C" {
    pub fn USI_SSI_GetTxFIFOStatus(usi_dev: *mut USI_TypeDef) -> u32;
}
extern "C" {
    pub fn USI_SSI_GetRxFIFOStatus(usi_dev: *mut USI_TypeDef) -> u32;
}
extern "C" {
    pub fn USI_SSI_GetTransStatus(usi_dev: *mut USI_TypeDef) -> u32;
}
extern "C" {
    pub fn USI_SSI_GetDataFrameSize(usi_dev: *mut USI_TypeDef) -> u32;
}
extern "C" {
    pub fn USI_SSI_Busy(usi_dev: *mut USI_TypeDef) -> u32;
}
extern "C" {
    pub fn USI_SSI_GetIsr(usi_dev: *mut USI_TypeDef) -> u32;
}
extern "C" {
    pub fn USI_SSI_GetRawIsr(usi_dev: *mut USI_TypeDef) -> u32;
}
extern "C" {
    pub fn USI_SSI_TXGDMA_Init(
        Index: u32,
        GDMA_InitStruct: PGDMA_InitTypeDef,
        CallbackData: *mut ffi::ctypes::c_void,
        CallbackFunc: IRQ_FUN,
        pTxData: *mut u8,
        Length: u32,
    ) -> BOOL;
}
extern "C" {
    pub fn USI_SSI_RXGDMA_Init(
        Index: u8,
        GDMA_InitStruct: *mut GDMA_InitTypeDef,
        CallbackData: *mut ffi::ctypes::c_void,
        CallbackFunc: IRQ_FUN,
        pRxData: *mut u8,
        Length: u32,
    ) -> BOOL;
}
extern "C" {
    pub fn USI_SSI_SetDmaEnable(usi_dev: *mut USI_TypeDef, newState: u32, Mask: u32);
}
extern "C" {
    pub fn USI_SSI_SetDmaLevel(usi_dev: *mut USI_TypeDef, TxLevel: u32, RxLevel: u32);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct USI_I2C_InitTypeDef {
    pub USI_I2CIdx: u32,
    pub USI_I2CMaster: u32,
    pub USI_I2CAddrMod: u32,
    pub USI_I2CSpdMod: u32,
    pub USI_I2CRXTL: u32,
    pub USI_I2CTXTL: u32,
    pub USI_I2CMstReSTR: u32,
    pub USI_I2CMstGC: u32,
    pub USI_I2CMstStartB: u32,
    pub USI_I2CSlvNoAck: u32,
    pub USI_I2CSlvAckGC: u32,
    pub USI_I2CAckAddr: u32,
    pub USI_I2CSlvSetup: u32,
    pub USI_I2CSdaHd: u32,
    pub USI_I2CClk: u32,
    pub USI_I2CIPClk: u32,
    pub USI_I2CFilter: u32,
    pub USI_I2CTxDMARqLv: u32,
    pub USI_I2CRxDMARqLv: u32,
    pub USI_I2CDMAMod: u32,
}
extern "C" {
    pub fn USI_I2C_StructInit(USI_I2C_InitStruct: *mut USI_I2C_InitTypeDef);
}
extern "C" {
    pub fn USI_I2C_Init(USIx: *mut USI_TypeDef, USI_I2C_InitStruct: *mut USI_I2C_InitTypeDef);
}
extern "C" {
    pub fn USI_I2C_SetSpeed(USIx: *mut USI_TypeDef, SpdMd: u32, I2Clk: u32, I2CIPClk: u32);
}
extern "C" {
    pub fn USI_I2C_SetSlaveAddress(USIx: *mut USI_TypeDef, Address: u16);
}
extern "C" {
    pub fn USI_I2C_CheckFlagState(USIx: *mut USI_TypeDef, USI_I2C_FLAG: u32) -> u8;
}
extern "C" {
    pub fn USI_I2C_CheckTXFIFOState(USIx: *mut USI_TypeDef, USI_I2C_TXFIFO_FLAG: u32) -> u8;
}
extern "C" {
    pub fn USI_I2C_CheckRXFIFOState(USIx: *mut USI_TypeDef, USI_I2C_RXFIFO_FLAG: u32) -> u8;
}
extern "C" {
    pub fn USI_I2C_INTConfig(USIx: *mut USI_TypeDef, USI_I2C_IT: u32, NewState: u32);
}
extern "C" {
    pub fn USI_I2C_ClearINT(USIx: *mut USI_TypeDef, INTrBit: u32);
}
extern "C" {
    pub fn USI_I2C_ClearAllINT(USIx: *mut USI_TypeDef);
}
extern "C" {
    pub fn USI_I2C_GetRawINT(USIx: *mut USI_TypeDef) -> u32;
}
extern "C" {
    pub fn USI_I2C_GetINT(USIx: *mut USI_TypeDef) -> u32;
}
extern "C" {
    pub fn USI_I2C_Cmd(USIx: *mut USI_TypeDef, NewState: u8);
}
extern "C" {
    pub fn USI_I2C_ReceiveData(USIx: *mut USI_TypeDef) -> u8;
}
extern "C" {
    pub fn USI_I2C_MasterSendNullData(
        USIx: *mut USI_TypeDef,
        pBuf: *mut u8,
        I2CCmd: u8,
        I2CStop: u8,
        I2CReSTR: u8,
    );
}
extern "C" {
    pub fn USI_I2C_MasterSend(
        USIx: *mut USI_TypeDef,
        pBuf: *mut u8,
        I2CCmd: u8,
        I2CStop: u8,
        I2CReSTR: u8,
    );
}
extern "C" {
    pub fn USI_I2C_MasterWrite(USIx: *mut USI_TypeDef, pBuf: *mut u8, len: u8) -> u8;
}
extern "C" {
    pub fn USI_I2C_MasterRead(USIx: *mut USI_TypeDef, pBuf: *mut u8, len: u8) -> u8;
}
extern "C" {
    pub fn USI_I2C_MasterRepeatRead(
        USIx: *mut USI_TypeDef,
        pWriteBuf: *mut u8,
        Writelen: u8,
        pReadBuf: *mut u8,
        Readlen: u8,
    );
}
extern "C" {
    pub fn USI_I2C_SlaveWrite(USIx: *mut USI_TypeDef, pBuf: *mut u8, len: u8);
}
extern "C" {
    pub fn USI_I2C_SlaveRead(USIx: *mut USI_TypeDef, pBuf: *mut u8, len: u8);
}
extern "C" {
    pub fn USI_I2C_SlaveSend(USIx: *mut USI_TypeDef, Data: u8);
}
extern "C" {
    pub fn USI_I2C_DMAControl(USIx: *mut USI_TypeDef, DmaCtrl: u32, NewState: u8);
}
extern "C" {
    pub fn USI_I2C_DmaRegModeConfig(
        USIx: *mut USI_TypeDef,
        USI_I2C_DmaCmd: u32,
        USI_I2C_DmaBLen: u32,
    );
}
extern "C" {
    pub fn USI_I2C_TXGDMA_Init(
        Index: u8,
        GDMA_InitStruct: *mut GDMA_InitTypeDef,
        CallbackData: *mut ffi::ctypes::c_void,
        CallbackFunc: IRQ_FUN,
        pTxBuf: *mut u8,
        TxCount: ffi::ctypes::c_int,
    ) -> BOOL;
}
extern "C" {
    pub fn USI_I2C_RXGDMA_Init(
        Index: u8,
        GDMA_InitStruct: *mut GDMA_InitTypeDef,
        CallbackData: *mut ffi::ctypes::c_void,
        CallbackFunc: IRQ_FUN,
        pRxBuf: *mut u8,
        RxCount: ffi::ctypes::c_int,
    ) -> BOOL;
}
extern "C" {
    pub fn USI_I2C_Sleep_Cmd(USIx: *mut USI_TypeDef, NewStatus: u32);
}
extern "C" {
    pub fn USI_I2C_WakeUp(USIx: *mut USI_TypeDef);
}
extern "C" {
    pub static mut USI_I2C_SLAVEWRITE_PATCH: u32;
}
extern "C" {
    pub static mut USI_IC_FS_SCL_HCNT_TRIM: u32;
}
extern "C" {
    pub static mut USI_IC_FS_SCL_LCNT_TRIM: u32;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CRC_InitTypeDef {
    pub CRC_Type: u32,
    pub CRC_Polynom: u32,
    pub CRC_InitVal: u32,
    pub CRC_Xor: u32,
    pub CRC_Iswap: u32,
    pub CRC_Oswap: u32,
    pub CRC_DmaMode: u32,
}
extern "C" {
    pub fn CRC_StructInit(CRC_InitStruct: *mut CRC_InitTypeDef);
}
extern "C" {
    pub fn CRC_Init(CRC_InitStruct: *mut CRC_InitTypeDef) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn CRC_Calculate(
        CRC_InitStruct: *mut CRC_InitTypeDef,
        message: *const u8,
        msglen: u32,
        pCrc: *mut u32,
    ) -> ffi::ctypes::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct LCDC_MCUInitTypeDef {
    pub LCDC_MCUIfMode: u32,
    pub LCDC_MCUMode: u32,
    pub LCDC_MCUDMAMode: u32,
    pub LCDC_MCUImgHeight: u32,
    pub LCDC_MCUImgWidth: u32,
    pub LCDC_MCUSyncMode: u32,
    pub LCDC_MCUVsyncPulPlrty: u32,
    pub LCDC_MCUTEPulPlrty: u32,
    pub LCDC_MCUTEDelay: u32,
    pub LCDC_MCUDataPulPlrty: u32,
    pub LCDC_MCURdPulPlrty: u32,
    pub LCDC_MCUWrPulPlrty: u32,
    pub LCDC_MCURsPulPlrty: u32,
    pub LCDC_MCUCsPulPlrty: u32,
    pub LCDC_MCUVsyncIdlePrd: u32,
    pub LCDC_MCUVsyncSigWidth: u32,
    pub LCDC_MCURdInacvWidth: u32,
    pub LCDC_MCURdAcvWidth: u32,
    pub LCDC_MCUWrPulWidth: u32,
    pub LCDC_MCUIOTimeOutClkNum: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct LCDC_RGBInitTypeDef {
    pub LCDC_RGBIfMode: u32,
    pub LCDC_RGBImgHeight: u32,
    pub LCDC_RGBImgWidth: u32,
    pub LCDC_RGBRefreshFreq: u32,
    pub LCDC_RGBSyncMode: u32,
    pub LCDC_RGBDatPulPlrty: u32,
    pub LCDC_RGBEnPulPlrty: u32,
    pub LCDC_RGBHsPulPlrty: u32,
    pub LCDC_RGBVsPulPlrty: u32,
    pub LCDC_RGBDclkActvEdge: u32,
    pub LCDC_RGBVFP: u32,
    pub LCDC_RGBVBP: u32,
    pub LCDC_RGBVSW: u32,
    pub LCDC_RGBHFP: u32,
    pub LCDC_RGBHBP: u32,
    pub LCDC_RGBHSW: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct LCDC_LEDInitTypeDef {
    pub LCDC_LEDIfMode: u32,
    pub LCDC_LEDImgHeight: u32,
    pub LCDC_LEDImgWidth: u32,
    pub LCDC_LEDRefreshFreq: u32,
    pub LCDC_LEDColorChnl: u32,
    pub LCDC_LEDColorNum: u32,
    pub LCDC_LEDClkPlrty: u32,
    pub LCDC_LEDOePlrty: u32,
    pub LCDC_LEDLatPlrty: u32,
    pub LCDC_LEDDatPlrty: u32,
    pub LCDC_LEDOEActw: u32,
    pub LCDC_LEDLatchWidth: u32,
    pub LCDC_LEDFrmIdlePd: u32,
    pub LCDC_LEDLineIdlePd: u32,
}
extern "C" {
    pub fn LCDC_MCUStructInit(LCDC_MCUInitStruct: *mut LCDC_MCUInitTypeDef);
}
extern "C" {
    pub fn LCDC_MCUInit(LCDCx: *mut LCDC_TypeDef, LCDC_MCUInitStruct: *mut LCDC_MCUInitTypeDef);
}
extern "C" {
    pub fn LCDC_MCUDMATrigger(LCDCx: *mut LCDC_TypeDef);
}
extern "C" {
    pub fn LCDC_MCUGetRunStatus(LCDCx: *mut LCDC_TypeDef) -> u32;
}
extern "C" {
    pub fn LCDC_MCUIOWriteData(LCDCx: *mut LCDC_TypeDef, Data: u16);
}
extern "C" {
    pub fn LCDC_MCUIOReadData(LCDCx: *mut LCDC_TypeDef) -> u16;
}
extern "C" {
    pub fn LCDC_MCUIOWriteCmd(LCDCx: *mut LCDC_TypeDef, Cmd: u16);
}
extern "C" {
    pub fn LCDC_RGBStructInit(LCDC_RGBInitStruct: *mut LCDC_RGBInitTypeDef);
}
extern "C" {
    pub fn LCDC_RGBInit(LCDCx: *mut LCDC_TypeDef, LCDC_RGBInitStruct: *mut LCDC_RGBInitTypeDef);
}
extern "C" {
    pub fn LCDC_RGBGetSyncStatus(
        LCDCx: *mut LCDC_TypeDef,
        pHSStatus: *mut u32,
        pVSStatus: *mut u32,
    );
}
extern "C" {
    pub fn LCDC_LEDStructInit(LCDC_LEDInitStruct: *mut LCDC_LEDInitTypeDef);
}
extern "C" {
    pub fn LCDC_LEDInit(LCDCx: *mut LCDC_TypeDef, LCDC_LEDInitStruct: *mut LCDC_LEDInitTypeDef);
}
extern "C" {
    pub fn LCDC_LEDSetOEWidth(LCDCx: *mut LCDC_TypeDef, OEActvWidth: u32);
}
extern "C" {
    pub fn LCDC_DMAModeConfig(LCDCx: *mut LCDC_TypeDef, BurstSize: u32);
}
extern "C" {
    pub fn LCDC_DMAUnderFlowConfig(LCDCx: *mut LCDC_TypeDef, DmaUnFlwMode: u32, ErrorData: u32);
}
extern "C" {
    pub fn LCDC_DMAImageBaseAddrConfig(LCDCx: *mut LCDC_TypeDef, ImgBaseAddr: u32);
}
extern "C" {
    pub fn LCDC_INTConfig(LCDCx: *mut LCDC_TypeDef, LCDC_IT: u32, NewState: u32);
}
extern "C" {
    pub fn LCDC_LineINTPosConfig(LCDCx: *mut LCDC_TypeDef, LineNum: u32);
}
extern "C" {
    pub fn LCDC_GetINTStatus(LCDCx: *mut LCDC_TypeDef) -> u32;
}
extern "C" {
    pub fn LCDC_GetRawINTStatus(LCDCx: *mut LCDC_TypeDef) -> u32;
}
extern "C" {
    pub fn LCDC_ClearAllINT(LCDCx: *mut LCDC_TypeDef);
}
extern "C" {
    pub fn LCDC_ClearINT(LCDCx: *mut LCDC_TypeDef, LCDC_IT: u32);
}
extern "C" {
    pub fn LCDC_GetCurPosStatus(LCDCx: *mut LCDC_TypeDef, pCurPosX: *mut u32, pCurPosY: *mut u32);
}
extern "C" {
    pub fn LCDC_GetDmaUnINTCnt(LCDCx: *mut LCDC_TypeDef, DmaUnIntCnt: *mut u32);
}
extern "C" {
    pub fn LCDC_Cmd(LCDCx: *mut LCDC_TypeDef, NewState: u32);
}
extern "C" {
    pub fn LCDC_InsDisable(LCDCx: *mut LCDC_TypeDef);
}
extern "C" {
    pub fn LCDC_DeInit(LCDCx: *mut LCDC_TypeDef);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SP_InitTypeDef {
    pub SP_WordLen: u32,
    pub SP_DataFormat: u32,
    pub SP_MonoStereo: u32,
    pub SP_SelRxCh: u32,
}
extern "C" {
    pub fn AUDIO_SP_StructInit(SP_InitStruct: *mut SP_InitTypeDef);
}
extern "C" {
    pub fn AUDIO_SP_Init(SPORTx: *mut AUDIO_SPORT_TypeDef, SP_InitStruct: *mut SP_InitTypeDef);
}
extern "C" {
    pub fn AUDIO_SP_TxStart(SPORTx: *mut AUDIO_SPORT_TypeDef, NewState: u32);
}
extern "C" {
    pub fn AUDIO_SP_RxStart(SPORTx: *mut AUDIO_SPORT_TypeDef, NewState: u32);
}
extern "C" {
    pub fn AUDIO_SP_TdmaCmd(SPORTx: *mut AUDIO_SPORT_TypeDef, NewState: u32);
}
extern "C" {
    pub fn AUDIO_SP_RdmaCmd(SPORTx: *mut AUDIO_SPORT_TypeDef, NewState: u32);
}
extern "C" {
    pub fn AUDIO_SP_SetWordLen(SPORTx: *mut AUDIO_SPORT_TypeDef, SP_WordLen: u32);
}
extern "C" {
    pub fn AUDIO_SP_GetWordLen(SPORTx: *mut AUDIO_SPORT_TypeDef) -> u32;
}
extern "C" {
    pub fn AUDIO_SP_SetMonoStereo(SPORTx: *mut AUDIO_SPORT_TypeDef, SP_MonoStereo: u32);
}
extern "C" {
    pub fn AUDIO_SP_TXGDMA_Init(
        Index: u32,
        GDMA_InitStruct: *mut GDMA_InitTypeDef,
        CallbackData: *mut ffi::ctypes::c_void,
        CallbackFunc: IRQ_FUN,
        pTxData: *mut u8,
        Length: u32,
    ) -> BOOL;
}
extern "C" {
    pub fn AUDIO_SP_RXGDMA_Init(
        Index: u32,
        GDMA_InitStruct: *mut GDMA_InitTypeDef,
        CallbackData: *mut ffi::ctypes::c_void,
        CallbackFunc: IRQ_FUN,
        pRxData: *mut u8,
        Length: u32,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AUDIO_DevTable {
    pub SPORTx: *mut AUDIO_SPORT_TypeDef,
    pub Tx_HandshakeInterface: u32,
    pub Rx_HandshakeInterface: u32,
}
impl Default for AUDIO_DevTable {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static AUDIO_DEV_TABLE: [AUDIO_DevTable; 1usize];
}
extern "C" {
    pub fn EFUSEPowerSwitch(bWrite: u8, PwrState: u8, L25OutVoltage: u8);
}
extern "C" {
    pub fn EFUSERead8(CtrlSetting: u32, Addr: u32, Data: *mut u8, L25OutVoltage: u8) -> u32;
}
extern "C" {
    pub fn EFUSEWrite8(CtrlSetting: u32, Addr: u32, Data: u8, L25OutVoltage: u8) -> u32;
}
extern "C" {
    pub fn EFUSE_LogicalMap_Read(pbuf: *mut u8) -> u32;
}
extern "C" {
    pub fn EFUSE_LogicalMap_Write(addr: u32, cnts: u32, data: *mut u8) -> u32;
}
extern "C" {
    pub static mut EFUSE_MAP: [u8; 1024usize];
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PCTL_InitTypeDef {
    pub PCTL_dfi_cs_wr_dly: u8,
    pub PCTL_dfi_cs_rd_dly: u8,
    pub PCTL_tphy_wrdata: u8,
    pub PCTL_fix_tphy_lat: u8,
    pub PCTL_tphy_rddata: u8,
    pub PCTL_dfi_path_dly: u8,
    pub PCTL_wl: u8,
    pub PCTL_rl: u8,
    pub PCTL_tcph_ps: u32,
    pub PCTL_tpu_ps: u32,
    pub PCTL_tcem_ps: u32,
    pub PCTL_clk_ps: u32,
    pub PCTL_mr0_burst_len: u8,
    pub PCTL_mr0_burst_type: u8,
    pub PCTL_mr0_lat_mode: u8,
    pub PCTL_mr0_init_lat: u8,
    pub PCTL_mr0_drv_strength: u8,
    pub PCTL_mr0_dpd_en: u8,
    pub PCTL_mr1_pasr: u8,
    pub PCTL_mr1_half_slp: u8,
    pub PCTL_mr1_refresh_rate: u8,
}
extern "C" {
    pub fn PSRAM_CTRL_StructInit(PCTL_InitStruct: *mut PCTL_InitTypeDef);
}
extern "C" {
    pub fn PSRAM_CTRL_Init(PCTL_InitStruct: *mut PCTL_InitTypeDef);
}
extern "C" {
    pub fn PSRAM_CTRL_CA_Gen(
        PSRAM_CA: *mut u8,
        StartAddr: u32,
        BurstType: u8,
        AddSpace: u8,
        RW: u8,
    );
}
extern "C" {
    pub fn PSRAM_CTRL_DPin_Mem(PSRAM_CA: *mut u8, PSRAM_data: *mut u32, PSRAM_byteen: u32, RW: u8);
}
extern "C" {
    pub fn PSRAM_CTRL_DPin_Reg(PSRAM_CA: *mut u8, PSRAM_data: *mut u32, RW: u8);
}
extern "C" {
    pub fn PSRAM_PHY_REG_Read(offset: u8) -> u32;
}
extern "C" {
    pub fn PSRAM_PHY_REG_Write(offset: u8, reg_val: u32);
}
extern "C" {
    pub fn PSRAM_calibration() -> BOOL;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PSRAMCFG_TypeDef {
    pub psram_dev_enable: u32,
    pub psram_dev_cal_enable: u32,
    pub psram_dev_retention: u32,
}
extern "C" {
    pub static mut psram_dev_config: PSRAMCFG_TypeDef;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SDIOH_InitTypeDef {
    pub SDIOH_idle_level: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SDIOH_DmaCtl {
    pub start_addr: u32,
    pub blk_cnt: u16,
    pub op: u8,
    pub type_: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SDIOH_CmdTypeDef {
    pub arg: u32,
    pub idx: u8,
    pub rsp_type: u8,
    pub rsp_crc_chk: u8,
    pub data_present: u8,
}
extern "C" {
    pub fn SDIOH_Busy() -> u32;
}
extern "C" {
    pub fn SDIOH_CheckTxError(status: *mut u16) -> u32;
}
extern "C" {
    pub fn SDIOH_WaitTxDone(timeout_us: u32) -> u32;
}
extern "C" {
    pub fn SDIOH_WaitDMADone(timeout_us: u32) -> u32;
}
extern "C" {
    pub fn SDIOH_GetISR() -> u32;
}
extern "C" {
    pub fn SDIOH_INTConfig(SDIO_IT: u8, newState: u32);
}
extern "C" {
    pub fn SDIOH_INTClearPendingBit(SDIO_IT: u8);
}
extern "C" {
    pub fn SDIOH_CheckBusState(status: u8, timeout_us: u32) -> u32;
}
extern "C" {
    pub fn SDIOH_GetBusWidth() -> u8;
}
extern "C" {
    pub fn SDIOH_SetBusWidth(width: u8);
}
extern "C" {
    pub fn SDIOH_DMAConfig(dma_ctl: *mut SDIOH_DmaCtl);
}
extern "C" {
    pub fn SDIOH_DMAReset();
}
extern "C" {
    pub fn SDIOH_SendCommand(cmd_attrib: *mut SDIOH_CmdTypeDef, timeout_us: u32) -> u32;
}
extern "C" {
    pub fn SDIOH_GetResponse(byte_index: u8) -> u8;
}
extern "C" {
    pub fn SDIOH_SwitchSpeed(clk_div: u8, mode: u8);
}
extern "C" {
    pub fn SDIOH_InitialModeCmd(NewState: u8, Level: u8) -> u32;
}
extern "C" {
    pub fn SDIOH_Init(BusBitMode: u8) -> u32;
}
extern "C" {
    pub fn SDIOH_DeInit();
}
pub const SD_COMMAND_SD_CMD_GoIdleSte: SD_COMMAND = 0;
pub const SD_COMMAND_EMMC_CMD_SendOpCond: SD_COMMAND = 1;
pub const SD_COMMAND_SD_CMD_AllSendCid: SD_COMMAND = 2;
pub const SD_COMMAND_SD_CMD_SendRelAddr: SD_COMMAND = 3;
pub const SD_COMMAND_SD_CMD_SetDsr: SD_COMMAND = 4;
pub const SD_COMMAND_SD_CMD_SwitchFunc: SD_COMMAND = 6;
pub const SD_COMMAND_SD_CMD_SetBusWidth: SD_COMMAND = 6;
pub const SD_COMMAND_SD_CMD_SelDeselCard: SD_COMMAND = 7;
pub const SD_COMMAND_SD_CMD_SendIfCond: SD_COMMAND = 8;
pub const SD_COMMAND_EMMC_CMD_SendExtCsd: SD_COMMAND = 8;
pub const SD_COMMAND_SD_CMD_SendCsd: SD_COMMAND = 9;
pub const SD_COMMAND_SD_CMD_SendCid: SD_COMMAND = 10;
pub const SD_COMMAND_SD_CMD_VolSwitch: SD_COMMAND = 11;
pub const SD_COMMAND_SD_CMD_StopXsmission: SD_COMMAND = 12;
pub const SD_COMMAND_SD_CMD_SendSts: SD_COMMAND = 13;
pub const SD_COMMAND_SD_CMD_SetBlklen: SD_COMMAND = 16;
pub const SD_COMMAND_SD_CMD_RdSingleBlk: SD_COMMAND = 17;
pub const SD_COMMAND_SD_CMD_RdMulBlk: SD_COMMAND = 18;
pub const SD_COMMAND_SD_CMD_SendTuningBlk: SD_COMMAND = 19;
pub const SD_COMMAND_SD_CMD_SendNumWrBlks: SD_COMMAND = 22;
pub const SD_COMMAND_SD_CMD_SetBlkCnt: SD_COMMAND = 23;
pub const SD_COMMAND_SD_CMD_SetWrBlkEraseCnt: SD_COMMAND = 23;
pub const SD_COMMAND_SD_CMD_WrBlk: SD_COMMAND = 24;
pub const SD_COMMAND_SD_CMD_WrMulBlk: SD_COMMAND = 25;
pub const SD_COMMAND_SD_CMD_ProgCsd: SD_COMMAND = 27;
pub const SD_COMMAND_SD_CMD_EraseBlkSt: SD_COMMAND = 32;
pub const SD_COMMAND_SD_CMD_EraseBlkEd: SD_COMMAND = 33;
pub const SD_COMMAND_EMMC_CMD_EraseAddrSt: SD_COMMAND = 35;
pub const SD_COMMAND_EMMC_CMD_EraseAddrEd: SD_COMMAND = 36;
pub const SD_COMMAND_SD_CMD_Erase: SD_COMMAND = 38;
pub const SD_COMMAND_SD_CMD_SdSendOpCond: SD_COMMAND = 41;
pub const SD_COMMAND_SD_CMD_SendScr: SD_COMMAND = 51;
pub const SD_COMMAND_SD_CMD_AppCmd: SD_COMMAND = 55;
pub type SD_COMMAND = ffi::ctypes::c_uint;
pub const SD_RESULT_SD_OK: SD_RESULT = 0;
pub const SD_RESULT_SD_NODISK: SD_RESULT = 1;
pub const SD_RESULT_SD_INSERT: SD_RESULT = 2;
pub const SD_RESULT_SD_INITERR: SD_RESULT = 3;
pub const SD_RESULT_SD_PROTECTED: SD_RESULT = 4;
pub const SD_RESULT_SD_ERROR: SD_RESULT = 5;
pub type SD_RESULT = ffi::ctypes::c_uint;
#[repr(C)]
#[repr(align(32))]
#[derive(Copy, Clone)]
pub struct SD_CardInfo {
    pub csd: [u8; 16usize],
    pub rca: u16,
    pub is_sdhc_sdxc: u8,
    pub sd_spec_ver: u8,
    pub capaticy: u32,
    pub read_bl_len: u32,
    pub write_bl_len: u32,
    pub sig_level: u8,
    pub bus_spd: u8,
    pub sd_status: SD_RESULT,
    pub __bindgen_padding_0: [u8; 24usize],
    pub dma_buf: [u8; 64usize],
}
impl Default for SD_CardInfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for SD_CardInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "SD_CardInfo {{ csd: {:?}, rca: {:?}, is_sdhc_sdxc: {:?}, sd_spec_ver: {:?}, capaticy: {:?}, read_bl_len: {:?}, write_bl_len: {:?}, sig_level: {:?}, bus_spd: {:?}, sd_status: {:?}, dma_buf: [...] }}" , self . csd , self . rca , self . is_sdhc_sdxc , self . sd_spec_ver , self . capaticy , self . read_bl_len , self . write_bl_len , self . sig_level , self . bus_spd , self . sd_status)
    }
}
extern "C" {
    pub fn SD_Init() -> SD_RESULT;
}
extern "C" {
    pub fn SD_DeInit() -> SD_RESULT;
}
extern "C" {
    pub fn SD_GetCapacity(sector_count: *mut u32) -> SD_RESULT;
}
extern "C" {
    pub fn SD_ReadBlocks(sector: u32, data: *mut u8, count: u32) -> SD_RESULT;
}
extern "C" {
    pub fn SD_WriteBlocks(sector: u32, data: *const u8, count: u32) -> SD_RESULT;
}
extern "C" {
    pub fn SD_Status() -> SD_RESULT;
}
extern "C" {
    pub fn SD_GetEXTCSD(pbuf: *mut u8) -> SD_RESULT;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SDIOHCFG_TypeDef {
    pub sdioh_bus_speed: u8,
    pub sdioh_bus_width: u8,
    pub sdioh_cd_pin: u32,
    pub sdioh_wp_pin: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IMAGE_HEADER {
    pub signature: [u32; 2usize],
    pub image_size: u32,
    pub image_addr: u32,
    pub sb_header: u32,
    pub reserved: [u32; 3usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SYSTEM_DATA {
    pub Rsvd00: u32,
    pub Valid_Image2: u32,
    pub Rsvd01: [u32; 2usize],
    pub Rsvd10: [u32; 4usize],
    pub Rsvd20: [u32; 2usize],
    pub BT_FW_DBG: u32,
    pub FTL_GC_Status: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SB_HEADER {
    pub reserved: [u32; 12usize],
    pub sb_sig: [ffi::ctypes::c_uchar; 64usize],
}
impl Default for SB_HEADER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for SB_HEADER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "SB_HEADER {{ reserved: {:?}, sb_sig: [...] }}",
            self.reserved
        )
    }
}
pub const _HAL_Status_HAL_OK: _HAL_Status = 0;
pub const _HAL_Status_HAL_BUSY: _HAL_Status = 1;
pub const _HAL_Status_HAL_TIMEOUT: _HAL_Status = 2;
pub const _HAL_Status_HAL_ERR_PARA: _HAL_Status = 3;
pub const _HAL_Status_HAL_ERR_MEM: _HAL_Status = 4;
pub const _HAL_Status_HAL_ERR_HW: _HAL_Status = 5;
pub const _HAL_Status_HAL_ERR_UNKNOWN: _HAL_Status = 238;
pub type _HAL_Status = ffi::ctypes::c_uint;
pub use self::_HAL_Status as HAL_Status;
extern "C" {
    pub fn io_assert_failed(file: *mut u8, line: u32);
}
extern "C" {
    pub fn simulation_stage_set(cpuid: u32, sim_stage_bit: u32) -> u32;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct KM4SLEEP_ParamDef {
    pub dlps_enable: u8,
    pub sleep_type: u8,
    pub sleep_time: u32,
}
extern "C" {
    pub fn km4_pm_init();
}
extern "C" {
    pub fn km4_boot_on();
}
extern "C" {
    pub fn km4_suspend(type_: u32) -> u32;
}
extern "C" {
    pub fn km4_resume();
}
extern "C" {
    pub fn km4_status_on() -> u32;
}
extern "C" {
    pub fn km4_set_wake_event(wevt: u32);
}
extern "C" {
    pub fn km4_get_wake_event() -> u32;
}
extern "C" {
    pub fn km4_wake_event_update();
}
extern "C" {
    pub fn km4_tickless_ipc_int(Data: *mut ffi::ctypes::c_void, IrqStatus: u32, ChanNum: u32);
}
extern "C" {
    pub fn km4_flash_highspeed_resume(Protection: u32);
}
extern "C" {
    pub fn km4_flash_highspeed_suspend(Protection: u32);
}
extern "C" {
    pub fn km4_flash_highspeed_init();
}
extern "C" {
    pub fn pmu_get_km4sleeptime() -> u32;
}
extern "C" {
    pub static mut km4_sleep_type: u8;
}
extern "C" {
    pub static mut km4_sleep_timeout: u32;
}
extern "C" {
    pub fn flash_operation_config();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CapTouch_CHInitTypeDef {
    pub CT_DiffThrehold: u16,
    pub CT_MbiasCurrent: u8,
    pub CT_ETCNNoiseThr: u8,
    pub CT_ETCPNoiseThr: u8,
    pub CT_CHEnable: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CapTouch_InitTypeDef {
    pub CT_DebounceEn: u32,
    pub CT_SampleCnt: u32,
    pub CT_ScanInterval: u32,
    pub CT_ETCStep: u32,
    pub CT_ETCFactor: u32,
    pub CT_ETCScanInterval: u32,
    pub CT_Channel: [CapTouch_CHInitTypeDef; 5usize],
}
extern "C" {
    pub fn CapTouch_StructInit(CapTouch_InitStruct: *mut CapTouch_InitTypeDef);
}
extern "C" {
    pub fn CapTouch_Init(
        CapTouch: *mut CAPTOUCH_TypeDef,
        CapTouch_InitStruct: *mut CapTouch_InitTypeDef,
    );
}
extern "C" {
    pub fn CapTouch_Cmd(CapTouch: *mut CAPTOUCH_TypeDef, NewState: u8);
}
extern "C" {
    pub fn CapTouch_INTConfig(CapTouch: *mut CAPTOUCH_TypeDef, CapTouch_IT: u32, newState: u8);
}
extern "C" {
    pub fn CapTouch_INTClearPendingBit(CapTouch: *mut CAPTOUCH_TypeDef, CapTouch_IT: u32);
}
extern "C" {
    pub fn CapTouch_GetRawISR(CapTouch: *mut CAPTOUCH_TypeDef) -> u32;
}
extern "C" {
    pub fn CapTouch_GetISR(CapTouch: *mut CAPTOUCH_TypeDef) -> u32;
}
extern "C" {
    pub fn CapTouch_SetScanInterval(CapTouch: *mut CAPTOUCH_TypeDef, Interval: u32);
}
extern "C" {
    pub fn CapTouch_ChCmd(CapTouch: *mut CAPTOUCH_TypeDef, Channel: u8, NewState: u8);
}
extern "C" {
    pub fn CapTouch_GetChStatus(CapTouch: *mut CAPTOUCH_TypeDef, Channel: u32) -> u32;
}
extern "C" {
    pub fn CapTouch_SetChDiffThres(CapTouch: *mut CAPTOUCH_TypeDef, Channel: u8, Threshold: u32);
}
extern "C" {
    pub fn CapTouch_SetChMbias(CapTouch: *mut CAPTOUCH_TypeDef, Channel: u8, Mbias: u8);
}
extern "C" {
    pub fn CapTouch_GetChDiffThres(CapTouch: *mut CAPTOUCH_TypeDef, Channel: u8) -> u32;
}
extern "C" {
    pub fn CapTouch_GetNoiseThres(CapTouch: *mut CAPTOUCH_TypeDef, Channel: u8, type_: u8) -> u32;
}
extern "C" {
    pub fn CapTouch_GetChBaseline(CapTouch: *mut CAPTOUCH_TypeDef, Channel: u8) -> u32;
}
extern "C" {
    pub fn CapTouch_GetChAveData(CapTouch: *mut CAPTOUCH_TypeDef, Channel: u8) -> u32;
}
extern "C" {
    pub fn CapTouch_DbgCmd(CapTouch: *mut CAPTOUCH_TypeDef, NewState: u8);
}
extern "C" {
    pub fn CapTouch_DbgDumpReg(CapTouch: *mut CAPTOUCH_TypeDef);
}
extern "C" {
    pub fn CapTouch_DbgDumpETC(CapTouch: *mut CAPTOUCH_TypeDef, ch: u32);
}
extern "C" {
    pub fn CapTouch_DbgRawData(CapTouch: *mut CAPTOUCH_TypeDef) -> u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct http_response_result_t {
    pub status_code: u32,
    pub header_len: u32,
    pub body: *mut u8,
    pub body_len: u32,
    pub header_bak: *mut u8,
    pub parse_status: u32,
}
impl Default for http_response_result_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct update_file_hdr {
    pub FwVer: u32,
    pub HdrNum: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct update_file_img_hdr {
    pub ImgId: [u8; 4usize],
    pub ImgHdrLen: u32,
    pub Checksum: u32,
    pub ImgLen: u32,
    pub Offset: u32,
    pub FlashAddr: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct update_dw_info {
    pub ImgId: u32,
    pub FlashAddr: u32,
    pub ImgOffset: u32,
    pub ImageLen: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct update_ota_target_hdr {
    pub FileHdr: update_file_hdr,
    pub FileImgHdr: [update_file_img_hdr; 2usize],
    pub Sign: [[u8; 9usize]; 2usize],
    pub ValidImgCnt: u8,
}
extern "C" {
    pub fn OTA_Change(OTAIdx: u32) -> u32;
}
extern "C" {
    pub fn ota_update_malloc(size: ffi::ctypes::c_uint) -> *mut ffi::ctypes::c_void;
}
extern "C" {
    pub fn ota_update_free(buf: *mut ffi::ctypes::c_void);
}
extern "C" {
    pub fn ota_platform_reset();
}
extern "C" {
    pub fn ota_write_ota2_addr(ota_addr: u32) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn ota_get_cur_index() -> u32;
}
extern "C" {
    pub fn ota_readstream_user(address: u32, len: u32, data: *mut u8) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn recv_file_info_from_server(
        Recvbuf: *mut u8,
        len: u32,
        socket: ffi::ctypes::c_int,
    ) -> u32;
}
extern "C" {
    pub fn recv_ota_file_hdr(
        Recvbuf: *mut u8,
        len: *mut u32,
        pOtaTgtHdr: *mut update_ota_target_hdr,
        socket: ffi::ctypes::c_int,
    ) -> u32;
}
extern "C" {
    pub fn get_ota_tartget_header(
        buf: *mut u8,
        len: u32,
        pOtaTgtHdr: *mut update_ota_target_hdr,
        target_idx: u8,
    ) -> u32;
}
extern "C" {
    pub fn erase_ota_target_flash(addr: u32, len: u32);
}
extern "C" {
    pub fn download_new_fw_from_server(
        socket: ffi::ctypes::c_int,
        pOtaTgtHdr: *mut update_ota_target_hdr,
        targetIdx: u8,
    ) -> u32;
}
extern "C" {
    pub fn verify_ota_checksum(pOtaTgtHdr: *mut update_ota_target_hdr) -> u32;
}
extern "C" {
    pub fn change_ota_signature(
        pOtaTgtHdr: *mut update_ota_target_hdr,
        ota_target_index: u32,
    ) -> u32;
}
extern "C" {
    pub fn parser_url(
        url: *mut ffi::ctypes::c_char,
        host: *mut ffi::ctypes::c_char,
        port: *mut u16,
        resource: *mut ffi::ctypes::c_char,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn parse_http_response(
        response: *mut ffi::ctypes::c_uchar,
        response_len: ffi::ctypes::c_uint,
        result: *mut http_response_result_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn update_ota_http_connect_server(
        server_socket: ffi::ctypes::c_int,
        host: *mut ffi::ctypes::c_char,
        port: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn recv_ota_file_hdr_http(
        Recvbuf: *mut u8,
        writelen: u32,
        len: *mut u32,
        pOtaTgtHdr: *mut update_ota_target_hdr,
        socket: ffi::ctypes::c_int,
    ) -> u32;
}
extern "C" {
    pub fn http_read_socket(
        socket: ffi::ctypes::c_int,
        recevie_buf: *mut u8,
        buf_len: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn download_new_fw_from_server_http(
        first_buf: *mut u8,
        firstbuf_len: ffi::ctypes::c_uint,
        socket: ffi::ctypes::c_int,
        pOtaTgtHdr: *mut update_ota_target_hdr,
        targetIdx: u8,
    ) -> u32;
}
extern "C" {
    pub fn http_update_ota(
        host: *mut ffi::ctypes::c_char,
        port: ffi::ctypes::c_int,
        resource: *mut ffi::ctypes::c_char,
    ) -> ffi::ctypes::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _rom_ssl_ram_map {
    pub ssl_malloc: ::core::option::Option<
        unsafe extern "C" fn(sz: ffi::ctypes::c_uint) -> *mut ffi::ctypes::c_void,
    >,
    pub ssl_free: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ffi::ctypes::c_void)>,
    pub ssl_printf: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const ffi::ctypes::c_char, ...) -> ffi::ctypes::c_int,
    >,
    pub hw_crypto_aes_ecb_init: ::core::option::Option<
        unsafe extern "C" fn(key: *const u8, keylen: u32) -> ffi::ctypes::c_int,
    >,
    pub hw_crypto_aes_ecb_decrypt: ::core::option::Option<
        unsafe extern "C" fn(
            message: *const u8,
            msglen: u32,
            iv: *const u8,
            ivlen: u32,
            pResult: *mut u8,
        ) -> ffi::ctypes::c_int,
    >,
    pub hw_crypto_aes_ecb_encrypt: ::core::option::Option<
        unsafe extern "C" fn(
            message: *const u8,
            msglen: u32,
            iv: *const u8,
            ivlen: u32,
            pResult: *mut u8,
        ) -> ffi::ctypes::c_int,
    >,
    pub hw_crypto_aes_cbc_init: ::core::option::Option<
        unsafe extern "C" fn(key: *const u8, keylen: u32) -> ffi::ctypes::c_int,
    >,
    pub hw_crypto_aes_cbc_decrypt: ::core::option::Option<
        unsafe extern "C" fn(
            message: *const u8,
            msglen: u32,
            iv: *const u8,
            ivlen: u32,
            pResult: *mut u8,
        ) -> ffi::ctypes::c_int,
    >,
    pub hw_crypto_aes_cbc_encrypt: ::core::option::Option<
        unsafe extern "C" fn(
            message: *const u8,
            msglen: u32,
            iv: *const u8,
            ivlen: u32,
            pResult: *mut u8,
        ) -> ffi::ctypes::c_int,
    >,
    pub hw_crypto_des_cbc_init: ::core::option::Option<
        unsafe extern "C" fn(key: *const u8, keylen: u32) -> ffi::ctypes::c_int,
    >,
    pub hw_crypto_des_cbc_decrypt: ::core::option::Option<
        unsafe extern "C" fn(
            message: *const u8,
            msglen: u32,
            iv: *const u8,
            ivlen: u32,
            pResult: *mut u8,
        ) -> ffi::ctypes::c_int,
    >,
    pub hw_crypto_des_cbc_encrypt: ::core::option::Option<
        unsafe extern "C" fn(
            message: *const u8,
            msglen: u32,
            iv: *const u8,
            ivlen: u32,
            pResult: *mut u8,
        ) -> ffi::ctypes::c_int,
    >,
    pub hw_crypto_3des_cbc_init: ::core::option::Option<
        unsafe extern "C" fn(key: *const u8, keylen: u32) -> ffi::ctypes::c_int,
    >,
    pub hw_crypto_3des_cbc_decrypt: ::core::option::Option<
        unsafe extern "C" fn(
            message: *const u8,
            msglen: u32,
            iv: *const u8,
            ivlen: u32,
            pResult: *mut u8,
        ) -> ffi::ctypes::c_int,
    >,
    pub hw_crypto_3des_cbc_encrypt: ::core::option::Option<
        unsafe extern "C" fn(
            message: *const u8,
            msglen: u32,
            iv: *const u8,
            ivlen: u32,
            pResult: *mut u8,
        ) -> ffi::ctypes::c_int,
    >,
    pub use_hw_crypto_func: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _rom_mbedtls_ram_map {
    pub ssl_calloc: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: ffi::ctypes::c_uint,
            arg2: ffi::ctypes::c_uint,
        ) -> *mut ffi::ctypes::c_void,
    >,
    pub ssl_free: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ffi::ctypes::c_void)>,
    pub ssl_printf: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const ffi::ctypes::c_char, ...) -> ffi::ctypes::c_int,
    >,
    pub hw_crypto_aes_ecb_init: ::core::option::Option<
        unsafe extern "C" fn(key: *const u8, keylen: u32) -> ffi::ctypes::c_int,
    >,
    pub hw_crypto_aes_ecb_decrypt: ::core::option::Option<
        unsafe extern "C" fn(
            message: *const u8,
            msglen: u32,
            iv: *const u8,
            ivlen: u32,
            pResult: *mut u8,
        ) -> ffi::ctypes::c_int,
    >,
    pub hw_crypto_aes_ecb_encrypt: ::core::option::Option<
        unsafe extern "C" fn(
            message: *const u8,
            msglen: u32,
            iv: *const u8,
            ivlen: u32,
            pResult: *mut u8,
        ) -> ffi::ctypes::c_int,
    >,
    pub hw_crypto_aes_cbc_init: ::core::option::Option<
        unsafe extern "C" fn(key: *const u8, keylen: u32) -> ffi::ctypes::c_int,
    >,
    pub hw_crypto_aes_cbc_decrypt: ::core::option::Option<
        unsafe extern "C" fn(
            message: *const u8,
            msglen: u32,
            iv: *const u8,
            ivlen: u32,
            pResult: *mut u8,
        ) -> ffi::ctypes::c_int,
    >,
    pub hw_crypto_aes_cbc_encrypt: ::core::option::Option<
        unsafe extern "C" fn(
            message: *const u8,
            msglen: u32,
            iv: *const u8,
            ivlen: u32,
            pResult: *mut u8,
        ) -> ffi::ctypes::c_int,
    >,
    pub hw_crypto_des_cbc_init: ::core::option::Option<
        unsafe extern "C" fn(key: *const u8, keylen: u32) -> ffi::ctypes::c_int,
    >,
    pub hw_crypto_des_cbc_decrypt: ::core::option::Option<
        unsafe extern "C" fn(
            message: *const u8,
            msglen: u32,
            iv: *const u8,
            ivlen: u32,
            pResult: *mut u8,
        ) -> ffi::ctypes::c_int,
    >,
    pub hw_crypto_des_cbc_encrypt: ::core::option::Option<
        unsafe extern "C" fn(
            message: *const u8,
            msglen: u32,
            iv: *const u8,
            ivlen: u32,
            pResult: *mut u8,
        ) -> ffi::ctypes::c_int,
    >,
    pub hw_crypto_3des_cbc_init: ::core::option::Option<
        unsafe extern "C" fn(key: *const u8, keylen: u32) -> ffi::ctypes::c_int,
    >,
    pub hw_crypto_3des_cbc_decrypt: ::core::option::Option<
        unsafe extern "C" fn(
            message: *const u8,
            msglen: u32,
            iv: *const u8,
            ivlen: u32,
            pResult: *mut u8,
        ) -> ffi::ctypes::c_int,
    >,
    pub hw_crypto_3des_cbc_encrypt: ::core::option::Option<
        unsafe extern "C" fn(
            message: *const u8,
            msglen: u32,
            iv: *const u8,
            ivlen: u32,
            pResult: *mut u8,
        ) -> ffi::ctypes::c_int,
    >,
    pub use_hw_crypto_func: u32,
}
extern "C" {
    pub static mut rom_ssl_ram_map: _rom_ssl_ram_map;
}
extern "C" {
    pub static mut p_rom_ssl_ram_map: *mut _rom_mbedtls_ram_map;
}
pub type __gnuc_va_list = __builtin_va_list;
pub type va_list = __gnuc_va_list;
pub type _LOCK_T = ffi::ctypes::c_int;
pub type _LOCK_RECURSIVE_T = ffi::ctypes::c_int;
pub type __blkcnt_t = ffi::ctypes::c_long;
pub type __blksize_t = ffi::ctypes::c_long;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint32_t;
pub type _off_t = ffi::ctypes::c_long;
pub type __pid_t = ffi::ctypes::c_int;
pub type __dev_t = ffi::ctypes::c_short;
pub type __uid_t = ffi::ctypes::c_ushort;
pub type __gid_t = ffi::ctypes::c_ushort;
pub type __id_t = __uint32_t;
pub type __ino_t = ffi::ctypes::c_ushort;
pub type __mode_t = __uint32_t;
pub type _off64_t = ffi::ctypes::c_longlong;
pub type __off_t = _off_t;
pub type __loff_t = _off64_t;
pub type __key_t = ffi::ctypes::c_long;
pub type _fpos_t = ffi::ctypes::c_long;
pub type __size_t = ffi::ctypes::c_ulong;
pub type _ssize_t = ffi::ctypes::c_long;
pub type __ssize_t = _ssize_t;
pub type wint_t = ffi::ctypes::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mbstate_t {
    pub __count: ffi::ctypes::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [ffi::ctypes::c_uchar; 4usize],
    _bindgen_union_align: u32,
}
impl Default for _mbstate_t__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for _mbstate_t__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "_mbstate_t__bindgen_ty_1 {{ union }}")
    }
}
impl Default for _mbstate_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for _mbstate_t {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "_mbstate_t {{ __count: {:?}, __value: {:?} }}",
            self.__count, self.__value
        )
    }
}
pub type _flock_t = _LOCK_RECURSIVE_T;
pub type _iconv_t = *mut ffi::ctypes::c_void;
pub type __clock_t = ffi::ctypes::c_ulong;
pub type __time_t = ffi::ctypes::c_long;
pub type __clockid_t = ffi::ctypes::c_ulong;
pub type __timer_t = ffi::ctypes::c_ulong;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __nlink_t = ffi::ctypes::c_ushort;
pub type __suseconds_t = ffi::ctypes::c_long;
pub type __useconds_t = ffi::ctypes::c_ulong;
pub type __va_list = __builtin_va_list;
pub type __ULong = ffi::ctypes::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Bigint {
    pub _next: *mut _Bigint,
    pub _k: ffi::ctypes::c_int,
    pub _maxwds: ffi::ctypes::c_int,
    pub _sign: ffi::ctypes::c_int,
    pub _wds: ffi::ctypes::c_int,
    pub _x: [__ULong; 1usize],
}
impl Default for _Bigint {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __tm {
    pub __tm_sec: ffi::ctypes::c_int,
    pub __tm_min: ffi::ctypes::c_int,
    pub __tm_hour: ffi::ctypes::c_int,
    pub __tm_mday: ffi::ctypes::c_int,
    pub __tm_mon: ffi::ctypes::c_int,
    pub __tm_year: ffi::ctypes::c_int,
    pub __tm_wday: ffi::ctypes::c_int,
    pub __tm_yday: ffi::ctypes::c_int,
    pub __tm_isdst: ffi::ctypes::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _on_exit_args {
    pub _fnargs: [*mut ffi::ctypes::c_void; 32usize],
    pub _dso_handle: [*mut ffi::ctypes::c_void; 32usize],
    pub _fntypes: __ULong,
    pub _is_cxa: __ULong,
}
impl Default for _on_exit_args {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _atexit {
    pub _next: *mut _atexit,
    pub _ind: ffi::ctypes::c_int,
    pub _fns: [::core::option::Option<unsafe extern "C" fn()>; 32usize],
    pub _on_exit_args: _on_exit_args,
}
impl Default for _atexit {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ffi::ctypes::c_uchar,
    pub _size: ffi::ctypes::c_int,
}
impl Default for __sbuf {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ffi::ctypes::c_uchar,
    pub _r: ffi::ctypes::c_int,
    pub _w: ffi::ctypes::c_int,
    pub _flags: ffi::ctypes::c_short,
    pub _file: ffi::ctypes::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ffi::ctypes::c_int,
    pub _cookie: *mut ffi::ctypes::c_void,
    pub _read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ffi::ctypes::c_void,
            arg3: *mut ffi::ctypes::c_char,
            arg4: ffi::ctypes::c_int,
        ) -> ffi::ctypes::c_int,
    >,
    pub _write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ffi::ctypes::c_void,
            arg3: *const ffi::ctypes::c_char,
            arg4: ffi::ctypes::c_int,
        ) -> ffi::ctypes::c_int,
    >,
    pub _seek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ffi::ctypes::c_void,
            arg3: _fpos_t,
            arg4: ffi::ctypes::c_int,
        ) -> _fpos_t,
    >,
    pub _close: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ffi::ctypes::c_void,
        ) -> ffi::ctypes::c_int,
    >,
    pub _ub: __sbuf,
    pub _up: *mut ffi::ctypes::c_uchar,
    pub _ur: ffi::ctypes::c_int,
    pub _ubuf: [ffi::ctypes::c_uchar; 3usize],
    pub _nbuf: [ffi::ctypes::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ffi::ctypes::c_int,
    pub _offset: _off_t,
    pub _data: *mut _reent,
    pub _lock: _flock_t,
    pub _mbstate: _mbstate_t,
    pub _flags2: ffi::ctypes::c_int,
}
impl Default for __sFILE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for __sFILE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "__sFILE {{ _p: {:?}, _r: {:?}, _w: {:?}, _flags: {:?}, _file: {:?}, _bf: {:?}, _lbfsize: {:?}, _cookie: {:?}, _read: {:?}, _write: {:?}, _seek: {:?}, _close: {:?}, _ub: {:?}, _up: {:?}, _ur: {:?}, _ubuf: {:?}, _nbuf: {:?}, _lb: {:?}, _blksize: {:?}, _offset: {:?}, _data: {:?}, _lock: {:?}, _mbstate: {:?}, _flags2: {:?} }}" , self . _p , self . _r , self . _w , self . _flags , self . _file , self . _bf , self . _lbfsize , self . _cookie , self . _read , self . _write , self . _seek , self . _close , self . _ub , self . _up , self . _ur , self . _ubuf , self . _nbuf , self . _lb , self . _blksize , self . _offset , self . _data , self . _lock , self . _mbstate , self . _flags2)
    }
}
pub type __FILE = __sFILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _glue {
    pub _next: *mut _glue,
    pub _niobs: ffi::ctypes::c_int,
    pub _iobs: *mut __FILE,
}
impl Default for _glue {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _rand48 {
    pub _seed: [ffi::ctypes::c_ushort; 3usize],
    pub _mult: [ffi::ctypes::c_ushort; 3usize],
    pub _add: ffi::ctypes::c_ushort,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent {
    pub _errno: ffi::ctypes::c_int,
    pub _stdin: *mut __FILE,
    pub _stdout: *mut __FILE,
    pub _stderr: *mut __FILE,
    pub _inc: ffi::ctypes::c_int,
    pub _emergency: [ffi::ctypes::c_char; 25usize],
    pub _unspecified_locale_info: ffi::ctypes::c_int,
    pub _locale: *mut __locale_t,
    pub __sdidinit: ffi::ctypes::c_int,
    pub __cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent)>,
    pub _result: *mut _Bigint,
    pub _result_k: ffi::ctypes::c_int,
    pub _p5s: *mut _Bigint,
    pub _freelist: *mut *mut _Bigint,
    pub _cvtlen: ffi::ctypes::c_int,
    pub _cvtbuf: *mut ffi::ctypes::c_char,
    pub _new: _reent__bindgen_ty_1,
    pub _atexit: *mut _atexit,
    pub _atexit0: _atexit,
    pub _sig_func: *mut ::core::option::Option<unsafe extern "C" fn(arg1: ffi::ctypes::c_int)>,
    pub __sglue: _glue,
    pub __sf: [__FILE; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _reent__bindgen_ty_1 {
    pub _reent: _reent__bindgen_ty_1__bindgen_ty_1,
    pub _unused: _reent__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u64; 45usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_1 {
    pub _unused_rand: ffi::ctypes::c_uint,
    pub _strtok_last: *mut ffi::ctypes::c_char,
    pub _asctime_buf: [ffi::ctypes::c_char; 26usize],
    pub _localtime_buf: __tm,
    pub _gamma_signgam: ffi::ctypes::c_int,
    pub _rand_next: ffi::ctypes::c_ulonglong,
    pub _r48: _rand48,
    pub _mblen_state: _mbstate_t,
    pub _mbtowc_state: _mbstate_t,
    pub _wctomb_state: _mbstate_t,
    pub _l64a_buf: [ffi::ctypes::c_char; 8usize],
    pub _signal_buf: [ffi::ctypes::c_char; 24usize],
    pub _getdate_err: ffi::ctypes::c_int,
    pub _mbrlen_state: _mbstate_t,
    pub _mbrtowc_state: _mbstate_t,
    pub _mbsrtowcs_state: _mbstate_t,
    pub _wcrtomb_state: _mbstate_t,
    pub _wcsrtombs_state: _mbstate_t,
    pub _h_errno: ffi::ctypes::c_int,
}
impl Default for _reent__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for _reent__bindgen_ty_1__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "_reent__bindgen_ty_1__bindgen_ty_1 {{ _unused_rand: {:?}, _strtok_last: {:?}, _asctime_buf: {:?}, _localtime_buf: {:?}, _gamma_signgam: {:?}, _rand_next: {:?}, _r48: {:?}, _mblen_state: {:?}, _mbtowc_state: {:?}, _wctomb_state: {:?}, _l64a_buf: {:?}, _signal_buf: {:?}, _getdate_err: {:?}, _mbrlen_state: {:?}, _mbrtowc_state: {:?}, _mbsrtowcs_state: {:?}, _wcrtomb_state: {:?}, _wcsrtombs_state: {:?}, _h_errno: {:?} }}" , self . _unused_rand , self . _strtok_last , self . _asctime_buf , self . _localtime_buf , self . _gamma_signgam , self . _rand_next , self . _r48 , self . _mblen_state , self . _mbtowc_state , self . _wctomb_state , self . _l64a_buf , self . _signal_buf , self . _getdate_err , self . _mbrlen_state , self . _mbrtowc_state , self . _mbsrtowcs_state , self . _wcrtomb_state , self . _wcsrtombs_state , self . _h_errno)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_2 {
    pub _nextf: [*mut ffi::ctypes::c_uchar; 30usize],
    pub _nmalloc: [ffi::ctypes::c_uint; 30usize],
}
impl Default for _reent__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for _reent__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for _reent__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "_reent__bindgen_ty_1 {{ union }}")
    }
}
impl Default for _reent {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for _reent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "_reent {{ _errno: {:?}, _stdin: {:?}, _stdout: {:?}, _stderr: {:?}, _inc: {:?}, _emergency: {:?}, _unspecified_locale_info: {:?}, _locale: {:?}, __sdidinit: {:?}, __cleanup: {:?}, _result: {:?}, _result_k: {:?}, _p5s: {:?}, _freelist: {:?}, _cvtlen: {:?}, _cvtbuf: {:?}, _new: {:?}, _atexit: {:?}, _atexit0: {:?}, _sig_func: {:?}, __sglue: {:?}, __sf: {:?} }}" , self . _errno , self . _stdin , self . _stdout , self . _stderr , self . _inc , self . _emergency , self . _unspecified_locale_info , self . _locale , self . __sdidinit , self . __cleanup , self . _result , self . _result_k , self . _p5s , self . _freelist , self . _cvtlen , self . _cvtbuf , self . _new , self . _atexit , self . _atexit0 , self . _sig_func , self . __sglue , self . __sf)
    }
}
extern "C" {
    pub static mut _impure_ptr: *mut _reent;
}
extern "C" {
    pub static _global_impure_ptr: *mut _reent;
}
extern "C" {
    pub fn _reclaim_reent(arg1: *mut _reent);
}
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ffi::ctypes::c_int;
pub type __sigset_t = ffi::ctypes::c_ulong;
pub type suseconds_t = __suseconds_t;
pub type time_t = ffi::ctypes::c_long;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ffi::ctypes::c_long,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
pub type sigset_t = __sigset_t;
pub type fd_mask = ffi::ctypes::c_ulong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _types_fd_set {
    pub fds_bits: [fd_mask; 1usize],
}
extern "C" {
    pub fn select(
        __n: ffi::ctypes::c_int,
        __readfds: *mut _types_fd_set,
        __writefds: *mut _types_fd_set,
        __exceptfds: *mut _types_fd_set,
        __timeout: *mut timeval,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn pselect(
        __n: ffi::ctypes::c_int,
        __readfds: *mut _types_fd_set,
        __writefds: *mut _types_fd_set,
        __exceptfds: *mut _types_fd_set,
        __timeout: *const timespec,
        __set: *const sigset_t,
    ) -> ffi::ctypes::c_int;
}
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type u_char = ffi::ctypes::c_uchar;
pub type u_short = ffi::ctypes::c_ushort;
pub type u_int = ffi::ctypes::c_uint;
pub type u_long = ffi::ctypes::c_ulong;
pub type ushort = ffi::ctypes::c_ushort;
pub type ulong = ffi::ctypes::c_ulong;
pub type blkcnt_t = __blkcnt_t;
pub type blksize_t = __blksize_t;
pub type clock_t = ffi::ctypes::c_ulong;
pub type daddr_t = ffi::ctypes::c_long;
pub type caddr_t = *mut ffi::ctypes::c_char;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type id_t = __id_t;
pub type ino_t = __ino_t;
pub type off_t = __off_t;
pub type dev_t = __dev_t;
pub type uid_t = __uid_t;
pub type gid_t = __gid_t;
pub type pid_t = __pid_t;
pub type key_t = __key_t;
pub type ssize_t = _ssize_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type useconds_t = __useconds_t;
pub type sbintime_t = __int64_t;
pub type FILE = __FILE;
pub type fpos_t = _fpos_t;
extern "C" {
    pub fn ctermid(arg1: *mut ffi::ctypes::c_char) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ffi::ctypes::c_char) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn tempnam(
        arg1: *const ffi::ctypes::c_char,
        arg2: *const ffi::ctypes::c_char,
    ) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn freopen(
        arg1: *const ffi::ctypes::c_char,
        arg2: *const ffi::ctypes::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ffi::ctypes::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut ffi::ctypes::c_char,
        arg3: ffi::ctypes::c_int,
        arg4: size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn fprintf(arg1: *mut FILE, arg2: *const ffi::ctypes::c_char, ...) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn fscanf(arg1: *mut FILE, arg2: *const ffi::ctypes::c_char, ...) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn printf(arg1: *const ffi::ctypes::c_char, ...) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn scanf(arg1: *const ffi::ctypes::c_char, ...) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn sscanf(
        arg1: *const ffi::ctypes::c_char,
        arg2: *const ffi::ctypes::c_char,
        ...
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const ffi::ctypes::c_char,
        arg3: *mut __va_list_tag,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn vprintf(
        arg1: *const ffi::ctypes::c_char,
        arg2: *mut __va_list_tag,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn vsprintf(
        arg1: *mut ffi::ctypes::c_char,
        arg2: *const ffi::ctypes::c_char,
        arg3: *mut __va_list_tag,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn fgets(
        arg1: *mut ffi::ctypes::c_char,
        arg2: ffi::ctypes::c_int,
        arg3: *mut FILE,
    ) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn fputc(arg1: ffi::ctypes::c_int, arg2: *mut FILE) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const ffi::ctypes::c_char, arg2: *mut FILE) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn getchar() -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut ffi::ctypes::c_char) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn putc(arg1: ffi::ctypes::c_int, arg2: *mut FILE) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn putchar(arg1: ffi::ctypes::c_int) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn puts(arg1: *const ffi::ctypes::c_char) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn ungetc(arg1: ffi::ctypes::c_int, arg2: *mut FILE) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn fread(
        arg1: *mut ffi::ctypes::c_void,
        _size: ffi::ctypes::c_ulong,
        _n: ffi::ctypes::c_ulong,
        arg2: *mut FILE,
    ) -> ffi::ctypes::c_ulong;
}
extern "C" {
    pub fn fwrite(
        arg1: *const ffi::ctypes::c_void,
        _size: ffi::ctypes::c_ulong,
        _n: ffi::ctypes::c_ulong,
        arg2: *mut FILE,
    ) -> ffi::ctypes::c_ulong;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn fseek(
        arg1: *mut FILE,
        arg2: ffi::ctypes::c_long,
        arg3: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ffi::ctypes::c_long;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn perror(arg1: *const ffi::ctypes::c_char);
}
extern "C" {
    pub fn fopen(_name: *const ffi::ctypes::c_char, _type: *const ffi::ctypes::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn sprintf(
        arg1: *mut ffi::ctypes::c_char,
        arg2: *const ffi::ctypes::c_char,
        ...
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn remove(arg1: *const ffi::ctypes::c_char) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rename(
        arg1: *const ffi::ctypes::c_char,
        arg2: *const ffi::ctypes::c_char,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn fseeko(arg1: *mut FILE, arg2: off_t, arg3: ffi::ctypes::c_int) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn ftello(arg1: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(
        arg1: *mut ffi::ctypes::c_char,
        arg2: ffi::ctypes::c_ulong,
        arg3: *const ffi::ctypes::c_char,
        ...
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn vsnprintf(
        arg1: *mut ffi::ctypes::c_char,
        arg2: ffi::ctypes::c_ulong,
        arg3: *const ffi::ctypes::c_char,
        arg4: *mut __va_list_tag,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn vfscanf(
        arg1: *mut FILE,
        arg2: *const ffi::ctypes::c_char,
        arg3: *mut __va_list_tag,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn vscanf(arg1: *const ffi::ctypes::c_char, arg2: *mut __va_list_tag)
        -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn vsscanf(
        arg1: *const ffi::ctypes::c_char,
        arg2: *const ffi::ctypes::c_char,
        arg3: *mut __va_list_tag,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn asiprintf(
        arg1: *mut *mut ffi::ctypes::c_char,
        arg2: *const ffi::ctypes::c_char,
        ...
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn asniprintf(
        arg1: *mut ffi::ctypes::c_char,
        arg2: *mut size_t,
        arg3: *const ffi::ctypes::c_char,
        ...
    ) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn asnprintf(
        arg1: *mut ffi::ctypes::c_char,
        arg2: *mut size_t,
        arg3: *const ffi::ctypes::c_char,
        ...
    ) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn diprintf(
        arg1: ffi::ctypes::c_int,
        arg2: *const ffi::ctypes::c_char,
        ...
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn fiprintf(arg1: *mut FILE, arg2: *const ffi::ctypes::c_char, ...) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn fiscanf(arg1: *mut FILE, arg2: *const ffi::ctypes::c_char, ...) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn iprintf(arg1: *const ffi::ctypes::c_char, ...) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn iscanf(arg1: *const ffi::ctypes::c_char, ...) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn siprintf(
        arg1: *mut ffi::ctypes::c_char,
        arg2: *const ffi::ctypes::c_char,
        ...
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn siscanf(
        arg1: *const ffi::ctypes::c_char,
        arg2: *const ffi::ctypes::c_char,
        ...
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn sniprintf(
        arg1: *mut ffi::ctypes::c_char,
        arg2: size_t,
        arg3: *const ffi::ctypes::c_char,
        ...
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn vasiprintf(
        arg1: *mut *mut ffi::ctypes::c_char,
        arg2: *const ffi::ctypes::c_char,
        arg3: *mut __va_list_tag,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn vasniprintf(
        arg1: *mut ffi::ctypes::c_char,
        arg2: *mut size_t,
        arg3: *const ffi::ctypes::c_char,
        arg4: *mut __va_list_tag,
    ) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn vasnprintf(
        arg1: *mut ffi::ctypes::c_char,
        arg2: *mut size_t,
        arg3: *const ffi::ctypes::c_char,
        arg4: *mut __va_list_tag,
    ) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn vdiprintf(
        arg1: ffi::ctypes::c_int,
        arg2: *const ffi::ctypes::c_char,
        arg3: *mut __va_list_tag,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn vfiprintf(
        arg1: *mut FILE,
        arg2: *const ffi::ctypes::c_char,
        arg3: *mut __va_list_tag,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn vfiscanf(
        arg1: *mut FILE,
        arg2: *const ffi::ctypes::c_char,
        arg3: *mut __va_list_tag,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn viprintf(
        arg1: *const ffi::ctypes::c_char,
        arg2: *mut __va_list_tag,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn viscanf(
        arg1: *const ffi::ctypes::c_char,
        arg2: *mut __va_list_tag,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn vsiprintf(
        arg1: *mut ffi::ctypes::c_char,
        arg2: *const ffi::ctypes::c_char,
        arg3: *mut __va_list_tag,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn vsiscanf(
        arg1: *const ffi::ctypes::c_char,
        arg2: *const ffi::ctypes::c_char,
        arg3: *mut __va_list_tag,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn vsniprintf(
        arg1: *mut ffi::ctypes::c_char,
        arg2: size_t,
        arg3: *const ffi::ctypes::c_char,
        arg4: *mut __va_list_tag,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn fdopen(arg1: ffi::ctypes::c_int, arg2: *const ffi::ctypes::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn popen(arg1: *const ffi::ctypes::c_char, arg2: *const ffi::ctypes::c_char) -> *mut FILE;
}
extern "C" {
    pub fn setbuffer(arg1: *mut FILE, arg2: *mut ffi::ctypes::c_char, arg3: ffi::ctypes::c_int);
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn putw(arg1: ffi::ctypes::c_int, arg2: *mut FILE) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn putc_unlocked(arg1: ffi::ctypes::c_int, arg2: *mut FILE) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: ffi::ctypes::c_int) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn dprintf(
        arg1: ffi::ctypes::c_int,
        arg2: *const ffi::ctypes::c_char,
        ...
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn fmemopen(
        arg1: *mut ffi::ctypes::c_void,
        arg2: size_t,
        arg3: *const ffi::ctypes::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(arg1: *mut *mut ffi::ctypes::c_char, arg2: *mut size_t) -> *mut FILE;
}
extern "C" {
    pub fn vdprintf(
        arg1: ffi::ctypes::c_int,
        arg2: *const ffi::ctypes::c_char,
        arg3: *mut __va_list_tag,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn renameat(
        arg1: ffi::ctypes::c_int,
        arg2: *const ffi::ctypes::c_char,
        arg3: ffi::ctypes::c_int,
        arg4: *const ffi::ctypes::c_char,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _asiprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut ffi::ctypes::c_char,
        arg3: *const ffi::ctypes::c_char,
        ...
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _asniprintf_r(
        arg1: *mut _reent,
        arg2: *mut ffi::ctypes::c_char,
        arg3: *mut size_t,
        arg4: *const ffi::ctypes::c_char,
        ...
    ) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn _asnprintf_r(
        arg1: *mut _reent,
        arg2: *mut ffi::ctypes::c_char,
        arg3: *mut size_t,
        arg4: *const ffi::ctypes::c_char,
        ...
    ) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn _asprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut ffi::ctypes::c_char,
        arg3: *const ffi::ctypes::c_char,
        ...
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _diprintf_r(
        arg1: *mut _reent,
        arg2: ffi::ctypes::c_int,
        arg3: *const ffi::ctypes::c_char,
        ...
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _dprintf_r(
        arg1: *mut _reent,
        arg2: ffi::ctypes::c_int,
        arg3: *const ffi::ctypes::c_char,
        ...
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _fclose_r(arg1: *mut _reent, arg2: *mut FILE) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _fcloseall_r(arg1: *mut _reent) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _fdopen_r(
        arg1: *mut _reent,
        arg2: ffi::ctypes::c_int,
        arg3: *const ffi::ctypes::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fflush_r(arg1: *mut _reent, arg2: *mut FILE) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _fgetc_r(arg1: *mut _reent, arg2: *mut FILE) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _fgetc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _fgets_r(
        arg1: *mut _reent,
        arg2: *mut ffi::ctypes::c_char,
        arg3: ffi::ctypes::c_int,
        arg4: *mut FILE,
    ) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn _fgets_unlocked_r(
        arg1: *mut _reent,
        arg2: *mut ffi::ctypes::c_char,
        arg3: ffi::ctypes::c_int,
        arg4: *mut FILE,
    ) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn _fgetpos_r(arg1: *mut _reent, arg2: *mut FILE, arg3: *mut fpos_t) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _fsetpos_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const fpos_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _fiprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ffi::ctypes::c_char,
        ...
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _fiscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ffi::ctypes::c_char,
        ...
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _fmemopen_r(
        arg1: *mut _reent,
        arg2: *mut ffi::ctypes::c_void,
        arg3: size_t,
        arg4: *const ffi::ctypes::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fopen_r(
        arg1: *mut _reent,
        arg2: *const ffi::ctypes::c_char,
        arg3: *const ffi::ctypes::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _freopen_r(
        arg1: *mut _reent,
        arg2: *const ffi::ctypes::c_char,
        arg3: *const ffi::ctypes::c_char,
        arg4: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ffi::ctypes::c_char,
        ...
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _fpurge_r(arg1: *mut _reent, arg2: *mut FILE) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _fputc_r(
        arg1: *mut _reent,
        arg2: ffi::ctypes::c_int,
        arg3: *mut FILE,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _fputc_unlocked_r(
        arg1: *mut _reent,
        arg2: ffi::ctypes::c_int,
        arg3: *mut FILE,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _fputs_r(
        arg1: *mut _reent,
        arg2: *const ffi::ctypes::c_char,
        arg3: *mut FILE,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _fputs_unlocked_r(
        arg1: *mut _reent,
        arg2: *const ffi::ctypes::c_char,
        arg3: *mut FILE,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _fread_r(
        arg1: *mut _reent,
        arg2: *mut ffi::ctypes::c_void,
        _size: size_t,
        _n: size_t,
        arg3: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn _fread_unlocked_r(
        arg1: *mut _reent,
        arg2: *mut ffi::ctypes::c_void,
        _size: size_t,
        _n: size_t,
        arg3: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn _fscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ffi::ctypes::c_char,
        ...
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _fseek_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: ffi::ctypes::c_long,
        arg4: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _fseeko_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: _off_t,
        arg4: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _ftell_r(arg1: *mut _reent, arg2: *mut FILE) -> ffi::ctypes::c_long;
}
extern "C" {
    pub fn _ftello_r(arg1: *mut _reent, arg2: *mut FILE) -> _off_t;
}
extern "C" {
    pub fn _rewind_r(arg1: *mut _reent, arg2: *mut FILE);
}
extern "C" {
    pub fn _fwrite_r(
        arg1: *mut _reent,
        arg2: *const ffi::ctypes::c_void,
        _size: size_t,
        _n: size_t,
        arg3: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn _fwrite_unlocked_r(
        arg1: *mut _reent,
        arg2: *const ffi::ctypes::c_void,
        _size: size_t,
        _n: size_t,
        arg3: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn _getc_r(arg1: *mut _reent, arg2: *mut FILE) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _getc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _getchar_r(arg1: *mut _reent) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _getchar_unlocked_r(arg1: *mut _reent) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _gets_r(arg1: *mut _reent, arg2: *mut ffi::ctypes::c_char) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn _iprintf_r(
        arg1: *mut _reent,
        arg2: *const ffi::ctypes::c_char,
        ...
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _iscanf_r(
        arg1: *mut _reent,
        arg2: *const ffi::ctypes::c_char,
        ...
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _open_memstream_r(
        arg1: *mut _reent,
        arg2: *mut *mut ffi::ctypes::c_char,
        arg3: *mut size_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _perror_r(arg1: *mut _reent, arg2: *const ffi::ctypes::c_char);
}
extern "C" {
    pub fn _printf_r(
        arg1: *mut _reent,
        arg2: *const ffi::ctypes::c_char,
        ...
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _putc_r(
        arg1: *mut _reent,
        arg2: ffi::ctypes::c_int,
        arg3: *mut FILE,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _putc_unlocked_r(
        arg1: *mut _reent,
        arg2: ffi::ctypes::c_int,
        arg3: *mut FILE,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _putchar_unlocked_r(arg1: *mut _reent, arg2: ffi::ctypes::c_int) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _putchar_r(arg1: *mut _reent, arg2: ffi::ctypes::c_int) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _puts_r(arg1: *mut _reent, arg2: *const ffi::ctypes::c_char) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _remove_r(arg1: *mut _reent, arg2: *const ffi::ctypes::c_char) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _rename_r(
        arg1: *mut _reent,
        _old: *const ffi::ctypes::c_char,
        _new: *const ffi::ctypes::c_char,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _scanf_r(arg1: *mut _reent, arg2: *const ffi::ctypes::c_char, ...)
        -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _siprintf_r(
        arg1: *mut _reent,
        arg2: *mut ffi::ctypes::c_char,
        arg3: *const ffi::ctypes::c_char,
        ...
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _siscanf_r(
        arg1: *mut _reent,
        arg2: *const ffi::ctypes::c_char,
        arg3: *const ffi::ctypes::c_char,
        ...
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _sniprintf_r(
        arg1: *mut _reent,
        arg2: *mut ffi::ctypes::c_char,
        arg3: size_t,
        arg4: *const ffi::ctypes::c_char,
        ...
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _snprintf_r(
        arg1: *mut _reent,
        arg2: *mut ffi::ctypes::c_char,
        arg3: size_t,
        arg4: *const ffi::ctypes::c_char,
        ...
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _sprintf_r(
        arg1: *mut _reent,
        arg2: *mut ffi::ctypes::c_char,
        arg3: *const ffi::ctypes::c_char,
        ...
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _sscanf_r(
        arg1: *mut _reent,
        arg2: *const ffi::ctypes::c_char,
        arg3: *const ffi::ctypes::c_char,
        ...
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _tempnam_r(
        arg1: *mut _reent,
        arg2: *const ffi::ctypes::c_char,
        arg3: *const ffi::ctypes::c_char,
    ) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn _tmpfile_r(arg1: *mut _reent) -> *mut FILE;
}
extern "C" {
    pub fn _tmpnam_r(arg1: *mut _reent, arg2: *mut ffi::ctypes::c_char)
        -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn _ungetc_r(
        arg1: *mut _reent,
        arg2: ffi::ctypes::c_int,
        arg3: *mut FILE,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _vasiprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut ffi::ctypes::c_char,
        arg3: *const ffi::ctypes::c_char,
        arg4: *mut __va_list_tag,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _vasniprintf_r(
        arg1: *mut _reent,
        arg2: *mut ffi::ctypes::c_char,
        arg3: *mut size_t,
        arg4: *const ffi::ctypes::c_char,
        arg5: *mut __va_list_tag,
    ) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn _vasnprintf_r(
        arg1: *mut _reent,
        arg2: *mut ffi::ctypes::c_char,
        arg3: *mut size_t,
        arg4: *const ffi::ctypes::c_char,
        arg5: *mut __va_list_tag,
    ) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn _vasprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut ffi::ctypes::c_char,
        arg3: *const ffi::ctypes::c_char,
        arg4: *mut __va_list_tag,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _vdiprintf_r(
        arg1: *mut _reent,
        arg2: ffi::ctypes::c_int,
        arg3: *const ffi::ctypes::c_char,
        arg4: *mut __va_list_tag,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _vdprintf_r(
        arg1: *mut _reent,
        arg2: ffi::ctypes::c_int,
        arg3: *const ffi::ctypes::c_char,
        arg4: *mut __va_list_tag,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _vfiprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ffi::ctypes::c_char,
        arg4: *mut __va_list_tag,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _vfiscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ffi::ctypes::c_char,
        arg4: *mut __va_list_tag,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _vfprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ffi::ctypes::c_char,
        arg4: *mut __va_list_tag,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _vfscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ffi::ctypes::c_char,
        arg4: *mut __va_list_tag,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _viprintf_r(
        arg1: *mut _reent,
        arg2: *const ffi::ctypes::c_char,
        arg3: *mut __va_list_tag,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _viscanf_r(
        arg1: *mut _reent,
        arg2: *const ffi::ctypes::c_char,
        arg3: *mut __va_list_tag,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _vprintf_r(
        arg1: *mut _reent,
        arg2: *const ffi::ctypes::c_char,
        arg3: *mut __va_list_tag,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _vscanf_r(
        arg1: *mut _reent,
        arg2: *const ffi::ctypes::c_char,
        arg3: *mut __va_list_tag,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _vsiprintf_r(
        arg1: *mut _reent,
        arg2: *mut ffi::ctypes::c_char,
        arg3: *const ffi::ctypes::c_char,
        arg4: *mut __va_list_tag,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _vsiscanf_r(
        arg1: *mut _reent,
        arg2: *const ffi::ctypes::c_char,
        arg3: *const ffi::ctypes::c_char,
        arg4: *mut __va_list_tag,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _vsniprintf_r(
        arg1: *mut _reent,
        arg2: *mut ffi::ctypes::c_char,
        arg3: size_t,
        arg4: *const ffi::ctypes::c_char,
        arg5: *mut __va_list_tag,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _vsnprintf_r(
        arg1: *mut _reent,
        arg2: *mut ffi::ctypes::c_char,
        arg3: size_t,
        arg4: *const ffi::ctypes::c_char,
        arg5: *mut __va_list_tag,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _vsprintf_r(
        arg1: *mut _reent,
        arg2: *mut ffi::ctypes::c_char,
        arg3: *const ffi::ctypes::c_char,
        arg4: *mut __va_list_tag,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _vsscanf_r(
        arg1: *mut _reent,
        arg2: *const ffi::ctypes::c_char,
        arg3: *const ffi::ctypes::c_char,
        arg4: *mut __va_list_tag,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn __getdelim(
        arg1: *mut *mut ffi::ctypes::c_char,
        arg2: *mut size_t,
        arg3: ffi::ctypes::c_int,
        arg4: *mut FILE,
    ) -> ssize_t;
}
extern "C" {
    pub fn __getline(
        arg1: *mut *mut ffi::ctypes::c_char,
        arg2: *mut size_t,
        arg3: *mut FILE,
    ) -> ssize_t;
}
extern "C" {
    pub fn clearerr_unlocked(arg1: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(arg1: *mut FILE) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn ferror_unlocked(arg1: *mut FILE) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn fileno_unlocked(arg1: *mut FILE) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn fflush_unlocked(arg1: *mut FILE) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(arg1: *mut FILE) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn fputc_unlocked(arg1: ffi::ctypes::c_int, arg2: *mut FILE) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn fread_unlocked(
        arg1: *mut ffi::ctypes::c_void,
        _size: size_t,
        _n: size_t,
        arg2: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fwrite_unlocked(
        arg1: *const ffi::ctypes::c_void,
        _size: size_t,
        _n: size_t,
        arg2: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn __srget_r(arg1: *mut _reent, arg2: *mut FILE) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn __swbuf_r(
        arg1: *mut _reent,
        arg2: ffi::ctypes::c_int,
        arg3: *mut FILE,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn funopen(
        __cookie: *const ffi::ctypes::c_void,
        __readfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ffi::ctypes::c_void,
                __buf: *mut ffi::ctypes::c_char,
                __n: ffi::ctypes::c_int,
            ) -> ffi::ctypes::c_int,
        >,
        __writefn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ffi::ctypes::c_void,
                __buf: *const ffi::ctypes::c_char,
                __n: ffi::ctypes::c_int,
            ) -> ffi::ctypes::c_int,
        >,
        __seekfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ffi::ctypes::c_void,
                __off: fpos_t,
                __whence: ffi::ctypes::c_int,
            ) -> fpos_t,
        >,
        __closefn: ::core::option::Option<
            unsafe extern "C" fn(__cookie: *mut ffi::ctypes::c_void) -> ffi::ctypes::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _funopen_r(
        arg1: *mut _reent,
        __cookie: *const ffi::ctypes::c_void,
        __readfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ffi::ctypes::c_void,
                __buf: *mut ffi::ctypes::c_char,
                __n: ffi::ctypes::c_int,
            ) -> ffi::ctypes::c_int,
        >,
        __writefn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ffi::ctypes::c_void,
                __buf: *const ffi::ctypes::c_char,
                __n: ffi::ctypes::c_int,
            ) -> ffi::ctypes::c_int,
        >,
        __seekfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ffi::ctypes::c_void,
                __off: fpos_t,
                __whence: ffi::ctypes::c_int,
            ) -> fpos_t,
        >,
        __closefn: ::core::option::Option<
            unsafe extern "C" fn(__cookie: *mut ffi::ctypes::c_void) -> ffi::ctypes::c_int,
        >,
    ) -> *mut FILE;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct div_t {
    pub quot: ffi::ctypes::c_int,
    pub rem: ffi::ctypes::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ffi::ctypes::c_long,
    pub rem: ffi::ctypes::c_long,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ffi::ctypes::c_longlong,
    pub rem: ffi::ctypes::c_longlong,
}
pub type __compar_fn_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *const ffi::ctypes::c_void,
        arg2: *const ffi::ctypes::c_void,
    ) -> ffi::ctypes::c_int,
>;
extern "C" {
    pub fn __locale_mb_cur_max() -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn abs(arg1: ffi::ctypes::c_int) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn arc4random() -> __uint32_t;
}
extern "C" {
    pub fn arc4random_uniform(arg1: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn arc4random_buf(arg1: *mut ffi::ctypes::c_void, arg2: size_t);
}
extern "C" {
    pub fn atexit(__func: ::core::option::Option<unsafe extern "C" fn()>) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn atof(__nptr: *const ffi::ctypes::c_char) -> f64;
}
extern "C" {
    pub fn atoff(__nptr: *const ffi::ctypes::c_char) -> f32;
}
extern "C" {
    pub fn atoi(__nptr: *const ffi::ctypes::c_char) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _atoi_r(arg1: *mut _reent, __nptr: *const ffi::ctypes::c_char) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ffi::ctypes::c_char) -> ffi::ctypes::c_long;
}
extern "C" {
    pub fn _atol_r(arg1: *mut _reent, __nptr: *const ffi::ctypes::c_char) -> ffi::ctypes::c_long;
}
extern "C" {
    pub fn bsearch(
        __key: *const ffi::ctypes::c_void,
        __base: *const ffi::ctypes::c_void,
        __nmemb: size_t,
        __size: size_t,
        _compar: __compar_fn_t,
    ) -> *mut ffi::ctypes::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ffi::ctypes::c_ulong,
        __size: ffi::ctypes::c_ulong,
    ) -> *mut ffi::ctypes::c_void;
}
extern "C" {
    pub fn div(__numer: ffi::ctypes::c_int, __denom: ffi::ctypes::c_int) -> div_t;
}
extern "C" {
    pub fn exit(__status: ffi::ctypes::c_int);
}
extern "C" {
    pub fn free(arg1: *mut ffi::ctypes::c_void);
}
extern "C" {
    pub fn getenv(__string: *const ffi::ctypes::c_char) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn _getenv_r(
        arg1: *mut _reent,
        __string: *const ffi::ctypes::c_char,
    ) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn _findenv(
        arg1: *const ffi::ctypes::c_char,
        arg2: *mut ffi::ctypes::c_int,
    ) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn _findenv_r(
        arg1: *mut _reent,
        arg2: *const ffi::ctypes::c_char,
        arg3: *mut ffi::ctypes::c_int,
    ) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub static mut suboptarg: *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut ffi::ctypes::c_char,
        arg2: *const *mut ffi::ctypes::c_char,
        arg3: *mut *mut ffi::ctypes::c_char,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn labs(arg1: ffi::ctypes::c_long) -> ffi::ctypes::c_long;
}
extern "C" {
    pub fn ldiv(__numer: ffi::ctypes::c_long, __denom: ffi::ctypes::c_long) -> ldiv_t;
}
extern "C" {
    pub fn malloc(__size: ffi::ctypes::c_ulong) -> *mut ffi::ctypes::c_void;
}
extern "C" {
    pub fn mblen(arg1: *const ffi::ctypes::c_char, arg2: size_t) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _mblen_r(
        arg1: *mut _reent,
        arg2: *const ffi::ctypes::c_char,
        arg3: size_t,
        arg4: *mut _mbstate_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbtowc(
        arg1: *mut wchar_t,
        arg2: *const ffi::ctypes::c_char,
        arg3: size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _mbtowc_r(
        arg1: *mut _reent,
        arg2: *mut wchar_t,
        arg3: *const ffi::ctypes::c_char,
        arg4: size_t,
        arg5: *mut _mbstate_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wctomb(arg1: *mut ffi::ctypes::c_char, arg2: wchar_t) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _wctomb_r(
        arg1: *mut _reent,
        arg2: *mut ffi::ctypes::c_char,
        arg3: wchar_t,
        arg4: *mut _mbstate_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const ffi::ctypes::c_char, arg3: size_t) -> size_t;
}
extern "C" {
    pub fn _mbstowcs_r(
        arg1: *mut _reent,
        arg2: *mut wchar_t,
        arg3: *const ffi::ctypes::c_char,
        arg4: size_t,
        arg5: *mut _mbstate_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcstombs(arg1: *mut ffi::ctypes::c_char, arg2: *const wchar_t, arg3: size_t) -> size_t;
}
extern "C" {
    pub fn _wcstombs_r(
        arg1: *mut _reent,
        arg2: *mut ffi::ctypes::c_char,
        arg3: *const wchar_t,
        arg4: size_t,
        arg5: *mut _mbstate_t,
    ) -> size_t;
}
extern "C" {
    pub fn mkdtemp(arg1: *mut ffi::ctypes::c_char) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn mkstemp(arg1: *mut ffi::ctypes::c_char) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mkstemps(arg1: *mut ffi::ctypes::c_char, arg2: ffi::ctypes::c_int)
        -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mktemp(arg1: *mut ffi::ctypes::c_char) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn _mkdtemp_r(
        arg1: *mut _reent,
        arg2: *mut ffi::ctypes::c_char,
    ) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn _mkostemp_r(
        arg1: *mut _reent,
        arg2: *mut ffi::ctypes::c_char,
        arg3: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _mkostemps_r(
        arg1: *mut _reent,
        arg2: *mut ffi::ctypes::c_char,
        arg3: ffi::ctypes::c_int,
        arg4: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _mkstemp_r(arg1: *mut _reent, arg2: *mut ffi::ctypes::c_char) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _mkstemps_r(
        arg1: *mut _reent,
        arg2: *mut ffi::ctypes::c_char,
        arg3: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _mktemp_r(arg1: *mut _reent, arg2: *mut ffi::ctypes::c_char)
        -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn qsort(
        __base: *mut ffi::ctypes::c_void,
        __nmemb: size_t,
        __size: size_t,
        _compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn rand() -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn realloc(
        __r: *mut ffi::ctypes::c_void,
        __size: ffi::ctypes::c_ulong,
    ) -> *mut ffi::ctypes::c_void;
}
extern "C" {
    pub fn reallocf(__r: *mut ffi::ctypes::c_void, __size: size_t) -> *mut ffi::ctypes::c_void;
}
extern "C" {
    pub fn realpath(
        path: *const ffi::ctypes::c_char,
        resolved_path: *mut ffi::ctypes::c_char,
    ) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn rpmatch(response: *const ffi::ctypes::c_char) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn srand(__seed: ffi::ctypes::c_uint);
}
extern "C" {
    pub fn strtod(__n: *const ffi::ctypes::c_char, __end_PTR: *mut *mut ffi::ctypes::c_char)
        -> f64;
}
extern "C" {
    pub fn _strtod_r(
        arg1: *mut _reent,
        __n: *const ffi::ctypes::c_char,
        __end_PTR: *mut *mut ffi::ctypes::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(__n: *const ffi::ctypes::c_char, __end_PTR: *mut *mut ffi::ctypes::c_char)
        -> f32;
}
extern "C" {
    pub fn strtol(
        __n: *const ffi::ctypes::c_char,
        __end_PTR: *mut *mut ffi::ctypes::c_char,
        __base: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_long;
}
extern "C" {
    pub fn _strtol_r(
        arg1: *mut _reent,
        __n: *const ffi::ctypes::c_char,
        __end_PTR: *mut *mut ffi::ctypes::c_char,
        __base: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_long;
}
extern "C" {
    pub fn strtoul(
        __n: *const ffi::ctypes::c_char,
        __end_PTR: *mut *mut ffi::ctypes::c_char,
        __base: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_ulong;
}
extern "C" {
    pub fn _strtoul_r(
        arg1: *mut _reent,
        __n: *const ffi::ctypes::c_char,
        __end_PTR: *mut *mut ffi::ctypes::c_char,
        __base: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_ulong;
}
extern "C" {
    pub fn system(__string: *const ffi::ctypes::c_char) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn a64l(__input: *const ffi::ctypes::c_char) -> ffi::ctypes::c_long;
}
extern "C" {
    pub fn l64a(__input: ffi::ctypes::c_long) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn _l64a_r(arg1: *mut _reent, __input: ffi::ctypes::c_long) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn on_exit(
        __func: ::core::option::Option<
            unsafe extern "C" fn(arg1: ffi::ctypes::c_int, arg2: *mut ffi::ctypes::c_void),
        >,
        __arg: *mut ffi::ctypes::c_void,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _Exit(__status: ffi::ctypes::c_int);
}
extern "C" {
    pub fn putenv(__string: *mut ffi::ctypes::c_char) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _putenv_r(arg1: *mut _reent, __string: *mut ffi::ctypes::c_char) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _reallocf_r(
        arg1: *mut _reent,
        arg2: *mut ffi::ctypes::c_void,
        arg3: size_t,
    ) -> *mut ffi::ctypes::c_void;
}
extern "C" {
    pub fn setenv(
        __string: *const ffi::ctypes::c_char,
        __value: *const ffi::ctypes::c_char,
        __overwrite: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _setenv_r(
        arg1: *mut _reent,
        __string: *const ffi::ctypes::c_char,
        __value: *const ffi::ctypes::c_char,
        __overwrite: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn __itoa(
        arg1: ffi::ctypes::c_int,
        arg2: *mut ffi::ctypes::c_char,
        arg3: ffi::ctypes::c_int,
    ) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn __utoa(
        arg1: ffi::ctypes::c_uint,
        arg2: *mut ffi::ctypes::c_char,
        arg3: ffi::ctypes::c_int,
    ) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn itoa(
        arg1: ffi::ctypes::c_int,
        arg2: *mut ffi::ctypes::c_char,
        arg3: ffi::ctypes::c_int,
    ) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn utoa(
        arg1: ffi::ctypes::c_uint,
        arg2: *mut ffi::ctypes::c_char,
        arg3: ffi::ctypes::c_int,
    ) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn rand_r(__seed: *mut ffi::ctypes::c_uint) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn _drand48_r(arg1: *mut _reent) -> f64;
}
extern "C" {
    pub fn erand48(arg1: *mut ffi::ctypes::c_ushort) -> f64;
}
extern "C" {
    pub fn _erand48_r(arg1: *mut _reent, arg2: *mut ffi::ctypes::c_ushort) -> f64;
}
extern "C" {
    pub fn jrand48(arg1: *mut ffi::ctypes::c_ushort) -> ffi::ctypes::c_long;
}
extern "C" {
    pub fn _jrand48_r(arg1: *mut _reent, arg2: *mut ffi::ctypes::c_ushort) -> ffi::ctypes::c_long;
}
extern "C" {
    pub fn lcong48(arg1: *mut ffi::ctypes::c_ushort);
}
extern "C" {
    pub fn _lcong48_r(arg1: *mut _reent, arg2: *mut ffi::ctypes::c_ushort);
}
extern "C" {
    pub fn lrand48() -> ffi::ctypes::c_long;
}
extern "C" {
    pub fn _lrand48_r(arg1: *mut _reent) -> ffi::ctypes::c_long;
}
extern "C" {
    pub fn mrand48() -> ffi::ctypes::c_long;
}
extern "C" {
    pub fn _mrand48_r(arg1: *mut _reent) -> ffi::ctypes::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut ffi::ctypes::c_ushort) -> ffi::ctypes::c_long;
}
extern "C" {
    pub fn _nrand48_r(arg1: *mut _reent, arg2: *mut ffi::ctypes::c_ushort) -> ffi::ctypes::c_long;
}
extern "C" {
    pub fn seed48(arg1: *mut ffi::ctypes::c_ushort) -> *mut ffi::ctypes::c_ushort;
}
extern "C" {
    pub fn _seed48_r(
        arg1: *mut _reent,
        arg2: *mut ffi::ctypes::c_ushort,
    ) -> *mut ffi::ctypes::c_ushort;
}
extern "C" {
    pub fn srand48(arg1: ffi::ctypes::c_long);
}
extern "C" {
    pub fn _srand48_r(arg1: *mut _reent, arg2: ffi::ctypes::c_long);
}
extern "C" {
    pub fn initstate(
        arg1: ffi::ctypes::c_uint,
        arg2: *mut ffi::ctypes::c_char,
        arg3: size_t,
    ) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn random() -> ffi::ctypes::c_long;
}
extern "C" {
    pub fn setstate(arg1: *mut ffi::ctypes::c_char) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn srandom(arg1: ffi::ctypes::c_uint);
}
extern "C" {
    pub fn atoll(__nptr: *const ffi::ctypes::c_char) -> ffi::ctypes::c_longlong;
}
extern "C" {
    pub fn _atoll_r(
        arg1: *mut _reent,
        __nptr: *const ffi::ctypes::c_char,
    ) -> ffi::ctypes::c_longlong;
}
extern "C" {
    pub fn llabs(arg1: ffi::ctypes::c_longlong) -> ffi::ctypes::c_longlong;
}
extern "C" {
    pub fn lldiv(__numer: ffi::ctypes::c_longlong, __denom: ffi::ctypes::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn strtoll(
        __n: *const ffi::ctypes::c_char,
        __end_PTR: *mut *mut ffi::ctypes::c_char,
        __base: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_longlong;
}
extern "C" {
    pub fn _strtoll_r(
        arg1: *mut _reent,
        __n: *const ffi::ctypes::c_char,
        __end_PTR: *mut *mut ffi::ctypes::c_char,
        __base: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __n: *const ffi::ctypes::c_char,
        __end_PTR: *mut *mut ffi::ctypes::c_char,
        __base: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_ulonglong;
}
extern "C" {
    pub fn _strtoull_r(
        arg1: *mut _reent,
        __n: *const ffi::ctypes::c_char,
        __end_PTR: *mut *mut ffi::ctypes::c_char,
        __base: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_ulonglong;
}
extern "C" {
    pub fn cfree(arg1: *mut ffi::ctypes::c_void);
}
extern "C" {
    pub fn unsetenv(__string: *const ffi::ctypes::c_char) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _unsetenv_r(
        arg1: *mut _reent,
        __string: *const ffi::ctypes::c_char,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn posix_memalign(
        arg1: *mut *mut ffi::ctypes::c_void,
        arg2: size_t,
        arg3: size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _dtoa_r(
        arg1: *mut _reent,
        arg2: f64,
        arg3: ffi::ctypes::c_int,
        arg4: ffi::ctypes::c_int,
        arg5: *mut ffi::ctypes::c_int,
        arg6: *mut ffi::ctypes::c_int,
        arg7: *mut *mut ffi::ctypes::c_char,
    ) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn _malloc_r(arg1: *mut _reent, arg2: size_t) -> *mut ffi::ctypes::c_void;
}
extern "C" {
    pub fn _calloc_r(arg1: *mut _reent, arg2: size_t, arg3: size_t) -> *mut ffi::ctypes::c_void;
}
extern "C" {
    pub fn _free_r(arg1: *mut _reent, arg2: *mut ffi::ctypes::c_void);
}
extern "C" {
    pub fn _realloc_r(
        arg1: *mut _reent,
        arg2: *mut ffi::ctypes::c_void,
        arg3: size_t,
    ) -> *mut ffi::ctypes::c_void;
}
extern "C" {
    pub fn _mstats_r(arg1: *mut _reent, arg2: *mut ffi::ctypes::c_char);
}
extern "C" {
    pub fn _system_r(arg1: *mut _reent, arg2: *const ffi::ctypes::c_char) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn __eprintf(
        arg1: *const ffi::ctypes::c_char,
        arg2: *const ffi::ctypes::c_char,
        arg3: ffi::ctypes::c_uint,
        arg4: *const ffi::ctypes::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}__bsd_qsort_r"]
    pub fn qsort_r(
        __base: *mut ffi::ctypes::c_void,
        __nmemb: size_t,
        __size: size_t,
        __thunk: *mut ffi::ctypes::c_void,
        _compar: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ffi::ctypes::c_void,
                arg2: *const ffi::ctypes::c_void,
                arg3: *const ffi::ctypes::c_void,
            ) -> ffi::ctypes::c_int,
        >,
    );
}
extern "C" {
    pub fn _strtold_r(
        arg1: *mut _reent,
        arg2: *const ffi::ctypes::c_char,
        arg3: *mut *mut ffi::ctypes::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtold(arg1: *const ffi::ctypes::c_char, arg2: *mut *mut ffi::ctypes::c_char) -> u128;
}
extern "C" {
    pub fn aligned_alloc(arg1: size_t, arg2: size_t) -> *mut ffi::ctypes::c_void;
}
extern "C" {
    pub fn at_quick_exit(
        arg1: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn quick_exit(arg1: ffi::ctypes::c_int);
}
pub type locale_t = *mut __locale_t;
extern "C" {
    pub fn memchr(
        arg1: *const ffi::ctypes::c_void,
        arg2: ffi::ctypes::c_int,
        arg3: ffi::ctypes::c_ulong,
    ) -> *mut ffi::ctypes::c_void;
}
extern "C" {
    pub fn memcmp(
        arg1: *const ffi::ctypes::c_void,
        arg2: *const ffi::ctypes::c_void,
        arg3: ffi::ctypes::c_ulong,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn memcpy(
        arg1: *mut ffi::ctypes::c_void,
        arg2: *const ffi::ctypes::c_void,
        arg3: ffi::ctypes::c_ulong,
    ) -> *mut ffi::ctypes::c_void;
}
extern "C" {
    pub fn memmove(
        arg1: *mut ffi::ctypes::c_void,
        arg2: *const ffi::ctypes::c_void,
        arg3: ffi::ctypes::c_ulong,
    ) -> *mut ffi::ctypes::c_void;
}
extern "C" {
    pub fn memset(
        arg1: *mut ffi::ctypes::c_void,
        arg2: ffi::ctypes::c_int,
        arg3: ffi::ctypes::c_ulong,
    ) -> *mut ffi::ctypes::c_void;
}
extern "C" {
    pub fn strcat(
        arg1: *mut ffi::ctypes::c_char,
        arg2: *const ffi::ctypes::c_char,
    ) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn strchr(
        arg1: *const ffi::ctypes::c_char,
        arg2: ffi::ctypes::c_int,
    ) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn strcmp(
        arg1: *const ffi::ctypes::c_char,
        arg2: *const ffi::ctypes::c_char,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn strcoll(
        arg1: *const ffi::ctypes::c_char,
        arg2: *const ffi::ctypes::c_char,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn strcpy(
        arg1: *mut ffi::ctypes::c_char,
        arg2: *const ffi::ctypes::c_char,
    ) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn strcspn(
        arg1: *const ffi::ctypes::c_char,
        arg2: *const ffi::ctypes::c_char,
    ) -> ffi::ctypes::c_ulong;
}
extern "C" {
    pub fn strerror(arg1: ffi::ctypes::c_int) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn strlen(arg1: *const ffi::ctypes::c_char) -> ffi::ctypes::c_ulong;
}
extern "C" {
    pub fn strncat(
        arg1: *mut ffi::ctypes::c_char,
        arg2: *const ffi::ctypes::c_char,
        arg3: ffi::ctypes::c_ulong,
    ) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn strncmp(
        arg1: *const ffi::ctypes::c_char,
        arg2: *const ffi::ctypes::c_char,
        arg3: ffi::ctypes::c_ulong,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn strncpy(
        arg1: *mut ffi::ctypes::c_char,
        arg2: *const ffi::ctypes::c_char,
        arg3: ffi::ctypes::c_ulong,
    ) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn strpbrk(
        arg1: *const ffi::ctypes::c_char,
        arg2: *const ffi::ctypes::c_char,
    ) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn strrchr(
        arg1: *const ffi::ctypes::c_char,
        arg2: ffi::ctypes::c_int,
    ) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn strspn(
        arg1: *const ffi::ctypes::c_char,
        arg2: *const ffi::ctypes::c_char,
    ) -> ffi::ctypes::c_ulong;
}
extern "C" {
    pub fn strstr(
        arg1: *const ffi::ctypes::c_char,
        arg2: *const ffi::ctypes::c_char,
    ) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn strtok(
        arg1: *mut ffi::ctypes::c_char,
        arg2: *const ffi::ctypes::c_char,
    ) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn strxfrm(
        arg1: *mut ffi::ctypes::c_char,
        arg2: *const ffi::ctypes::c_char,
        arg3: ffi::ctypes::c_ulong,
    ) -> ffi::ctypes::c_ulong;
}
extern "C" {
    pub fn strcoll_l(
        arg1: *const ffi::ctypes::c_char,
        arg2: *const ffi::ctypes::c_char,
        arg3: locale_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn strerror_l(arg1: ffi::ctypes::c_int, arg2: locale_t) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn strxfrm_l(
        arg1: *mut ffi::ctypes::c_char,
        arg2: *const ffi::ctypes::c_char,
        arg3: size_t,
        arg4: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn strtok_r(
        arg1: *mut ffi::ctypes::c_char,
        arg2: *const ffi::ctypes::c_char,
        arg3: *mut *mut ffi::ctypes::c_char,
    ) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn bcmp(
        arg1: *const ffi::ctypes::c_void,
        arg2: *const ffi::ctypes::c_void,
        arg3: ffi::ctypes::c_ulong,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn bcopy(arg1: *const ffi::ctypes::c_void, arg2: *mut ffi::ctypes::c_void, arg3: size_t);
}
extern "C" {
    pub fn bzero(arg1: *mut ffi::ctypes::c_void, arg2: ffi::ctypes::c_ulong);
}
extern "C" {
    pub fn explicit_bzero(arg1: *mut ffi::ctypes::c_void, arg2: size_t);
}
extern "C" {
    pub fn timingsafe_bcmp(
        arg1: *const ffi::ctypes::c_void,
        arg2: *const ffi::ctypes::c_void,
        arg3: size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn timingsafe_memcmp(
        arg1: *const ffi::ctypes::c_void,
        arg2: *const ffi::ctypes::c_void,
        arg3: size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn ffs(arg1: ffi::ctypes::c_int) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn index(
        arg1: *const ffi::ctypes::c_char,
        arg2: ffi::ctypes::c_int,
    ) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn memccpy(
        arg1: *mut ffi::ctypes::c_void,
        arg2: *const ffi::ctypes::c_void,
        arg3: ffi::ctypes::c_int,
        arg4: ffi::ctypes::c_ulong,
    ) -> *mut ffi::ctypes::c_void;
}
extern "C" {
    pub fn rindex(
        arg1: *const ffi::ctypes::c_char,
        arg2: ffi::ctypes::c_int,
    ) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn stpcpy(
        arg1: *mut ffi::ctypes::c_char,
        arg2: *const ffi::ctypes::c_char,
    ) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn stpncpy(
        arg1: *mut ffi::ctypes::c_char,
        arg2: *const ffi::ctypes::c_char,
        arg3: ffi::ctypes::c_ulong,
    ) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn strcasecmp(
        arg1: *const ffi::ctypes::c_char,
        arg2: *const ffi::ctypes::c_char,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn strdup(arg1: *const ffi::ctypes::c_char) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn _strdup_r(
        arg1: *mut _reent,
        arg2: *const ffi::ctypes::c_char,
    ) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn strndup(
        arg1: *const ffi::ctypes::c_char,
        arg2: ffi::ctypes::c_ulong,
    ) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn _strndup_r(
        arg1: *mut _reent,
        arg2: *const ffi::ctypes::c_char,
        arg3: size_t,
    ) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        arg1: ffi::ctypes::c_int,
        arg2: *mut ffi::ctypes::c_char,
        arg3: size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _strerror_r(
        arg1: *mut _reent,
        arg2: ffi::ctypes::c_int,
        arg3: ffi::ctypes::c_int,
        arg4: *mut ffi::ctypes::c_int,
    ) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn strlcat(
        arg1: *mut ffi::ctypes::c_char,
        arg2: *const ffi::ctypes::c_char,
        arg3: ffi::ctypes::c_ulong,
    ) -> ffi::ctypes::c_ulong;
}
extern "C" {
    pub fn strlcpy(
        arg1: *mut ffi::ctypes::c_char,
        arg2: *const ffi::ctypes::c_char,
        arg3: ffi::ctypes::c_ulong,
    ) -> ffi::ctypes::c_ulong;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const ffi::ctypes::c_char,
        arg2: *const ffi::ctypes::c_char,
        arg3: ffi::ctypes::c_ulong,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn strnlen(arg1: *const ffi::ctypes::c_char, arg2: size_t) -> size_t;
}
extern "C" {
    pub fn strsep(
        arg1: *mut *mut ffi::ctypes::c_char,
        arg2: *const ffi::ctypes::c_char,
    ) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn strlwr(arg1: *mut ffi::ctypes::c_char) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn strupr(arg1: *mut ffi::ctypes::c_char) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn strsignal(__signo: ffi::ctypes::c_int) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn _rtl_vsprintf(
        buf: *mut ffi::ctypes::c_char,
        size: size_t,
        fmt: *const ffi::ctypes::c_char,
        dp: *const ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _rtl_printf(fmt: *const ffi::ctypes::c_char, ...) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _rtl_sprintf(
        str_: *mut ffi::ctypes::c_char,
        fmt: *const ffi::ctypes::c_char,
        ...
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _rtl_snprintf(
        str_: *mut ffi::ctypes::c_char,
        size: size_t,
        fmt: *const ffi::ctypes::c_char,
        ...
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _rtl_vsnprintf(
        buf: *mut ffi::ctypes::c_char,
        size: size_t,
        fmt: *const ffi::ctypes::c_char,
        ap: *mut __va_list_tag,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn _rtl_sscanf(
        buf: *const ffi::ctypes::c_char,
        fmt: *const ffi::ctypes::c_char,
        ...
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn pvPortReAlloc(
        pv: *mut ffi::ctypes::c_void,
        xWantedSize: size_t,
    ) -> *mut ffi::ctypes::c_void;
}
pub type mbedtls_iso_c_forbids_empty_translation_units = ffi::ctypes::c_int;
extern "C" {
    pub static mut mbedtls_calloc: ::core::option::Option<
        unsafe extern "C" fn(n: size_t, size: size_t) -> *mut ffi::ctypes::c_void,
    >;
}
extern "C" {
    pub static mut mbedtls_free:
        ::core::option::Option<unsafe extern "C" fn(ptr: *mut ffi::ctypes::c_void)>;
}
extern "C" {
    pub fn mbedtls_platform_set_calloc_free(
        calloc_func: ::core::option::Option<
            unsafe extern "C" fn(arg1: size_t, arg2: size_t) -> *mut ffi::ctypes::c_void,
        >,
        free_func: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ffi::ctypes::c_void)>,
    ) -> ffi::ctypes::c_int;
}
pub type mbedtls_mpi_sint = i64;
pub type mbedtls_mpi_uint = u64;
pub type mbedtls_t_udbl = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_mpi {
    pub s: ffi::ctypes::c_int,
    pub n: size_t,
    pub p: *mut mbedtls_mpi_uint,
}
impl Default for mbedtls_mpi {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn mbedtls_mpi_init(X: *mut mbedtls_mpi);
}
extern "C" {
    pub fn mbedtls_mpi_free(X: *mut mbedtls_mpi);
}
extern "C" {
    pub fn mbedtls_mpi_grow(X: *mut mbedtls_mpi, nblimbs: size_t) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_mpi_shrink(X: *mut mbedtls_mpi, nblimbs: size_t) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_mpi_copy(X: *mut mbedtls_mpi, Y: *const mbedtls_mpi) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_mpi_swap(X: *mut mbedtls_mpi, Y: *mut mbedtls_mpi);
}
extern "C" {
    pub fn mbedtls_mpi_safe_cond_assign(
        X: *mut mbedtls_mpi,
        Y: *const mbedtls_mpi,
        assign: ffi::ctypes::c_uchar,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_mpi_safe_cond_swap(
        X: *mut mbedtls_mpi,
        Y: *mut mbedtls_mpi,
        assign: ffi::ctypes::c_uchar,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_mpi_lset(X: *mut mbedtls_mpi, z: mbedtls_mpi_sint) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_mpi_get_bit(X: *const mbedtls_mpi, pos: size_t) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_mpi_set_bit(
        X: *mut mbedtls_mpi,
        pos: size_t,
        val: ffi::ctypes::c_uchar,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_mpi_lsb(X: *const mbedtls_mpi) -> size_t;
}
extern "C" {
    pub fn mbedtls_mpi_bitlen(X: *const mbedtls_mpi) -> size_t;
}
extern "C" {
    pub fn mbedtls_mpi_size(X: *const mbedtls_mpi) -> size_t;
}
extern "C" {
    pub fn mbedtls_mpi_read_string(
        X: *mut mbedtls_mpi,
        radix: ffi::ctypes::c_int,
        s: *const ffi::ctypes::c_char,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_mpi_write_string(
        X: *const mbedtls_mpi,
        radix: ffi::ctypes::c_int,
        buf: *mut ffi::ctypes::c_char,
        buflen: size_t,
        olen: *mut size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_mpi_read_binary(
        X: *mut mbedtls_mpi,
        buf: *const ffi::ctypes::c_uchar,
        buflen: size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_mpi_write_binary(
        X: *const mbedtls_mpi,
        buf: *mut ffi::ctypes::c_uchar,
        buflen: size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_mpi_shift_l(X: *mut mbedtls_mpi, count: size_t) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_mpi_shift_r(X: *mut mbedtls_mpi, count: size_t) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_mpi_cmp_abs(X: *const mbedtls_mpi, Y: *const mbedtls_mpi) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_mpi_cmp_mpi(X: *const mbedtls_mpi, Y: *const mbedtls_mpi) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_mpi_cmp_int(X: *const mbedtls_mpi, z: mbedtls_mpi_sint) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_mpi_add_abs(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        B: *const mbedtls_mpi,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_mpi_sub_abs(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        B: *const mbedtls_mpi,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_mpi_add_mpi(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        B: *const mbedtls_mpi,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_mpi_sub_mpi(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        B: *const mbedtls_mpi,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_mpi_add_int(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        b: mbedtls_mpi_sint,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_mpi_sub_int(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        b: mbedtls_mpi_sint,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_mpi_mul_mpi(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        B: *const mbedtls_mpi,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_mpi_mul_int(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        b: mbedtls_mpi_uint,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_mpi_div_mpi(
        Q: *mut mbedtls_mpi,
        R: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        B: *const mbedtls_mpi,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_mpi_div_int(
        Q: *mut mbedtls_mpi,
        R: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        b: mbedtls_mpi_sint,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_mpi_mod_mpi(
        R: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        B: *const mbedtls_mpi,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_mpi_mod_int(
        r: *mut mbedtls_mpi_uint,
        A: *const mbedtls_mpi,
        b: mbedtls_mpi_sint,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_mpi_exp_mod(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        E: *const mbedtls_mpi,
        N: *const mbedtls_mpi,
        _RR: *mut mbedtls_mpi,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_mpi_fill_random(
        X: *mut mbedtls_mpi,
        size: size_t,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ffi::ctypes::c_void,
                arg2: *mut ffi::ctypes::c_uchar,
                arg3: size_t,
            ) -> ffi::ctypes::c_int,
        >,
        p_rng: *mut ffi::ctypes::c_void,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_mpi_gcd(
        G: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        B: *const mbedtls_mpi,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_mpi_inv_mod(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        N: *const mbedtls_mpi,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_mpi_is_prime(
        X: *const mbedtls_mpi,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ffi::ctypes::c_void,
                arg2: *mut ffi::ctypes::c_uchar,
                arg3: size_t,
            ) -> ffi::ctypes::c_int,
        >,
        p_rng: *mut ffi::ctypes::c_void,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_mpi_gen_prime(
        X: *mut mbedtls_mpi,
        nbits: size_t,
        dh_flag: ffi::ctypes::c_int,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ffi::ctypes::c_void,
                arg2: *mut ffi::ctypes::c_uchar,
                arg3: size_t,
            ) -> ffi::ctypes::c_int,
        >,
        p_rng: *mut ffi::ctypes::c_void,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_mpi_self_test(verbose: ffi::ctypes::c_int) -> ffi::ctypes::c_int;
}
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_NONE: mbedtls_ecp_group_id = 0;
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP192R1: mbedtls_ecp_group_id = 1;
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP224R1: mbedtls_ecp_group_id = 2;
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP256R1: mbedtls_ecp_group_id = 3;
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP384R1: mbedtls_ecp_group_id = 4;
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP521R1: mbedtls_ecp_group_id = 5;
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_BP256R1: mbedtls_ecp_group_id = 6;
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_BP384R1: mbedtls_ecp_group_id = 7;
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_BP512R1: mbedtls_ecp_group_id = 8;
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_CURVE25519: mbedtls_ecp_group_id = 9;
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP192K1: mbedtls_ecp_group_id = 10;
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP224K1: mbedtls_ecp_group_id = 11;
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP256K1: mbedtls_ecp_group_id = 12;
pub type mbedtls_ecp_group_id = ffi::ctypes::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ecp_curve_info {
    pub grp_id: mbedtls_ecp_group_id,
    pub tls_id: u16,
    pub bit_size: u16,
    pub name: *const ffi::ctypes::c_char,
}
impl Default for mbedtls_ecp_curve_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ecp_point {
    pub X: mbedtls_mpi,
    pub Y: mbedtls_mpi,
    pub Z: mbedtls_mpi,
}
impl Default for mbedtls_ecp_point {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ecp_group {
    pub id: mbedtls_ecp_group_id,
    pub P: mbedtls_mpi,
    pub A: mbedtls_mpi,
    pub B: mbedtls_mpi,
    pub G: mbedtls_ecp_point,
    pub N: mbedtls_mpi,
    pub pbits: size_t,
    pub nbits: size_t,
    pub h: ffi::ctypes::c_uint,
    pub modp:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut mbedtls_mpi) -> ffi::ctypes::c_int>,
    pub t_pre: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mbedtls_ecp_point,
            arg2: *mut ffi::ctypes::c_void,
        ) -> ffi::ctypes::c_int,
    >,
    pub t_post: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mbedtls_ecp_point,
            arg2: *mut ffi::ctypes::c_void,
        ) -> ffi::ctypes::c_int,
    >,
    pub t_data: *mut ffi::ctypes::c_void,
    pub T: *mut mbedtls_ecp_point,
    pub T_size: size_t,
}
impl Default for mbedtls_ecp_group {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ecp_keypair {
    pub grp: mbedtls_ecp_group,
    pub d: mbedtls_mpi,
    pub Q: mbedtls_ecp_point,
}
impl Default for mbedtls_ecp_keypair {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn mbedtls_ecp_curve_list() -> *const mbedtls_ecp_curve_info;
}
extern "C" {
    pub fn mbedtls_ecp_grp_id_list() -> *const mbedtls_ecp_group_id;
}
extern "C" {
    pub fn mbedtls_ecp_curve_info_from_grp_id(
        grp_id: mbedtls_ecp_group_id,
    ) -> *const mbedtls_ecp_curve_info;
}
extern "C" {
    pub fn mbedtls_ecp_curve_info_from_tls_id(tls_id: u16) -> *const mbedtls_ecp_curve_info;
}
extern "C" {
    pub fn mbedtls_ecp_curve_info_from_name(
        name: *const ffi::ctypes::c_char,
    ) -> *const mbedtls_ecp_curve_info;
}
extern "C" {
    pub fn mbedtls_ecp_point_init(pt: *mut mbedtls_ecp_point);
}
extern "C" {
    pub fn mbedtls_ecp_group_init(grp: *mut mbedtls_ecp_group);
}
extern "C" {
    pub fn mbedtls_ecp_keypair_init(key: *mut mbedtls_ecp_keypair);
}
extern "C" {
    pub fn mbedtls_ecp_point_free(pt: *mut mbedtls_ecp_point);
}
extern "C" {
    pub fn mbedtls_ecp_group_free(grp: *mut mbedtls_ecp_group);
}
extern "C" {
    pub fn mbedtls_ecp_keypair_free(key: *mut mbedtls_ecp_keypair);
}
extern "C" {
    pub fn mbedtls_ecp_copy(
        P: *mut mbedtls_ecp_point,
        Q: *const mbedtls_ecp_point,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ecp_group_copy(
        dst: *mut mbedtls_ecp_group,
        src: *const mbedtls_ecp_group,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ecp_set_zero(pt: *mut mbedtls_ecp_point) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ecp_is_zero(pt: *mut mbedtls_ecp_point) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ecp_point_cmp(
        P: *const mbedtls_ecp_point,
        Q: *const mbedtls_ecp_point,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ecp_point_read_string(
        P: *mut mbedtls_ecp_point,
        radix: ffi::ctypes::c_int,
        x: *const ffi::ctypes::c_char,
        y: *const ffi::ctypes::c_char,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ecp_point_write_binary(
        grp: *const mbedtls_ecp_group,
        P: *const mbedtls_ecp_point,
        format: ffi::ctypes::c_int,
        olen: *mut size_t,
        buf: *mut ffi::ctypes::c_uchar,
        buflen: size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ecp_point_read_binary(
        grp: *const mbedtls_ecp_group,
        P: *mut mbedtls_ecp_point,
        buf: *const ffi::ctypes::c_uchar,
        ilen: size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ecp_tls_read_point(
        grp: *const mbedtls_ecp_group,
        pt: *mut mbedtls_ecp_point,
        buf: *mut *const ffi::ctypes::c_uchar,
        len: size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ecp_tls_write_point(
        grp: *const mbedtls_ecp_group,
        pt: *const mbedtls_ecp_point,
        format: ffi::ctypes::c_int,
        olen: *mut size_t,
        buf: *mut ffi::ctypes::c_uchar,
        blen: size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ecp_group_load(
        grp: *mut mbedtls_ecp_group,
        index: mbedtls_ecp_group_id,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ecp_tls_read_group(
        grp: *mut mbedtls_ecp_group,
        buf: *mut *const ffi::ctypes::c_uchar,
        len: size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ecp_tls_write_group(
        grp: *const mbedtls_ecp_group,
        olen: *mut size_t,
        buf: *mut ffi::ctypes::c_uchar,
        blen: size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ecp_mul(
        grp: *mut mbedtls_ecp_group,
        R: *mut mbedtls_ecp_point,
        m: *const mbedtls_mpi,
        P: *const mbedtls_ecp_point,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ffi::ctypes::c_void,
                arg2: *mut ffi::ctypes::c_uchar,
                arg3: size_t,
            ) -> ffi::ctypes::c_int,
        >,
        p_rng: *mut ffi::ctypes::c_void,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ecp_muladd(
        grp: *mut mbedtls_ecp_group,
        R: *mut mbedtls_ecp_point,
        m: *const mbedtls_mpi,
        P: *const mbedtls_ecp_point,
        n: *const mbedtls_mpi,
        Q: *const mbedtls_ecp_point,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ecp_check_pubkey(
        grp: *const mbedtls_ecp_group,
        pt: *const mbedtls_ecp_point,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ecp_check_privkey(
        grp: *const mbedtls_ecp_group,
        d: *const mbedtls_mpi,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ecp_gen_keypair_base(
        grp: *mut mbedtls_ecp_group,
        G: *const mbedtls_ecp_point,
        d: *mut mbedtls_mpi,
        Q: *mut mbedtls_ecp_point,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ffi::ctypes::c_void,
                arg2: *mut ffi::ctypes::c_uchar,
                arg3: size_t,
            ) -> ffi::ctypes::c_int,
        >,
        p_rng: *mut ffi::ctypes::c_void,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ecp_gen_keypair(
        grp: *mut mbedtls_ecp_group,
        d: *mut mbedtls_mpi,
        Q: *mut mbedtls_ecp_point,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ffi::ctypes::c_void,
                arg2: *mut ffi::ctypes::c_uchar,
                arg3: size_t,
            ) -> ffi::ctypes::c_int,
        >,
        p_rng: *mut ffi::ctypes::c_void,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ecp_gen_key(
        grp_id: mbedtls_ecp_group_id,
        key: *mut mbedtls_ecp_keypair,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ffi::ctypes::c_void,
                arg2: *mut ffi::ctypes::c_uchar,
                arg3: size_t,
            ) -> ffi::ctypes::c_int,
        >,
        p_rng: *mut ffi::ctypes::c_void,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ecp_check_pub_priv(
        pub_: *const mbedtls_ecp_keypair,
        prv: *const mbedtls_ecp_keypair,
    ) -> ffi::ctypes::c_int;
}
pub const mbedtls_md_type_t_MBEDTLS_MD_NONE: mbedtls_md_type_t = 0;
pub const mbedtls_md_type_t_MBEDTLS_MD_MD2: mbedtls_md_type_t = 1;
pub const mbedtls_md_type_t_MBEDTLS_MD_MD4: mbedtls_md_type_t = 2;
pub const mbedtls_md_type_t_MBEDTLS_MD_MD5: mbedtls_md_type_t = 3;
pub const mbedtls_md_type_t_MBEDTLS_MD_SHA1: mbedtls_md_type_t = 4;
pub const mbedtls_md_type_t_MBEDTLS_MD_SHA224: mbedtls_md_type_t = 5;
pub const mbedtls_md_type_t_MBEDTLS_MD_SHA256: mbedtls_md_type_t = 6;
pub const mbedtls_md_type_t_MBEDTLS_MD_SHA384: mbedtls_md_type_t = 7;
pub const mbedtls_md_type_t_MBEDTLS_MD_SHA512: mbedtls_md_type_t = 8;
pub const mbedtls_md_type_t_MBEDTLS_MD_RIPEMD160: mbedtls_md_type_t = 9;
pub type mbedtls_md_type_t = ffi::ctypes::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_md_info_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_md_context_t {
    pub md_info: *const mbedtls_md_info_t,
    pub md_ctx: *mut ffi::ctypes::c_void,
    pub hmac_ctx: *mut ffi::ctypes::c_void,
}
impl Default for mbedtls_md_context_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn mbedtls_md_list() -> *const ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_md_info_from_string(
        md_name: *const ffi::ctypes::c_char,
    ) -> *const mbedtls_md_info_t;
}
extern "C" {
    pub fn mbedtls_md_info_from_type(md_type: mbedtls_md_type_t) -> *const mbedtls_md_info_t;
}
extern "C" {
    pub fn mbedtls_md_init(ctx: *mut mbedtls_md_context_t);
}
extern "C" {
    pub fn mbedtls_md_free(ctx: *mut mbedtls_md_context_t);
}
extern "C" {
    pub fn mbedtls_md_init_ctx(
        ctx: *mut mbedtls_md_context_t,
        md_info: *const mbedtls_md_info_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_md_setup(
        ctx: *mut mbedtls_md_context_t,
        md_info: *const mbedtls_md_info_t,
        hmac: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_md_clone(
        dst: *mut mbedtls_md_context_t,
        src: *const mbedtls_md_context_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_md_get_size(md_info: *const mbedtls_md_info_t) -> ffi::ctypes::c_uchar;
}
extern "C" {
    pub fn mbedtls_md_get_type(md_info: *const mbedtls_md_info_t) -> mbedtls_md_type_t;
}
extern "C" {
    pub fn mbedtls_md_get_name(md_info: *const mbedtls_md_info_t) -> *const ffi::ctypes::c_char;
}
extern "C" {
    pub fn mbedtls_md_starts(ctx: *mut mbedtls_md_context_t) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_md_update(
        ctx: *mut mbedtls_md_context_t,
        input: *const ffi::ctypes::c_uchar,
        ilen: size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_md_finish(
        ctx: *mut mbedtls_md_context_t,
        output: *mut ffi::ctypes::c_uchar,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_md(
        md_info: *const mbedtls_md_info_t,
        input: *const ffi::ctypes::c_uchar,
        ilen: size_t,
        output: *mut ffi::ctypes::c_uchar,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_md_hmac_starts(
        ctx: *mut mbedtls_md_context_t,
        key: *const ffi::ctypes::c_uchar,
        keylen: size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_md_hmac_update(
        ctx: *mut mbedtls_md_context_t,
        input: *const ffi::ctypes::c_uchar,
        ilen: size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_md_hmac_finish(
        ctx: *mut mbedtls_md_context_t,
        output: *mut ffi::ctypes::c_uchar,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_md_hmac_reset(ctx: *mut mbedtls_md_context_t) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_md_hmac(
        md_info: *const mbedtls_md_info_t,
        key: *const ffi::ctypes::c_uchar,
        keylen: size_t,
        input: *const ffi::ctypes::c_uchar,
        ilen: size_t,
        output: *mut ffi::ctypes::c_uchar,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_md_process(
        ctx: *mut mbedtls_md_context_t,
        data: *const ffi::ctypes::c_uchar,
    ) -> ffi::ctypes::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_rsa_context {
    pub ver: ffi::ctypes::c_int,
    pub len: size_t,
    pub N: mbedtls_mpi,
    pub E: mbedtls_mpi,
    pub D: mbedtls_mpi,
    pub P: mbedtls_mpi,
    pub Q: mbedtls_mpi,
    pub DP: mbedtls_mpi,
    pub DQ: mbedtls_mpi,
    pub QP: mbedtls_mpi,
    pub RN: mbedtls_mpi,
    pub RP: mbedtls_mpi,
    pub RQ: mbedtls_mpi,
    pub Vi: mbedtls_mpi,
    pub Vf: mbedtls_mpi,
    pub padding: ffi::ctypes::c_int,
    pub hash_id: ffi::ctypes::c_int,
}
impl Default for mbedtls_rsa_context {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn mbedtls_rsa_init(
        ctx: *mut mbedtls_rsa_context,
        padding: ffi::ctypes::c_int,
        hash_id: ffi::ctypes::c_int,
    );
}
extern "C" {
    pub fn mbedtls_rsa_set_padding(
        ctx: *mut mbedtls_rsa_context,
        padding: ffi::ctypes::c_int,
        hash_id: ffi::ctypes::c_int,
    );
}
extern "C" {
    pub fn mbedtls_rsa_gen_key(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ffi::ctypes::c_void,
                arg2: *mut ffi::ctypes::c_uchar,
                arg3: size_t,
            ) -> ffi::ctypes::c_int,
        >,
        p_rng: *mut ffi::ctypes::c_void,
        nbits: ffi::ctypes::c_uint,
        exponent: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_rsa_check_pubkey(ctx: *const mbedtls_rsa_context) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_rsa_check_privkey(ctx: *const mbedtls_rsa_context) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_rsa_check_pub_priv(
        pub_: *const mbedtls_rsa_context,
        prv: *const mbedtls_rsa_context,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_rsa_public(
        ctx: *mut mbedtls_rsa_context,
        input: *const ffi::ctypes::c_uchar,
        output: *mut ffi::ctypes::c_uchar,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_rsa_private(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ffi::ctypes::c_void,
                arg2: *mut ffi::ctypes::c_uchar,
                arg3: size_t,
            ) -> ffi::ctypes::c_int,
        >,
        p_rng: *mut ffi::ctypes::c_void,
        input: *const ffi::ctypes::c_uchar,
        output: *mut ffi::ctypes::c_uchar,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_rsa_pkcs1_encrypt(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ffi::ctypes::c_void,
                arg2: *mut ffi::ctypes::c_uchar,
                arg3: size_t,
            ) -> ffi::ctypes::c_int,
        >,
        p_rng: *mut ffi::ctypes::c_void,
        mode: ffi::ctypes::c_int,
        ilen: size_t,
        input: *const ffi::ctypes::c_uchar,
        output: *mut ffi::ctypes::c_uchar,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_rsa_rsaes_pkcs1_v15_encrypt(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ffi::ctypes::c_void,
                arg2: *mut ffi::ctypes::c_uchar,
                arg3: size_t,
            ) -> ffi::ctypes::c_int,
        >,
        p_rng: *mut ffi::ctypes::c_void,
        mode: ffi::ctypes::c_int,
        ilen: size_t,
        input: *const ffi::ctypes::c_uchar,
        output: *mut ffi::ctypes::c_uchar,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_rsa_rsaes_oaep_encrypt(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ffi::ctypes::c_void,
                arg2: *mut ffi::ctypes::c_uchar,
                arg3: size_t,
            ) -> ffi::ctypes::c_int,
        >,
        p_rng: *mut ffi::ctypes::c_void,
        mode: ffi::ctypes::c_int,
        label: *const ffi::ctypes::c_uchar,
        label_len: size_t,
        ilen: size_t,
        input: *const ffi::ctypes::c_uchar,
        output: *mut ffi::ctypes::c_uchar,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_rsa_pkcs1_decrypt(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ffi::ctypes::c_void,
                arg2: *mut ffi::ctypes::c_uchar,
                arg3: size_t,
            ) -> ffi::ctypes::c_int,
        >,
        p_rng: *mut ffi::ctypes::c_void,
        mode: ffi::ctypes::c_int,
        olen: *mut size_t,
        input: *const ffi::ctypes::c_uchar,
        output: *mut ffi::ctypes::c_uchar,
        output_max_len: size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_rsa_rsaes_pkcs1_v15_decrypt(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ffi::ctypes::c_void,
                arg2: *mut ffi::ctypes::c_uchar,
                arg3: size_t,
            ) -> ffi::ctypes::c_int,
        >,
        p_rng: *mut ffi::ctypes::c_void,
        mode: ffi::ctypes::c_int,
        olen: *mut size_t,
        input: *const ffi::ctypes::c_uchar,
        output: *mut ffi::ctypes::c_uchar,
        output_max_len: size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_rsa_rsaes_oaep_decrypt(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ffi::ctypes::c_void,
                arg2: *mut ffi::ctypes::c_uchar,
                arg3: size_t,
            ) -> ffi::ctypes::c_int,
        >,
        p_rng: *mut ffi::ctypes::c_void,
        mode: ffi::ctypes::c_int,
        label: *const ffi::ctypes::c_uchar,
        label_len: size_t,
        olen: *mut size_t,
        input: *const ffi::ctypes::c_uchar,
        output: *mut ffi::ctypes::c_uchar,
        output_max_len: size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_rsa_pkcs1_sign(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ffi::ctypes::c_void,
                arg2: *mut ffi::ctypes::c_uchar,
                arg3: size_t,
            ) -> ffi::ctypes::c_int,
        >,
        p_rng: *mut ffi::ctypes::c_void,
        mode: ffi::ctypes::c_int,
        md_alg: mbedtls_md_type_t,
        hashlen: ffi::ctypes::c_uint,
        hash: *const ffi::ctypes::c_uchar,
        sig: *mut ffi::ctypes::c_uchar,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_rsa_rsassa_pkcs1_v15_sign(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ffi::ctypes::c_void,
                arg2: *mut ffi::ctypes::c_uchar,
                arg3: size_t,
            ) -> ffi::ctypes::c_int,
        >,
        p_rng: *mut ffi::ctypes::c_void,
        mode: ffi::ctypes::c_int,
        md_alg: mbedtls_md_type_t,
        hashlen: ffi::ctypes::c_uint,
        hash: *const ffi::ctypes::c_uchar,
        sig: *mut ffi::ctypes::c_uchar,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_rsa_rsassa_pss_sign(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ffi::ctypes::c_void,
                arg2: *mut ffi::ctypes::c_uchar,
                arg3: size_t,
            ) -> ffi::ctypes::c_int,
        >,
        p_rng: *mut ffi::ctypes::c_void,
        mode: ffi::ctypes::c_int,
        md_alg: mbedtls_md_type_t,
        hashlen: ffi::ctypes::c_uint,
        hash: *const ffi::ctypes::c_uchar,
        sig: *mut ffi::ctypes::c_uchar,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_rsa_pkcs1_verify(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ffi::ctypes::c_void,
                arg2: *mut ffi::ctypes::c_uchar,
                arg3: size_t,
            ) -> ffi::ctypes::c_int,
        >,
        p_rng: *mut ffi::ctypes::c_void,
        mode: ffi::ctypes::c_int,
        md_alg: mbedtls_md_type_t,
        hashlen: ffi::ctypes::c_uint,
        hash: *const ffi::ctypes::c_uchar,
        sig: *const ffi::ctypes::c_uchar,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_rsa_rsassa_pkcs1_v15_verify(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ffi::ctypes::c_void,
                arg2: *mut ffi::ctypes::c_uchar,
                arg3: size_t,
            ) -> ffi::ctypes::c_int,
        >,
        p_rng: *mut ffi::ctypes::c_void,
        mode: ffi::ctypes::c_int,
        md_alg: mbedtls_md_type_t,
        hashlen: ffi::ctypes::c_uint,
        hash: *const ffi::ctypes::c_uchar,
        sig: *const ffi::ctypes::c_uchar,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_rsa_rsassa_pss_verify(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ffi::ctypes::c_void,
                arg2: *mut ffi::ctypes::c_uchar,
                arg3: size_t,
            ) -> ffi::ctypes::c_int,
        >,
        p_rng: *mut ffi::ctypes::c_void,
        mode: ffi::ctypes::c_int,
        md_alg: mbedtls_md_type_t,
        hashlen: ffi::ctypes::c_uint,
        hash: *const ffi::ctypes::c_uchar,
        sig: *const ffi::ctypes::c_uchar,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_rsa_rsassa_pss_verify_ext(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ffi::ctypes::c_void,
                arg2: *mut ffi::ctypes::c_uchar,
                arg3: size_t,
            ) -> ffi::ctypes::c_int,
        >,
        p_rng: *mut ffi::ctypes::c_void,
        mode: ffi::ctypes::c_int,
        md_alg: mbedtls_md_type_t,
        hashlen: ffi::ctypes::c_uint,
        hash: *const ffi::ctypes::c_uchar,
        mgf1_hash_id: mbedtls_md_type_t,
        expected_salt_len: ffi::ctypes::c_int,
        sig: *const ffi::ctypes::c_uchar,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_rsa_copy(
        dst: *mut mbedtls_rsa_context,
        src: *const mbedtls_rsa_context,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_rsa_free(ctx: *mut mbedtls_rsa_context);
}
extern "C" {
    pub fn mbedtls_rsa_self_test(verbose: ffi::ctypes::c_int) -> ffi::ctypes::c_int;
}
pub type mbedtls_ecdsa_context = mbedtls_ecp_keypair;
extern "C" {
    pub fn mbedtls_ecdsa_sign(
        grp: *mut mbedtls_ecp_group,
        r: *mut mbedtls_mpi,
        s: *mut mbedtls_mpi,
        d: *const mbedtls_mpi,
        buf: *const ffi::ctypes::c_uchar,
        blen: size_t,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ffi::ctypes::c_void,
                arg2: *mut ffi::ctypes::c_uchar,
                arg3: size_t,
            ) -> ffi::ctypes::c_int,
        >,
        p_rng: *mut ffi::ctypes::c_void,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ecdsa_verify(
        grp: *mut mbedtls_ecp_group,
        buf: *const ffi::ctypes::c_uchar,
        blen: size_t,
        Q: *const mbedtls_ecp_point,
        r: *const mbedtls_mpi,
        s: *const mbedtls_mpi,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ecdsa_write_signature(
        ctx: *mut mbedtls_ecdsa_context,
        md_alg: mbedtls_md_type_t,
        hash: *const ffi::ctypes::c_uchar,
        hlen: size_t,
        sig: *mut ffi::ctypes::c_uchar,
        slen: *mut size_t,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ffi::ctypes::c_void,
                arg2: *mut ffi::ctypes::c_uchar,
                arg3: size_t,
            ) -> ffi::ctypes::c_int,
        >,
        p_rng: *mut ffi::ctypes::c_void,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ecdsa_read_signature(
        ctx: *mut mbedtls_ecdsa_context,
        hash: *const ffi::ctypes::c_uchar,
        hlen: size_t,
        sig: *const ffi::ctypes::c_uchar,
        slen: size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ecdsa_genkey(
        ctx: *mut mbedtls_ecdsa_context,
        gid: mbedtls_ecp_group_id,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ffi::ctypes::c_void,
                arg2: *mut ffi::ctypes::c_uchar,
                arg3: size_t,
            ) -> ffi::ctypes::c_int,
        >,
        p_rng: *mut ffi::ctypes::c_void,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ecdsa_from_keypair(
        ctx: *mut mbedtls_ecdsa_context,
        key: *const mbedtls_ecp_keypair,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ecdsa_init(ctx: *mut mbedtls_ecdsa_context);
}
extern "C" {
    pub fn mbedtls_ecdsa_free(ctx: *mut mbedtls_ecdsa_context);
}
pub const mbedtls_pk_type_t_MBEDTLS_PK_NONE: mbedtls_pk_type_t = 0;
pub const mbedtls_pk_type_t_MBEDTLS_PK_RSA: mbedtls_pk_type_t = 1;
pub const mbedtls_pk_type_t_MBEDTLS_PK_ECKEY: mbedtls_pk_type_t = 2;
pub const mbedtls_pk_type_t_MBEDTLS_PK_ECKEY_DH: mbedtls_pk_type_t = 3;
pub const mbedtls_pk_type_t_MBEDTLS_PK_ECDSA: mbedtls_pk_type_t = 4;
pub const mbedtls_pk_type_t_MBEDTLS_PK_RSA_ALT: mbedtls_pk_type_t = 5;
pub const mbedtls_pk_type_t_MBEDTLS_PK_RSASSA_PSS: mbedtls_pk_type_t = 6;
pub type mbedtls_pk_type_t = ffi::ctypes::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_pk_rsassa_pss_options {
    pub mgf1_hash_id: mbedtls_md_type_t,
    pub expected_salt_len: ffi::ctypes::c_int,
}
impl Default for mbedtls_pk_rsassa_pss_options {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const mbedtls_pk_debug_type_MBEDTLS_PK_DEBUG_NONE: mbedtls_pk_debug_type = 0;
pub const mbedtls_pk_debug_type_MBEDTLS_PK_DEBUG_MPI: mbedtls_pk_debug_type = 1;
pub const mbedtls_pk_debug_type_MBEDTLS_PK_DEBUG_ECP: mbedtls_pk_debug_type = 2;
pub type mbedtls_pk_debug_type = ffi::ctypes::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_pk_debug_item {
    pub type_: mbedtls_pk_debug_type,
    pub name: *const ffi::ctypes::c_char,
    pub value: *mut ffi::ctypes::c_void,
}
impl Default for mbedtls_pk_debug_item {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_pk_info_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_pk_context {
    pub pk_info: *const mbedtls_pk_info_t,
    pub pk_ctx: *mut ffi::ctypes::c_void,
}
impl Default for mbedtls_pk_context {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type mbedtls_pk_rsa_alt_decrypt_func = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ffi::ctypes::c_void,
        mode: ffi::ctypes::c_int,
        olen: *mut size_t,
        input: *const ffi::ctypes::c_uchar,
        output: *mut ffi::ctypes::c_uchar,
        output_max_len: size_t,
    ) -> ffi::ctypes::c_int,
>;
pub type mbedtls_pk_rsa_alt_sign_func = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ffi::ctypes::c_void,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ffi::ctypes::c_void,
                arg2: *mut ffi::ctypes::c_uchar,
                arg3: size_t,
            ) -> ffi::ctypes::c_int,
        >,
        p_rng: *mut ffi::ctypes::c_void,
        mode: ffi::ctypes::c_int,
        md_alg: mbedtls_md_type_t,
        hashlen: ffi::ctypes::c_uint,
        hash: *const ffi::ctypes::c_uchar,
        sig: *mut ffi::ctypes::c_uchar,
    ) -> ffi::ctypes::c_int,
>;
pub type mbedtls_pk_rsa_alt_key_len_func =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut ffi::ctypes::c_void) -> size_t>;
extern "C" {
    pub fn mbedtls_pk_info_from_type(pk_type: mbedtls_pk_type_t) -> *const mbedtls_pk_info_t;
}
extern "C" {
    pub fn mbedtls_pk_init(ctx: *mut mbedtls_pk_context);
}
extern "C" {
    pub fn mbedtls_pk_free(ctx: *mut mbedtls_pk_context);
}
extern "C" {
    pub fn mbedtls_pk_setup(
        ctx: *mut mbedtls_pk_context,
        info: *const mbedtls_pk_info_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_pk_setup_rsa_alt(
        ctx: *mut mbedtls_pk_context,
        key: *mut ffi::ctypes::c_void,
        decrypt_func: mbedtls_pk_rsa_alt_decrypt_func,
        sign_func: mbedtls_pk_rsa_alt_sign_func,
        key_len_func: mbedtls_pk_rsa_alt_key_len_func,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_pk_get_bitlen(ctx: *const mbedtls_pk_context) -> size_t;
}
extern "C" {
    pub fn mbedtls_pk_can_do(
        ctx: *const mbedtls_pk_context,
        type_: mbedtls_pk_type_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_pk_verify(
        ctx: *mut mbedtls_pk_context,
        md_alg: mbedtls_md_type_t,
        hash: *const ffi::ctypes::c_uchar,
        hash_len: size_t,
        sig: *const ffi::ctypes::c_uchar,
        sig_len: size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_pk_verify_ext(
        type_: mbedtls_pk_type_t,
        options: *const ffi::ctypes::c_void,
        ctx: *mut mbedtls_pk_context,
        md_alg: mbedtls_md_type_t,
        hash: *const ffi::ctypes::c_uchar,
        hash_len: size_t,
        sig: *const ffi::ctypes::c_uchar,
        sig_len: size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_pk_sign(
        ctx: *mut mbedtls_pk_context,
        md_alg: mbedtls_md_type_t,
        hash: *const ffi::ctypes::c_uchar,
        hash_len: size_t,
        sig: *mut ffi::ctypes::c_uchar,
        sig_len: *mut size_t,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ffi::ctypes::c_void,
                arg2: *mut ffi::ctypes::c_uchar,
                arg3: size_t,
            ) -> ffi::ctypes::c_int,
        >,
        p_rng: *mut ffi::ctypes::c_void,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_pk_decrypt(
        ctx: *mut mbedtls_pk_context,
        input: *const ffi::ctypes::c_uchar,
        ilen: size_t,
        output: *mut ffi::ctypes::c_uchar,
        olen: *mut size_t,
        osize: size_t,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ffi::ctypes::c_void,
                arg2: *mut ffi::ctypes::c_uchar,
                arg3: size_t,
            ) -> ffi::ctypes::c_int,
        >,
        p_rng: *mut ffi::ctypes::c_void,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_pk_encrypt(
        ctx: *mut mbedtls_pk_context,
        input: *const ffi::ctypes::c_uchar,
        ilen: size_t,
        output: *mut ffi::ctypes::c_uchar,
        olen: *mut size_t,
        osize: size_t,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ffi::ctypes::c_void,
                arg2: *mut ffi::ctypes::c_uchar,
                arg3: size_t,
            ) -> ffi::ctypes::c_int,
        >,
        p_rng: *mut ffi::ctypes::c_void,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_pk_check_pair(
        pub_: *const mbedtls_pk_context,
        prv: *const mbedtls_pk_context,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_pk_debug(
        ctx: *const mbedtls_pk_context,
        items: *mut mbedtls_pk_debug_item,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_pk_get_name(ctx: *const mbedtls_pk_context) -> *const ffi::ctypes::c_char;
}
extern "C" {
    pub fn mbedtls_pk_get_type(ctx: *const mbedtls_pk_context) -> mbedtls_pk_type_t;
}
extern "C" {
    pub fn mbedtls_pk_parse_key(
        ctx: *mut mbedtls_pk_context,
        key: *const ffi::ctypes::c_uchar,
        keylen: size_t,
        pwd: *const ffi::ctypes::c_uchar,
        pwdlen: size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_pk_parse_public_key(
        ctx: *mut mbedtls_pk_context,
        key: *const ffi::ctypes::c_uchar,
        keylen: size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_pk_parse_subpubkey(
        p: *mut *mut ffi::ctypes::c_uchar,
        end: *const ffi::ctypes::c_uchar,
        pk: *mut mbedtls_pk_context,
    ) -> ffi::ctypes::c_int;
}
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_NONE: mbedtls_cipher_id_t = 0;
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_NULL: mbedtls_cipher_id_t = 1;
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_AES: mbedtls_cipher_id_t = 2;
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_DES: mbedtls_cipher_id_t = 3;
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_3DES: mbedtls_cipher_id_t = 4;
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_CAMELLIA: mbedtls_cipher_id_t = 5;
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_BLOWFISH: mbedtls_cipher_id_t = 6;
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_ARC4: mbedtls_cipher_id_t = 7;
pub type mbedtls_cipher_id_t = ffi::ctypes::c_uint;
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_NONE: mbedtls_cipher_type_t = 0;
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_NULL: mbedtls_cipher_type_t = 1;
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_ECB: mbedtls_cipher_type_t = 2;
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_ECB: mbedtls_cipher_type_t = 3;
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_ECB: mbedtls_cipher_type_t = 4;
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_CBC: mbedtls_cipher_type_t = 5;
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_CBC: mbedtls_cipher_type_t = 6;
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_CBC: mbedtls_cipher_type_t = 7;
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_CFB128: mbedtls_cipher_type_t = 8;
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_CFB128: mbedtls_cipher_type_t = 9;
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_CFB128: mbedtls_cipher_type_t = 10;
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_CTR: mbedtls_cipher_type_t = 11;
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_CTR: mbedtls_cipher_type_t = 12;
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_CTR: mbedtls_cipher_type_t = 13;
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_GCM: mbedtls_cipher_type_t = 14;
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_GCM: mbedtls_cipher_type_t = 15;
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_GCM: mbedtls_cipher_type_t = 16;
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_128_ECB: mbedtls_cipher_type_t = 17;
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_192_ECB: mbedtls_cipher_type_t = 18;
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_256_ECB: mbedtls_cipher_type_t = 19;
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_128_CBC: mbedtls_cipher_type_t = 20;
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_192_CBC: mbedtls_cipher_type_t = 21;
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_256_CBC: mbedtls_cipher_type_t = 22;
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_128_CFB128: mbedtls_cipher_type_t = 23;
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_192_CFB128: mbedtls_cipher_type_t = 24;
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_256_CFB128: mbedtls_cipher_type_t = 25;
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_128_CTR: mbedtls_cipher_type_t = 26;
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_192_CTR: mbedtls_cipher_type_t = 27;
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_256_CTR: mbedtls_cipher_type_t = 28;
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_128_GCM: mbedtls_cipher_type_t = 29;
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_192_GCM: mbedtls_cipher_type_t = 30;
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_256_GCM: mbedtls_cipher_type_t = 31;
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_DES_ECB: mbedtls_cipher_type_t = 32;
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_DES_CBC: mbedtls_cipher_type_t = 33;
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_DES_EDE_ECB: mbedtls_cipher_type_t = 34;
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_DES_EDE_CBC: mbedtls_cipher_type_t = 35;
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_DES_EDE3_ECB: mbedtls_cipher_type_t = 36;
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_DES_EDE3_CBC: mbedtls_cipher_type_t = 37;
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_BLOWFISH_ECB: mbedtls_cipher_type_t = 38;
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_BLOWFISH_CBC: mbedtls_cipher_type_t = 39;
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_BLOWFISH_CFB64: mbedtls_cipher_type_t = 40;
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_BLOWFISH_CTR: mbedtls_cipher_type_t = 41;
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARC4_128: mbedtls_cipher_type_t = 42;
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_CCM: mbedtls_cipher_type_t = 43;
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_CCM: mbedtls_cipher_type_t = 44;
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_CCM: mbedtls_cipher_type_t = 45;
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_128_CCM: mbedtls_cipher_type_t = 46;
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_192_CCM: mbedtls_cipher_type_t = 47;
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_256_CCM: mbedtls_cipher_type_t = 48;
pub type mbedtls_cipher_type_t = ffi::ctypes::c_uint;
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_NONE: mbedtls_cipher_mode_t = 0;
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_ECB: mbedtls_cipher_mode_t = 1;
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_CBC: mbedtls_cipher_mode_t = 2;
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_CFB: mbedtls_cipher_mode_t = 3;
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_OFB: mbedtls_cipher_mode_t = 4;
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_CTR: mbedtls_cipher_mode_t = 5;
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_GCM: mbedtls_cipher_mode_t = 6;
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_STREAM: mbedtls_cipher_mode_t = 7;
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_CCM: mbedtls_cipher_mode_t = 8;
pub type mbedtls_cipher_mode_t = ffi::ctypes::c_uint;
pub const mbedtls_cipher_padding_t_MBEDTLS_PADDING_PKCS7: mbedtls_cipher_padding_t = 0;
pub const mbedtls_cipher_padding_t_MBEDTLS_PADDING_ONE_AND_ZEROS: mbedtls_cipher_padding_t = 1;
pub const mbedtls_cipher_padding_t_MBEDTLS_PADDING_ZEROS_AND_LEN: mbedtls_cipher_padding_t = 2;
pub const mbedtls_cipher_padding_t_MBEDTLS_PADDING_ZEROS: mbedtls_cipher_padding_t = 3;
pub const mbedtls_cipher_padding_t_MBEDTLS_PADDING_NONE: mbedtls_cipher_padding_t = 4;
pub type mbedtls_cipher_padding_t = ffi::ctypes::c_uint;
pub const mbedtls_operation_t_MBEDTLS_OPERATION_NONE: mbedtls_operation_t = -1;
pub const mbedtls_operation_t_MBEDTLS_DECRYPT: mbedtls_operation_t = 0;
pub const mbedtls_operation_t_MBEDTLS_ENCRYPT: mbedtls_operation_t = 1;
pub type mbedtls_operation_t = ffi::ctypes::c_int;
pub const MBEDTLS_KEY_LENGTH_NONE: ffi::ctypes::c_uint = 0;
pub const MBEDTLS_KEY_LENGTH_DES: ffi::ctypes::c_uint = 64;
pub const MBEDTLS_KEY_LENGTH_DES_EDE: ffi::ctypes::c_uint = 128;
pub const MBEDTLS_KEY_LENGTH_DES_EDE3: ffi::ctypes::c_uint = 192;
pub type _bindgen_ty_1 = ffi::ctypes::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_cipher_base_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_cmac_context_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_cipher_info_t {
    pub type_: mbedtls_cipher_type_t,
    pub mode: mbedtls_cipher_mode_t,
    pub key_bitlen: ffi::ctypes::c_uint,
    pub name: *const ffi::ctypes::c_char,
    pub iv_size: ffi::ctypes::c_uint,
    pub flags: ffi::ctypes::c_int,
    pub block_size: ffi::ctypes::c_uint,
    pub base: *const mbedtls_cipher_base_t,
}
impl Default for mbedtls_cipher_info_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_cipher_context_t {
    pub cipher_info: *const mbedtls_cipher_info_t,
    pub key_bitlen: ffi::ctypes::c_int,
    pub operation: mbedtls_operation_t,
    pub add_padding: ::core::option::Option<
        unsafe extern "C" fn(output: *mut ffi::ctypes::c_uchar, olen: size_t, data_len: size_t),
    >,
    pub get_padding: ::core::option::Option<
        unsafe extern "C" fn(
            input: *mut ffi::ctypes::c_uchar,
            ilen: size_t,
            data_len: *mut size_t,
        ) -> ffi::ctypes::c_int,
    >,
    pub unprocessed_data: [ffi::ctypes::c_uchar; 16usize],
    pub unprocessed_len: size_t,
    pub iv: [ffi::ctypes::c_uchar; 16usize],
    pub iv_size: size_t,
    pub cipher_ctx: *mut ffi::ctypes::c_void,
}
impl Default for mbedtls_cipher_context_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn mbedtls_cipher_list() -> *const ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_cipher_info_from_string(
        cipher_name: *const ffi::ctypes::c_char,
    ) -> *const mbedtls_cipher_info_t;
}
extern "C" {
    pub fn mbedtls_cipher_info_from_type(
        cipher_type: mbedtls_cipher_type_t,
    ) -> *const mbedtls_cipher_info_t;
}
extern "C" {
    pub fn mbedtls_cipher_info_from_values(
        cipher_id: mbedtls_cipher_id_t,
        key_bitlen: ffi::ctypes::c_int,
        mode: mbedtls_cipher_mode_t,
    ) -> *const mbedtls_cipher_info_t;
}
extern "C" {
    pub fn mbedtls_cipher_init(ctx: *mut mbedtls_cipher_context_t);
}
extern "C" {
    pub fn mbedtls_cipher_free(ctx: *mut mbedtls_cipher_context_t);
}
extern "C" {
    pub fn mbedtls_cipher_setup(
        ctx: *mut mbedtls_cipher_context_t,
        cipher_info: *const mbedtls_cipher_info_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_cipher_setkey(
        ctx: *mut mbedtls_cipher_context_t,
        key: *const ffi::ctypes::c_uchar,
        key_bitlen: ffi::ctypes::c_int,
        operation: mbedtls_operation_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_cipher_set_padding_mode(
        ctx: *mut mbedtls_cipher_context_t,
        mode: mbedtls_cipher_padding_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_cipher_set_iv(
        ctx: *mut mbedtls_cipher_context_t,
        iv: *const ffi::ctypes::c_uchar,
        iv_len: size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_cipher_reset(ctx: *mut mbedtls_cipher_context_t) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_cipher_update_ad(
        ctx: *mut mbedtls_cipher_context_t,
        ad: *const ffi::ctypes::c_uchar,
        ad_len: size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_cipher_update(
        ctx: *mut mbedtls_cipher_context_t,
        input: *const ffi::ctypes::c_uchar,
        ilen: size_t,
        output: *mut ffi::ctypes::c_uchar,
        olen: *mut size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_cipher_finish(
        ctx: *mut mbedtls_cipher_context_t,
        output: *mut ffi::ctypes::c_uchar,
        olen: *mut size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_cipher_write_tag(
        ctx: *mut mbedtls_cipher_context_t,
        tag: *mut ffi::ctypes::c_uchar,
        tag_len: size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_cipher_check_tag(
        ctx: *mut mbedtls_cipher_context_t,
        tag: *const ffi::ctypes::c_uchar,
        tag_len: size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_cipher_crypt(
        ctx: *mut mbedtls_cipher_context_t,
        iv: *const ffi::ctypes::c_uchar,
        iv_len: size_t,
        input: *const ffi::ctypes::c_uchar,
        ilen: size_t,
        output: *mut ffi::ctypes::c_uchar,
        olen: *mut size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_cipher_auth_encrypt(
        ctx: *mut mbedtls_cipher_context_t,
        iv: *const ffi::ctypes::c_uchar,
        iv_len: size_t,
        ad: *const ffi::ctypes::c_uchar,
        ad_len: size_t,
        input: *const ffi::ctypes::c_uchar,
        ilen: size_t,
        output: *mut ffi::ctypes::c_uchar,
        olen: *mut size_t,
        tag: *mut ffi::ctypes::c_uchar,
        tag_len: size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_cipher_auth_decrypt(
        ctx: *mut mbedtls_cipher_context_t,
        iv: *const ffi::ctypes::c_uchar,
        iv_len: size_t,
        ad: *const ffi::ctypes::c_uchar,
        ad_len: size_t,
        input: *const ffi::ctypes::c_uchar,
        ilen: size_t,
        output: *mut ffi::ctypes::c_uchar,
        olen: *mut size_t,
        tag: *const ffi::ctypes::c_uchar,
        tag_len: size_t,
    ) -> ffi::ctypes::c_int;
}
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_NONE: mbedtls_key_exchange_type_t = 0;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_RSA: mbedtls_key_exchange_type_t = 1;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_DHE_RSA: mbedtls_key_exchange_type_t = 2;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_ECDHE_RSA: mbedtls_key_exchange_type_t =
    3;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA:
    mbedtls_key_exchange_type_t = 4;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_PSK: mbedtls_key_exchange_type_t = 5;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_DHE_PSK: mbedtls_key_exchange_type_t = 6;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_RSA_PSK: mbedtls_key_exchange_type_t = 7;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_ECDHE_PSK: mbedtls_key_exchange_type_t =
    8;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_ECDH_RSA: mbedtls_key_exchange_type_t =
    9;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA: mbedtls_key_exchange_type_t =
    10;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_ECJPAKE: mbedtls_key_exchange_type_t =
    11;
pub type mbedtls_key_exchange_type_t = ffi::ctypes::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ssl_ciphersuite_t {
    pub id: ffi::ctypes::c_int,
    pub name: *const ffi::ctypes::c_char,
    pub cipher: mbedtls_cipher_type_t,
    pub mac: mbedtls_md_type_t,
    pub key_exchange: mbedtls_key_exchange_type_t,
    pub min_major_ver: ffi::ctypes::c_int,
    pub min_minor_ver: ffi::ctypes::c_int,
    pub max_major_ver: ffi::ctypes::c_int,
    pub max_minor_ver: ffi::ctypes::c_int,
    pub flags: ffi::ctypes::c_uchar,
}
impl Default for mbedtls_ssl_ciphersuite_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn mbedtls_ssl_list_ciphersuites() -> *const ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ssl_ciphersuite_from_string(
        ciphersuite_name: *const ffi::ctypes::c_char,
    ) -> *const mbedtls_ssl_ciphersuite_t;
}
extern "C" {
    pub fn mbedtls_ssl_ciphersuite_from_id(
        ciphersuite_id: ffi::ctypes::c_int,
    ) -> *const mbedtls_ssl_ciphersuite_t;
}
extern "C" {
    pub fn mbedtls_ssl_get_ciphersuite_sig_pk_alg(
        info: *const mbedtls_ssl_ciphersuite_t,
    ) -> mbedtls_pk_type_t;
}
extern "C" {
    pub fn mbedtls_ssl_ciphersuite_uses_ec(
        info: *const mbedtls_ssl_ciphersuite_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ssl_ciphersuite_uses_psk(
        info: *const mbedtls_ssl_ciphersuite_t,
    ) -> ffi::ctypes::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_asn1_buf {
    pub tag: ffi::ctypes::c_int,
    pub len: size_t,
    pub p: *mut ffi::ctypes::c_uchar,
}
impl Default for mbedtls_asn1_buf {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_asn1_bitstring {
    pub len: size_t,
    pub unused_bits: ffi::ctypes::c_uchar,
    pub p: *mut ffi::ctypes::c_uchar,
}
impl Default for mbedtls_asn1_bitstring {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_asn1_sequence {
    pub buf: mbedtls_asn1_buf,
    pub next: *mut mbedtls_asn1_sequence,
}
impl Default for mbedtls_asn1_sequence {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_asn1_named_data {
    pub oid: mbedtls_asn1_buf,
    pub val: mbedtls_asn1_buf,
    pub next: *mut mbedtls_asn1_named_data,
    pub next_merged: ffi::ctypes::c_uchar,
}
impl Default for mbedtls_asn1_named_data {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn mbedtls_asn1_get_len(
        p: *mut *mut ffi::ctypes::c_uchar,
        end: *const ffi::ctypes::c_uchar,
        len: *mut size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_asn1_get_tag(
        p: *mut *mut ffi::ctypes::c_uchar,
        end: *const ffi::ctypes::c_uchar,
        len: *mut size_t,
        tag: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_asn1_get_bool(
        p: *mut *mut ffi::ctypes::c_uchar,
        end: *const ffi::ctypes::c_uchar,
        val: *mut ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_asn1_get_int(
        p: *mut *mut ffi::ctypes::c_uchar,
        end: *const ffi::ctypes::c_uchar,
        val: *mut ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_asn1_get_bitstring(
        p: *mut *mut ffi::ctypes::c_uchar,
        end: *const ffi::ctypes::c_uchar,
        bs: *mut mbedtls_asn1_bitstring,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_asn1_get_bitstring_null(
        p: *mut *mut ffi::ctypes::c_uchar,
        end: *const ffi::ctypes::c_uchar,
        len: *mut size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_asn1_get_sequence_of(
        p: *mut *mut ffi::ctypes::c_uchar,
        end: *const ffi::ctypes::c_uchar,
        cur: *mut mbedtls_asn1_sequence,
        tag: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_asn1_get_mpi(
        p: *mut *mut ffi::ctypes::c_uchar,
        end: *const ffi::ctypes::c_uchar,
        X: *mut mbedtls_mpi,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_asn1_get_alg(
        p: *mut *mut ffi::ctypes::c_uchar,
        end: *const ffi::ctypes::c_uchar,
        alg: *mut mbedtls_asn1_buf,
        params: *mut mbedtls_asn1_buf,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_asn1_get_alg_null(
        p: *mut *mut ffi::ctypes::c_uchar,
        end: *const ffi::ctypes::c_uchar,
        alg: *mut mbedtls_asn1_buf,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_asn1_find_named_data(
        list: *mut mbedtls_asn1_named_data,
        oid: *const ffi::ctypes::c_char,
        len: size_t,
    ) -> *mut mbedtls_asn1_named_data;
}
extern "C" {
    pub fn mbedtls_asn1_free_named_data(entry: *mut mbedtls_asn1_named_data);
}
extern "C" {
    pub fn mbedtls_asn1_free_named_data_list(head: *mut *mut mbedtls_asn1_named_data);
}
pub type mbedtls_x509_buf = mbedtls_asn1_buf;
pub type mbedtls_x509_bitstring = mbedtls_asn1_bitstring;
pub type mbedtls_x509_name = mbedtls_asn1_named_data;
pub type mbedtls_x509_sequence = mbedtls_asn1_sequence;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mbedtls_x509_time {
    pub year: ffi::ctypes::c_int,
    pub mon: ffi::ctypes::c_int,
    pub day: ffi::ctypes::c_int,
    pub hour: ffi::ctypes::c_int,
    pub min: ffi::ctypes::c_int,
    pub sec: ffi::ctypes::c_int,
}
extern "C" {
    pub fn mbedtls_x509_dn_gets(
        buf: *mut ffi::ctypes::c_char,
        size: size_t,
        dn: *const mbedtls_x509_name,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_x509_serial_gets(
        buf: *mut ffi::ctypes::c_char,
        size: size_t,
        serial: *const mbedtls_x509_buf,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_x509_time_is_past(time: *const mbedtls_x509_time) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_x509_time_is_future(time: *const mbedtls_x509_time) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_x509_self_test(verbose: ffi::ctypes::c_int) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_name(
        p: *mut *mut ffi::ctypes::c_uchar,
        end: *const ffi::ctypes::c_uchar,
        cur: *mut mbedtls_x509_name,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_alg_null(
        p: *mut *mut ffi::ctypes::c_uchar,
        end: *const ffi::ctypes::c_uchar,
        alg: *mut mbedtls_x509_buf,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_alg(
        p: *mut *mut ffi::ctypes::c_uchar,
        end: *const ffi::ctypes::c_uchar,
        alg: *mut mbedtls_x509_buf,
        params: *mut mbedtls_x509_buf,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_sig(
        p: *mut *mut ffi::ctypes::c_uchar,
        end: *const ffi::ctypes::c_uchar,
        sig: *mut mbedtls_x509_buf,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_sig_alg(
        sig_oid: *const mbedtls_x509_buf,
        sig_params: *const mbedtls_x509_buf,
        md_alg: *mut mbedtls_md_type_t,
        pk_alg: *mut mbedtls_pk_type_t,
        sig_opts: *mut *mut ffi::ctypes::c_void,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_time(
        p: *mut *mut ffi::ctypes::c_uchar,
        end: *const ffi::ctypes::c_uchar,
        time: *mut mbedtls_x509_time,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_serial(
        p: *mut *mut ffi::ctypes::c_uchar,
        end: *const ffi::ctypes::c_uchar,
        serial: *mut mbedtls_x509_buf,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_ext(
        p: *mut *mut ffi::ctypes::c_uchar,
        end: *const ffi::ctypes::c_uchar,
        ext: *mut mbedtls_x509_buf,
        tag: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_x509_sig_alg_gets(
        buf: *mut ffi::ctypes::c_char,
        size: size_t,
        sig_oid: *const mbedtls_x509_buf,
        pk_alg: mbedtls_pk_type_t,
        md_alg: mbedtls_md_type_t,
        sig_opts: *const ffi::ctypes::c_void,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_x509_key_size_helper(
        buf: *mut ffi::ctypes::c_char,
        buf_size: size_t,
        name: *const ffi::ctypes::c_char,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_x509_string_to_names(
        head: *mut *mut mbedtls_asn1_named_data,
        name: *const ffi::ctypes::c_char,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_x509_set_extension(
        head: *mut *mut mbedtls_asn1_named_data,
        oid: *const ffi::ctypes::c_char,
        oid_len: size_t,
        critical: ffi::ctypes::c_int,
        val: *const ffi::ctypes::c_uchar,
        val_len: size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_x509_write_extensions(
        p: *mut *mut ffi::ctypes::c_uchar,
        start: *mut ffi::ctypes::c_uchar,
        first: *mut mbedtls_asn1_named_data,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_x509_write_names(
        p: *mut *mut ffi::ctypes::c_uchar,
        start: *mut ffi::ctypes::c_uchar,
        first: *mut mbedtls_asn1_named_data,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_x509_write_sig(
        p: *mut *mut ffi::ctypes::c_uchar,
        start: *mut ffi::ctypes::c_uchar,
        oid: *const ffi::ctypes::c_char,
        oid_len: size_t,
        sig: *mut ffi::ctypes::c_uchar,
        size: size_t,
    ) -> ffi::ctypes::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_x509_crl_entry {
    pub raw: mbedtls_x509_buf,
    pub serial: mbedtls_x509_buf,
    pub revocation_date: mbedtls_x509_time,
    pub entry_ext: mbedtls_x509_buf,
    pub next: *mut mbedtls_x509_crl_entry,
}
impl Default for mbedtls_x509_crl_entry {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_x509_crl {
    pub raw: mbedtls_x509_buf,
    pub tbs: mbedtls_x509_buf,
    pub version: ffi::ctypes::c_int,
    pub sig_oid: mbedtls_x509_buf,
    pub issuer_raw: mbedtls_x509_buf,
    pub issuer: mbedtls_x509_name,
    pub this_update: mbedtls_x509_time,
    pub next_update: mbedtls_x509_time,
    pub entry: mbedtls_x509_crl_entry,
    pub crl_ext: mbedtls_x509_buf,
    pub sig_oid2: mbedtls_x509_buf,
    pub sig: mbedtls_x509_buf,
    pub sig_md: mbedtls_md_type_t,
    pub sig_pk: mbedtls_pk_type_t,
    pub sig_opts: *mut ffi::ctypes::c_void,
    pub next: *mut mbedtls_x509_crl,
}
impl Default for mbedtls_x509_crl {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn mbedtls_x509_crl_parse_der(
        chain: *mut mbedtls_x509_crl,
        buf: *const ffi::ctypes::c_uchar,
        buflen: size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_x509_crl_parse(
        chain: *mut mbedtls_x509_crl,
        buf: *const ffi::ctypes::c_uchar,
        buflen: size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_x509_crl_info(
        buf: *mut ffi::ctypes::c_char,
        size: size_t,
        prefix: *const ffi::ctypes::c_char,
        crl: *const mbedtls_x509_crl,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_x509_crl_init(crl: *mut mbedtls_x509_crl);
}
extern "C" {
    pub fn mbedtls_x509_crl_free(crl: *mut mbedtls_x509_crl);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_x509_crt {
    pub raw: mbedtls_x509_buf,
    pub tbs: mbedtls_x509_buf,
    pub version: ffi::ctypes::c_int,
    pub serial: mbedtls_x509_buf,
    pub sig_oid: mbedtls_x509_buf,
    pub issuer_raw: mbedtls_x509_buf,
    pub subject_raw: mbedtls_x509_buf,
    pub issuer: mbedtls_x509_name,
    pub subject: mbedtls_x509_name,
    pub valid_from: mbedtls_x509_time,
    pub valid_to: mbedtls_x509_time,
    pub pk: mbedtls_pk_context,
    pub issuer_id: mbedtls_x509_buf,
    pub subject_id: mbedtls_x509_buf,
    pub v3_ext: mbedtls_x509_buf,
    pub subject_alt_names: mbedtls_x509_sequence,
    pub ext_types: ffi::ctypes::c_int,
    pub ca_istrue: ffi::ctypes::c_int,
    pub max_pathlen: ffi::ctypes::c_int,
    pub key_usage: ffi::ctypes::c_uint,
    pub ext_key_usage: mbedtls_x509_sequence,
    pub ns_cert_type: ffi::ctypes::c_uchar,
    pub sig: mbedtls_x509_buf,
    pub sig_md: mbedtls_md_type_t,
    pub sig_pk: mbedtls_pk_type_t,
    pub sig_opts: *mut ffi::ctypes::c_void,
    pub next: *mut mbedtls_x509_crt,
}
impl Default for mbedtls_x509_crt {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mbedtls_x509_crt_profile {
    pub allowed_mds: u32,
    pub allowed_pks: u32,
    pub allowed_curves: u32,
    pub rsa_min_bitlen: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_x509write_cert {
    pub version: ffi::ctypes::c_int,
    pub serial: mbedtls_mpi,
    pub subject_key: *mut mbedtls_pk_context,
    pub issuer_key: *mut mbedtls_pk_context,
    pub subject: *mut mbedtls_asn1_named_data,
    pub issuer: *mut mbedtls_asn1_named_data,
    pub md_alg: mbedtls_md_type_t,
    pub not_before: [ffi::ctypes::c_char; 16usize],
    pub not_after: [ffi::ctypes::c_char; 16usize],
    pub extensions: *mut mbedtls_asn1_named_data,
}
impl Default for mbedtls_x509write_cert {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static mbedtls_x509_crt_profile_default: mbedtls_x509_crt_profile;
}
extern "C" {
    pub static mbedtls_x509_crt_profile_next: mbedtls_x509_crt_profile;
}
extern "C" {
    pub static mbedtls_x509_crt_profile_suiteb: mbedtls_x509_crt_profile;
}
extern "C" {
    pub fn mbedtls_x509_crt_parse_der(
        chain: *mut mbedtls_x509_crt,
        buf: *const ffi::ctypes::c_uchar,
        buflen: size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_x509_crt_parse(
        chain: *mut mbedtls_x509_crt,
        buf: *const ffi::ctypes::c_uchar,
        buflen: size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_x509_crt_info(
        buf: *mut ffi::ctypes::c_char,
        size: size_t,
        prefix: *const ffi::ctypes::c_char,
        crt: *const mbedtls_x509_crt,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_x509_crt_verify_info(
        buf: *mut ffi::ctypes::c_char,
        size: size_t,
        prefix: *const ffi::ctypes::c_char,
        flags: u32,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_x509_crt_verify(
        crt: *mut mbedtls_x509_crt,
        trust_ca: *mut mbedtls_x509_crt,
        ca_crl: *mut mbedtls_x509_crl,
        cn: *const ffi::ctypes::c_char,
        flags: *mut u32,
        f_vrfy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ffi::ctypes::c_void,
                arg2: *mut mbedtls_x509_crt,
                arg3: ffi::ctypes::c_int,
                arg4: *mut u32,
            ) -> ffi::ctypes::c_int,
        >,
        p_vrfy: *mut ffi::ctypes::c_void,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_x509_crt_verify_with_profile(
        crt: *mut mbedtls_x509_crt,
        trust_ca: *mut mbedtls_x509_crt,
        ca_crl: *mut mbedtls_x509_crl,
        profile: *const mbedtls_x509_crt_profile,
        cn: *const ffi::ctypes::c_char,
        flags: *mut u32,
        f_vrfy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ffi::ctypes::c_void,
                arg2: *mut mbedtls_x509_crt,
                arg3: ffi::ctypes::c_int,
                arg4: *mut u32,
            ) -> ffi::ctypes::c_int,
        >,
        p_vrfy: *mut ffi::ctypes::c_void,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_x509_crt_init(crt: *mut mbedtls_x509_crt);
}
extern "C" {
    pub fn mbedtls_x509_crt_free(crt: *mut mbedtls_x509_crt);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_dhm_context {
    pub len: size_t,
    pub P: mbedtls_mpi,
    pub G: mbedtls_mpi,
    pub X: mbedtls_mpi,
    pub GX: mbedtls_mpi,
    pub GY: mbedtls_mpi,
    pub K: mbedtls_mpi,
    pub RP: mbedtls_mpi,
    pub Vi: mbedtls_mpi,
    pub Vf: mbedtls_mpi,
    pub pX: mbedtls_mpi,
}
impl Default for mbedtls_dhm_context {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn mbedtls_dhm_init(ctx: *mut mbedtls_dhm_context);
}
extern "C" {
    pub fn mbedtls_dhm_read_params(
        ctx: *mut mbedtls_dhm_context,
        p: *mut *mut ffi::ctypes::c_uchar,
        end: *const ffi::ctypes::c_uchar,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_dhm_make_params(
        ctx: *mut mbedtls_dhm_context,
        x_size: ffi::ctypes::c_int,
        output: *mut ffi::ctypes::c_uchar,
        olen: *mut size_t,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ffi::ctypes::c_void,
                arg2: *mut ffi::ctypes::c_uchar,
                arg3: size_t,
            ) -> ffi::ctypes::c_int,
        >,
        p_rng: *mut ffi::ctypes::c_void,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_dhm_read_public(
        ctx: *mut mbedtls_dhm_context,
        input: *const ffi::ctypes::c_uchar,
        ilen: size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_dhm_make_public(
        ctx: *mut mbedtls_dhm_context,
        x_size: ffi::ctypes::c_int,
        output: *mut ffi::ctypes::c_uchar,
        olen: size_t,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ffi::ctypes::c_void,
                arg2: *mut ffi::ctypes::c_uchar,
                arg3: size_t,
            ) -> ffi::ctypes::c_int,
        >,
        p_rng: *mut ffi::ctypes::c_void,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_dhm_calc_secret(
        ctx: *mut mbedtls_dhm_context,
        output: *mut ffi::ctypes::c_uchar,
        output_size: size_t,
        olen: *mut size_t,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ffi::ctypes::c_void,
                arg2: *mut ffi::ctypes::c_uchar,
                arg3: size_t,
            ) -> ffi::ctypes::c_int,
        >,
        p_rng: *mut ffi::ctypes::c_void,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_dhm_free(ctx: *mut mbedtls_dhm_context);
}
extern "C" {
    pub fn mbedtls_dhm_parse_dhm(
        dhm: *mut mbedtls_dhm_context,
        dhmin: *const ffi::ctypes::c_uchar,
        dhminlen: size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_dhm_self_test(verbose: ffi::ctypes::c_int) -> ffi::ctypes::c_int;
}
pub const mbedtls_ecdh_side_MBEDTLS_ECDH_OURS: mbedtls_ecdh_side = 0;
pub const mbedtls_ecdh_side_MBEDTLS_ECDH_THEIRS: mbedtls_ecdh_side = 1;
pub type mbedtls_ecdh_side = ffi::ctypes::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ecdh_context {
    pub grp: mbedtls_ecp_group,
    pub d: mbedtls_mpi,
    pub Q: mbedtls_ecp_point,
    pub Qp: mbedtls_ecp_point,
    pub z: mbedtls_mpi,
    pub point_format: ffi::ctypes::c_int,
    pub Vi: mbedtls_ecp_point,
    pub Vf: mbedtls_ecp_point,
    pub _d: mbedtls_mpi,
}
impl Default for mbedtls_ecdh_context {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn mbedtls_ecdh_gen_public(
        grp: *mut mbedtls_ecp_group,
        d: *mut mbedtls_mpi,
        Q: *mut mbedtls_ecp_point,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ffi::ctypes::c_void,
                arg2: *mut ffi::ctypes::c_uchar,
                arg3: size_t,
            ) -> ffi::ctypes::c_int,
        >,
        p_rng: *mut ffi::ctypes::c_void,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ecdh_compute_shared(
        grp: *mut mbedtls_ecp_group,
        z: *mut mbedtls_mpi,
        Q: *const mbedtls_ecp_point,
        d: *const mbedtls_mpi,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ffi::ctypes::c_void,
                arg2: *mut ffi::ctypes::c_uchar,
                arg3: size_t,
            ) -> ffi::ctypes::c_int,
        >,
        p_rng: *mut ffi::ctypes::c_void,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ecdh_init(ctx: *mut mbedtls_ecdh_context);
}
extern "C" {
    pub fn mbedtls_ecdh_free(ctx: *mut mbedtls_ecdh_context);
}
extern "C" {
    pub fn mbedtls_ecdh_make_params(
        ctx: *mut mbedtls_ecdh_context,
        olen: *mut size_t,
        buf: *mut ffi::ctypes::c_uchar,
        blen: size_t,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ffi::ctypes::c_void,
                arg2: *mut ffi::ctypes::c_uchar,
                arg3: size_t,
            ) -> ffi::ctypes::c_int,
        >,
        p_rng: *mut ffi::ctypes::c_void,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ecdh_read_params(
        ctx: *mut mbedtls_ecdh_context,
        buf: *mut *const ffi::ctypes::c_uchar,
        end: *const ffi::ctypes::c_uchar,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ecdh_get_params(
        ctx: *mut mbedtls_ecdh_context,
        key: *const mbedtls_ecp_keypair,
        side: mbedtls_ecdh_side,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ecdh_make_public(
        ctx: *mut mbedtls_ecdh_context,
        olen: *mut size_t,
        buf: *mut ffi::ctypes::c_uchar,
        blen: size_t,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ffi::ctypes::c_void,
                arg2: *mut ffi::ctypes::c_uchar,
                arg3: size_t,
            ) -> ffi::ctypes::c_int,
        >,
        p_rng: *mut ffi::ctypes::c_void,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ecdh_read_public(
        ctx: *mut mbedtls_ecdh_context,
        buf: *const ffi::ctypes::c_uchar,
        blen: size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ecdh_calc_secret(
        ctx: *mut mbedtls_ecdh_context,
        olen: *mut size_t,
        buf: *mut ffi::ctypes::c_uchar,
        blen: size_t,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ffi::ctypes::c_void,
                arg2: *mut ffi::ctypes::c_uchar,
                arg3: size_t,
            ) -> ffi::ctypes::c_int,
        >,
        p_rng: *mut ffi::ctypes::c_void,
    ) -> ffi::ctypes::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_ssl_premaster_secret {
    pub _pms_rsa: [ffi::ctypes::c_uchar; 48usize],
    pub _pms_dhm: [ffi::ctypes::c_uchar; 1024usize],
    pub _pms_ecdh: [ffi::ctypes::c_uchar; 66usize],
    pub _pms_psk: [ffi::ctypes::c_uchar; 68usize],
    pub _pms_dhe_psk: [ffi::ctypes::c_uchar; 1060usize],
    pub _pms_rsa_psk: [ffi::ctypes::c_uchar; 84usize],
    pub _pms_ecdhe_psk: [ffi::ctypes::c_uchar; 102usize],
    _bindgen_union_align: [u8; 1060usize],
}
impl Default for mbedtls_ssl_premaster_secret {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for mbedtls_ssl_premaster_secret {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "mbedtls_ssl_premaster_secret {{ union }}")
    }
}
pub const mbedtls_ssl_states_MBEDTLS_SSL_HELLO_REQUEST: mbedtls_ssl_states = 0;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CLIENT_HELLO: mbedtls_ssl_states = 1;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_HELLO: mbedtls_ssl_states = 2;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_CERTIFICATE: mbedtls_ssl_states = 3;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_KEY_EXCHANGE: mbedtls_ssl_states = 4;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CERTIFICATE_REQUEST: mbedtls_ssl_states = 5;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_HELLO_DONE: mbedtls_ssl_states = 6;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CLIENT_CERTIFICATE: mbedtls_ssl_states = 7;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CLIENT_KEY_EXCHANGE: mbedtls_ssl_states = 8;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CERTIFICATE_VERIFY: mbedtls_ssl_states = 9;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CLIENT_CHANGE_CIPHER_SPEC: mbedtls_ssl_states = 10;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CLIENT_FINISHED: mbedtls_ssl_states = 11;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC: mbedtls_ssl_states = 12;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_FINISHED: mbedtls_ssl_states = 13;
pub const mbedtls_ssl_states_MBEDTLS_SSL_FLUSH_BUFFERS: mbedtls_ssl_states = 14;
pub const mbedtls_ssl_states_MBEDTLS_SSL_HANDSHAKE_WRAPUP: mbedtls_ssl_states = 15;
pub const mbedtls_ssl_states_MBEDTLS_SSL_HANDSHAKE_OVER: mbedtls_ssl_states = 16;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_NEW_SESSION_TICKET: mbedtls_ssl_states = 17;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_HELLO_VERIFY_REQUEST_SENT: mbedtls_ssl_states = 18;
pub type mbedtls_ssl_states = ffi::ctypes::c_uint;
pub type mbedtls_ssl_send_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ffi::ctypes::c_void,
        buf: *const ffi::ctypes::c_uchar,
        len: size_t,
    ) -> ffi::ctypes::c_int,
>;
pub type mbedtls_ssl_recv_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ffi::ctypes::c_void,
        buf: *mut ffi::ctypes::c_uchar,
        len: size_t,
    ) -> ffi::ctypes::c_int,
>;
pub type mbedtls_ssl_recv_timeout_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ffi::ctypes::c_void,
        buf: *mut ffi::ctypes::c_uchar,
        len: size_t,
        timeout: u32,
    ) -> ffi::ctypes::c_int,
>;
pub type mbedtls_ssl_set_timer_t = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut ffi::ctypes::c_void, int_ms: u32, fin_ms: u32),
>;
pub type mbedtls_ssl_get_timer_t = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut ffi::ctypes::c_void) -> ffi::ctypes::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ssl_transform {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ssl_handshake_params {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ssl_key_cert {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ssl_session {
    pub ciphersuite: ffi::ctypes::c_int,
    pub compression: ffi::ctypes::c_int,
    pub id_len: size_t,
    pub id: [ffi::ctypes::c_uchar; 32usize],
    pub master: [ffi::ctypes::c_uchar; 48usize],
    pub peer_cert: *mut mbedtls_x509_crt,
    pub verify_result: u32,
    pub ticket: *mut ffi::ctypes::c_uchar,
    pub ticket_len: size_t,
    pub ticket_lifetime: u32,
    pub mfl_code: ffi::ctypes::c_uchar,
    pub trunc_hmac: ffi::ctypes::c_int,
    pub encrypt_then_mac: ffi::ctypes::c_int,
}
impl Default for mbedtls_ssl_session {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for mbedtls_ssl_session {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "mbedtls_ssl_session {{ ciphersuite: {:?}, compression: {:?}, id_len: {:?}, id: [...], master: [...], peer_cert: {:?}, verify_result: {:?}, ticket: {:?}, ticket_len: {:?}, ticket_lifetime: {:?}, mfl_code: {:?}, trunc_hmac: {:?}, encrypt_then_mac: {:?} }}" , self . ciphersuite , self . compression , self . id_len , self . peer_cert , self . verify_result , self . ticket , self . ticket_len , self . ticket_lifetime , self . mfl_code , self . trunc_hmac , self . encrypt_then_mac)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ssl_config {
    pub ciphersuite_list: [*const ffi::ctypes::c_int; 4usize],
    pub f_dbg: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ffi::ctypes::c_void,
            arg2: ffi::ctypes::c_int,
            arg3: *const ffi::ctypes::c_char,
            arg4: ffi::ctypes::c_int,
            arg5: *const ffi::ctypes::c_char,
        ),
    >,
    pub p_dbg: *mut ffi::ctypes::c_void,
    pub f_rng: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ffi::ctypes::c_void,
            arg2: *mut ffi::ctypes::c_uchar,
            arg3: size_t,
        ) -> ffi::ctypes::c_int,
    >,
    pub p_rng: *mut ffi::ctypes::c_void,
    pub f_get_cache: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ffi::ctypes::c_void,
            arg2: *mut mbedtls_ssl_session,
        ) -> ffi::ctypes::c_int,
    >,
    pub f_set_cache: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ffi::ctypes::c_void,
            arg2: *const mbedtls_ssl_session,
        ) -> ffi::ctypes::c_int,
    >,
    pub p_cache: *mut ffi::ctypes::c_void,
    pub f_sni: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ffi::ctypes::c_void,
            arg2: *mut mbedtls_ssl_context,
            arg3: *const ffi::ctypes::c_uchar,
            arg4: size_t,
        ) -> ffi::ctypes::c_int,
    >,
    pub p_sni: *mut ffi::ctypes::c_void,
    pub f_vrfy: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ffi::ctypes::c_void,
            arg2: *mut mbedtls_x509_crt,
            arg3: ffi::ctypes::c_int,
            arg4: *mut u32,
        ) -> ffi::ctypes::c_int,
    >,
    pub p_vrfy: *mut ffi::ctypes::c_void,
    pub f_psk: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ffi::ctypes::c_void,
            arg2: *mut mbedtls_ssl_context,
            arg3: *const ffi::ctypes::c_uchar,
            arg4: size_t,
        ) -> ffi::ctypes::c_int,
    >,
    pub p_psk: *mut ffi::ctypes::c_void,
    pub f_export_keys: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ffi::ctypes::c_void,
            arg2: *const ffi::ctypes::c_uchar,
            arg3: *const ffi::ctypes::c_uchar,
            arg4: size_t,
            arg5: size_t,
            arg6: size_t,
        ) -> ffi::ctypes::c_int,
    >,
    pub p_export_keys: *mut ffi::ctypes::c_void,
    pub cert_profile: *const mbedtls_x509_crt_profile,
    pub key_cert: *mut mbedtls_ssl_key_cert,
    pub ca_chain: *mut mbedtls_x509_crt,
    pub ca_crl: *mut mbedtls_x509_crl,
    pub sig_hashes: *const ffi::ctypes::c_int,
    pub curve_list: *const mbedtls_ecp_group_id,
    pub dhm_P: mbedtls_mpi,
    pub dhm_G: mbedtls_mpi,
    pub psk: *mut ffi::ctypes::c_uchar,
    pub psk_len: size_t,
    pub psk_identity: *mut ffi::ctypes::c_uchar,
    pub psk_identity_len: size_t,
    pub read_timeout: u32,
    pub renego_max_records: ffi::ctypes::c_int,
    pub renego_period: [ffi::ctypes::c_uchar; 8usize],
    pub dhm_min_bitlen: ffi::ctypes::c_uint,
    pub max_major_ver: ffi::ctypes::c_uchar,
    pub max_minor_ver: ffi::ctypes::c_uchar,
    pub min_major_ver: ffi::ctypes::c_uchar,
    pub min_minor_ver: ffi::ctypes::c_uchar,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub __bindgen_padding_0: [u8; 5usize],
}
impl Default for mbedtls_ssl_config {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl mbedtls_ssl_config {
    #[inline]
    pub fn endpoint(&self) -> ffi::ctypes::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_endpoint(&mut self, val: ffi::ctypes::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn transport(&self) -> ffi::ctypes::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transport(&mut self, val: ffi::ctypes::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn authmode(&self) -> ffi::ctypes::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_authmode(&mut self, val: ffi::ctypes::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn allow_legacy_renegotiation(&self) -> ffi::ctypes::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_allow_legacy_renegotiation(&mut self, val: ffi::ctypes::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn arc4_disabled(&self) -> ffi::ctypes::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_arc4_disabled(&mut self, val: ffi::ctypes::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mfl_code(&self) -> ffi::ctypes::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_mfl_code(&mut self, val: ffi::ctypes::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn encrypt_then_mac(&self) -> ffi::ctypes::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_encrypt_then_mac(&mut self, val: ffi::ctypes::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn extended_ms(&self) -> ffi::ctypes::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_extended_ms(&mut self, val: ffi::ctypes::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cbc_record_splitting(&self) -> ffi::ctypes::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cbc_record_splitting(&mut self, val: ffi::ctypes::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disable_renegotiation(&self) -> ffi::ctypes::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disable_renegotiation(&mut self, val: ffi::ctypes::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn trunc_hmac(&self) -> ffi::ctypes::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_trunc_hmac(&mut self, val: ffi::ctypes::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn session_tickets(&self) -> ffi::ctypes::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_session_tickets(&mut self, val: ffi::ctypes::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fallback(&self) -> ffi::ctypes::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fallback(&mut self, val: ffi::ctypes::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        endpoint: ffi::ctypes::c_uint,
        transport: ffi::ctypes::c_uint,
        authmode: ffi::ctypes::c_uint,
        allow_legacy_renegotiation: ffi::ctypes::c_uint,
        arc4_disabled: ffi::ctypes::c_uint,
        mfl_code: ffi::ctypes::c_uint,
        encrypt_then_mac: ffi::ctypes::c_uint,
        extended_ms: ffi::ctypes::c_uint,
        cbc_record_splitting: ffi::ctypes::c_uint,
        disable_renegotiation: ffi::ctypes::c_uint,
        trunc_hmac: ffi::ctypes::c_uint,
        session_tickets: ffi::ctypes::c_uint,
        fallback: ffi::ctypes::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let endpoint: u32 = unsafe { ::core::mem::transmute(endpoint) };
            endpoint as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let transport: u32 = unsafe { ::core::mem::transmute(transport) };
            transport as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let authmode: u32 = unsafe { ::core::mem::transmute(authmode) };
            authmode as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let allow_legacy_renegotiation: u32 =
                unsafe { ::core::mem::transmute(allow_legacy_renegotiation) };
            allow_legacy_renegotiation as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let arc4_disabled: u32 = unsafe { ::core::mem::transmute(arc4_disabled) };
            arc4_disabled as u64
        });
        __bindgen_bitfield_unit.set(7usize, 3u8, {
            let mfl_code: u32 = unsafe { ::core::mem::transmute(mfl_code) };
            mfl_code as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let encrypt_then_mac: u32 = unsafe { ::core::mem::transmute(encrypt_then_mac) };
            encrypt_then_mac as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let extended_ms: u32 = unsafe { ::core::mem::transmute(extended_ms) };
            extended_ms as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let cbc_record_splitting: u32 = unsafe { ::core::mem::transmute(cbc_record_splitting) };
            cbc_record_splitting as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let disable_renegotiation: u32 =
                unsafe { ::core::mem::transmute(disable_renegotiation) };
            disable_renegotiation as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let trunc_hmac: u32 = unsafe { ::core::mem::transmute(trunc_hmac) };
            trunc_hmac as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let session_tickets: u32 = unsafe { ::core::mem::transmute(session_tickets) };
            session_tickets as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let fallback: u32 = unsafe { ::core::mem::transmute(fallback) };
            fallback as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ssl_context {
    pub conf: *const mbedtls_ssl_config,
    pub state: ffi::ctypes::c_int,
    pub renego_status: ffi::ctypes::c_int,
    pub renego_records_seen: ffi::ctypes::c_int,
    pub major_ver: ffi::ctypes::c_int,
    pub minor_ver: ffi::ctypes::c_int,
    pub f_send: mbedtls_ssl_send_t,
    pub f_recv: mbedtls_ssl_recv_t,
    pub f_recv_timeout: mbedtls_ssl_recv_timeout_t,
    pub p_bio: *mut ffi::ctypes::c_void,
    pub session_in: *mut mbedtls_ssl_session,
    pub session_out: *mut mbedtls_ssl_session,
    pub session: *mut mbedtls_ssl_session,
    pub session_negotiate: *mut mbedtls_ssl_session,
    pub handshake: *mut mbedtls_ssl_handshake_params,
    pub transform_in: *mut mbedtls_ssl_transform,
    pub transform_out: *mut mbedtls_ssl_transform,
    pub transform: *mut mbedtls_ssl_transform,
    pub transform_negotiate: *mut mbedtls_ssl_transform,
    pub p_timer: *mut ffi::ctypes::c_void,
    pub f_set_timer: mbedtls_ssl_set_timer_t,
    pub f_get_timer: mbedtls_ssl_get_timer_t,
    pub in_buf: *mut ffi::ctypes::c_uchar,
    pub in_ctr: *mut ffi::ctypes::c_uchar,
    pub in_hdr: *mut ffi::ctypes::c_uchar,
    pub in_len: *mut ffi::ctypes::c_uchar,
    pub in_iv: *mut ffi::ctypes::c_uchar,
    pub in_msg: *mut ffi::ctypes::c_uchar,
    pub in_offt: *mut ffi::ctypes::c_uchar,
    pub in_msgtype: ffi::ctypes::c_int,
    pub in_msglen: size_t,
    pub in_left: size_t,
    pub in_hslen: size_t,
    pub nb_zero: ffi::ctypes::c_int,
    pub record_read: ffi::ctypes::c_int,
    pub out_buf: *mut ffi::ctypes::c_uchar,
    pub out_ctr: *mut ffi::ctypes::c_uchar,
    pub out_hdr: *mut ffi::ctypes::c_uchar,
    pub out_len: *mut ffi::ctypes::c_uchar,
    pub out_iv: *mut ffi::ctypes::c_uchar,
    pub out_msg: *mut ffi::ctypes::c_uchar,
    pub out_msgtype: ffi::ctypes::c_int,
    pub out_msglen: size_t,
    pub out_left: size_t,
    pub split_done: ffi::ctypes::c_schar,
    pub client_auth: ffi::ctypes::c_int,
    pub hostname: *mut ffi::ctypes::c_char,
    pub secure_renegotiation: ffi::ctypes::c_int,
    pub verify_data_len: size_t,
    pub own_verify_data: [ffi::ctypes::c_char; 12usize],
    pub peer_verify_data: [ffi::ctypes::c_char; 12usize],
}
impl Default for mbedtls_ssl_context {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn mbedtls_ssl_get_ciphersuite_name(
        ciphersuite_id: ffi::ctypes::c_int,
    ) -> *const ffi::ctypes::c_char;
}
extern "C" {
    pub fn mbedtls_ssl_get_ciphersuite_id(
        ciphersuite_name: *const ffi::ctypes::c_char,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ssl_init(ssl: *mut mbedtls_ssl_context);
}
extern "C" {
    pub fn mbedtls_ssl_setup(
        ssl: *mut mbedtls_ssl_context,
        conf: *const mbedtls_ssl_config,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ssl_session_reset(ssl: *mut mbedtls_ssl_context) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ssl_conf_endpoint(conf: *mut mbedtls_ssl_config, endpoint: ffi::ctypes::c_int);
}
extern "C" {
    pub fn mbedtls_ssl_conf_transport(conf: *mut mbedtls_ssl_config, transport: ffi::ctypes::c_int);
}
extern "C" {
    pub fn mbedtls_ssl_conf_authmode(conf: *mut mbedtls_ssl_config, authmode: ffi::ctypes::c_int);
}
extern "C" {
    pub fn mbedtls_ssl_conf_verify(
        conf: *mut mbedtls_ssl_config,
        f_vrfy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ffi::ctypes::c_void,
                arg2: *mut mbedtls_x509_crt,
                arg3: ffi::ctypes::c_int,
                arg4: *mut u32,
            ) -> ffi::ctypes::c_int,
        >,
        p_vrfy: *mut ffi::ctypes::c_void,
    );
}
extern "C" {
    pub fn mbedtls_ssl_conf_rng(
        conf: *mut mbedtls_ssl_config,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ffi::ctypes::c_void,
                arg2: *mut ffi::ctypes::c_uchar,
                arg3: size_t,
            ) -> ffi::ctypes::c_int,
        >,
        p_rng: *mut ffi::ctypes::c_void,
    );
}
extern "C" {
    pub fn mbedtls_ssl_conf_dbg(
        conf: *mut mbedtls_ssl_config,
        f_dbg: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ffi::ctypes::c_void,
                arg2: ffi::ctypes::c_int,
                arg3: *const ffi::ctypes::c_char,
                arg4: ffi::ctypes::c_int,
                arg5: *const ffi::ctypes::c_char,
            ),
        >,
        p_dbg: *mut ffi::ctypes::c_void,
    );
}
extern "C" {
    pub fn mbedtls_ssl_set_bio(
        ssl: *mut mbedtls_ssl_context,
        p_bio: *mut ffi::ctypes::c_void,
        f_send: mbedtls_ssl_send_t,
        f_recv: mbedtls_ssl_recv_t,
        f_recv_timeout: mbedtls_ssl_recv_timeout_t,
    );
}
extern "C" {
    pub fn mbedtls_ssl_conf_read_timeout(conf: *mut mbedtls_ssl_config, timeout: u32);
}
extern "C" {
    pub fn mbedtls_ssl_set_timer_cb(
        ssl: *mut mbedtls_ssl_context,
        p_timer: *mut ffi::ctypes::c_void,
        f_set_timer: mbedtls_ssl_set_timer_t,
        f_get_timer: mbedtls_ssl_get_timer_t,
    );
}
pub type mbedtls_ssl_ticket_write_t = ::core::option::Option<
    unsafe extern "C" fn(
        p_ticket: *mut ffi::ctypes::c_void,
        session: *const mbedtls_ssl_session,
        start: *mut ffi::ctypes::c_uchar,
        end: *const ffi::ctypes::c_uchar,
        tlen: *mut size_t,
        lifetime: *mut u32,
    ) -> ffi::ctypes::c_int,
>;
pub type mbedtls_ssl_export_keys_t = ::core::option::Option<
    unsafe extern "C" fn(
        p_expkey: *mut ffi::ctypes::c_void,
        ms: *const ffi::ctypes::c_uchar,
        kb: *const ffi::ctypes::c_uchar,
        maclen: size_t,
        keylen: size_t,
        ivlen: size_t,
    ) -> ffi::ctypes::c_int,
>;
pub type mbedtls_ssl_ticket_parse_t = ::core::option::Option<
    unsafe extern "C" fn(
        p_ticket: *mut ffi::ctypes::c_void,
        session: *mut mbedtls_ssl_session,
        buf: *mut ffi::ctypes::c_uchar,
        len: size_t,
    ) -> ffi::ctypes::c_int,
>;
extern "C" {
    pub fn mbedtls_ssl_conf_export_keys_cb(
        conf: *mut mbedtls_ssl_config,
        f_export_keys: mbedtls_ssl_export_keys_t,
        p_export_keys: *mut ffi::ctypes::c_void,
    );
}
pub type mbedtls_ssl_cookie_write_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ffi::ctypes::c_void,
        p: *mut *mut ffi::ctypes::c_uchar,
        end: *mut ffi::ctypes::c_uchar,
        info: *const ffi::ctypes::c_uchar,
        ilen: size_t,
    ) -> ffi::ctypes::c_int,
>;
pub type mbedtls_ssl_cookie_check_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ffi::ctypes::c_void,
        cookie: *const ffi::ctypes::c_uchar,
        clen: size_t,
        info: *const ffi::ctypes::c_uchar,
        ilen: size_t,
    ) -> ffi::ctypes::c_int,
>;
extern "C" {
    pub fn mbedtls_ssl_set_session(
        ssl: *mut mbedtls_ssl_context,
        session: *const mbedtls_ssl_session,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ssl_conf_ciphersuites(
        conf: *mut mbedtls_ssl_config,
        ciphersuites: *const ffi::ctypes::c_int,
    );
}
extern "C" {
    pub fn mbedtls_ssl_conf_ciphersuites_for_version(
        conf: *mut mbedtls_ssl_config,
        ciphersuites: *const ffi::ctypes::c_int,
        major: ffi::ctypes::c_int,
        minor: ffi::ctypes::c_int,
    );
}
extern "C" {
    pub fn mbedtls_ssl_conf_cert_profile(
        conf: *mut mbedtls_ssl_config,
        profile: *const mbedtls_x509_crt_profile,
    );
}
extern "C" {
    pub fn mbedtls_ssl_conf_ca_chain(
        conf: *mut mbedtls_ssl_config,
        ca_chain: *mut mbedtls_x509_crt,
        ca_crl: *mut mbedtls_x509_crl,
    );
}
extern "C" {
    pub fn mbedtls_ssl_conf_own_cert(
        conf: *mut mbedtls_ssl_config,
        own_cert: *mut mbedtls_x509_crt,
        pk_key: *mut mbedtls_pk_context,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ssl_conf_psk(
        conf: *mut mbedtls_ssl_config,
        psk: *const ffi::ctypes::c_uchar,
        psk_len: size_t,
        psk_identity: *const ffi::ctypes::c_uchar,
        psk_identity_len: size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ssl_set_hs_psk(
        ssl: *mut mbedtls_ssl_context,
        psk: *const ffi::ctypes::c_uchar,
        psk_len: size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ssl_conf_psk_cb(
        conf: *mut mbedtls_ssl_config,
        f_psk: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ffi::ctypes::c_void,
                arg2: *mut mbedtls_ssl_context,
                arg3: *const ffi::ctypes::c_uchar,
                arg4: size_t,
            ) -> ffi::ctypes::c_int,
        >,
        p_psk: *mut ffi::ctypes::c_void,
    );
}
extern "C" {
    pub fn mbedtls_ssl_conf_dhm_min_bitlen(
        conf: *mut mbedtls_ssl_config,
        bitlen: ffi::ctypes::c_uint,
    );
}
extern "C" {
    pub fn mbedtls_ssl_conf_curves(
        conf: *mut mbedtls_ssl_config,
        curves: *const mbedtls_ecp_group_id,
    );
}
extern "C" {
    pub fn mbedtls_ssl_conf_sig_hashes(
        conf: *mut mbedtls_ssl_config,
        hashes: *const ffi::ctypes::c_int,
    );
}
extern "C" {
    pub fn mbedtls_ssl_set_hostname(
        ssl: *mut mbedtls_ssl_context,
        hostname: *const ffi::ctypes::c_char,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ssl_set_hs_own_cert(
        ssl: *mut mbedtls_ssl_context,
        own_cert: *mut mbedtls_x509_crt,
        pk_key: *mut mbedtls_pk_context,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ssl_set_hs_ca_chain(
        ssl: *mut mbedtls_ssl_context,
        ca_chain: *mut mbedtls_x509_crt,
        ca_crl: *mut mbedtls_x509_crl,
    );
}
extern "C" {
    pub fn mbedtls_ssl_set_hs_authmode(ssl: *mut mbedtls_ssl_context, authmode: ffi::ctypes::c_int);
}
extern "C" {
    pub fn mbedtls_ssl_conf_sni(
        conf: *mut mbedtls_ssl_config,
        f_sni: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ffi::ctypes::c_void,
                arg2: *mut mbedtls_ssl_context,
                arg3: *const ffi::ctypes::c_uchar,
                arg4: size_t,
            ) -> ffi::ctypes::c_int,
        >,
        p_sni: *mut ffi::ctypes::c_void,
    );
}
extern "C" {
    pub fn mbedtls_ssl_conf_max_version(
        conf: *mut mbedtls_ssl_config,
        major: ffi::ctypes::c_int,
        minor: ffi::ctypes::c_int,
    );
}
extern "C" {
    pub fn mbedtls_ssl_conf_min_version(
        conf: *mut mbedtls_ssl_config,
        major: ffi::ctypes::c_int,
        minor: ffi::ctypes::c_int,
    );
}
extern "C" {
    pub fn mbedtls_ssl_conf_fallback(conf: *mut mbedtls_ssl_config, fallback: ffi::ctypes::c_char);
}
extern "C" {
    pub fn mbedtls_ssl_conf_encrypt_then_mac(
        conf: *mut mbedtls_ssl_config,
        etm: ffi::ctypes::c_char,
    );
}
extern "C" {
    pub fn mbedtls_ssl_conf_extended_master_secret(
        conf: *mut mbedtls_ssl_config,
        ems: ffi::ctypes::c_char,
    );
}
extern "C" {
    pub fn mbedtls_ssl_conf_arc4_support(conf: *mut mbedtls_ssl_config, arc4: ffi::ctypes::c_char);
}
extern "C" {
    pub fn mbedtls_ssl_conf_max_frag_len(
        conf: *mut mbedtls_ssl_config,
        mfl_code: ffi::ctypes::c_uchar,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ssl_conf_truncated_hmac(
        conf: *mut mbedtls_ssl_config,
        truncate: ffi::ctypes::c_int,
    );
}
extern "C" {
    pub fn mbedtls_ssl_conf_cbc_record_splitting(
        conf: *mut mbedtls_ssl_config,
        split: ffi::ctypes::c_char,
    );
}
extern "C" {
    pub fn mbedtls_ssl_conf_session_tickets(
        conf: *mut mbedtls_ssl_config,
        use_tickets: ffi::ctypes::c_int,
    );
}
extern "C" {
    pub fn mbedtls_ssl_conf_renegotiation(
        conf: *mut mbedtls_ssl_config,
        renegotiation: ffi::ctypes::c_int,
    );
}
extern "C" {
    pub fn mbedtls_ssl_conf_legacy_renegotiation(
        conf: *mut mbedtls_ssl_config,
        allow_legacy: ffi::ctypes::c_int,
    );
}
extern "C" {
    pub fn mbedtls_ssl_conf_renegotiation_enforced(
        conf: *mut mbedtls_ssl_config,
        max_records: ffi::ctypes::c_int,
    );
}
extern "C" {
    pub fn mbedtls_ssl_conf_renegotiation_period(
        conf: *mut mbedtls_ssl_config,
        period: *const ffi::ctypes::c_uchar,
    );
}
extern "C" {
    pub fn mbedtls_ssl_get_bytes_avail(ssl: *const mbedtls_ssl_context) -> size_t;
}
extern "C" {
    pub fn mbedtls_ssl_get_verify_result(ssl: *const mbedtls_ssl_context) -> u32;
}
extern "C" {
    pub fn mbedtls_ssl_get_ciphersuite(
        ssl: *const mbedtls_ssl_context,
    ) -> *const ffi::ctypes::c_char;
}
extern "C" {
    pub fn mbedtls_ssl_get_version(ssl: *const mbedtls_ssl_context) -> *const ffi::ctypes::c_char;
}
extern "C" {
    pub fn mbedtls_ssl_get_record_expansion(ssl: *const mbedtls_ssl_context) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ssl_get_max_frag_len(ssl: *const mbedtls_ssl_context) -> size_t;
}
extern "C" {
    pub fn mbedtls_ssl_get_peer_cert(ssl: *const mbedtls_ssl_context) -> *const mbedtls_x509_crt;
}
extern "C" {
    pub fn mbedtls_ssl_get_session(
        ssl: *const mbedtls_ssl_context,
        session: *mut mbedtls_ssl_session,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ssl_handshake(ssl: *mut mbedtls_ssl_context) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ssl_handshake_step(ssl: *mut mbedtls_ssl_context) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ssl_renegotiate(ssl: *mut mbedtls_ssl_context) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ssl_read(
        ssl: *mut mbedtls_ssl_context,
        buf: *mut ffi::ctypes::c_uchar,
        len: size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ssl_write(
        ssl: *mut mbedtls_ssl_context,
        buf: *const ffi::ctypes::c_uchar,
        len: size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ssl_send_alert_message(
        ssl: *mut mbedtls_ssl_context,
        level: ffi::ctypes::c_uchar,
        message: ffi::ctypes::c_uchar,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ssl_close_notify(ssl: *mut mbedtls_ssl_context) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ssl_free(ssl: *mut mbedtls_ssl_context);
}
extern "C" {
    pub fn mbedtls_ssl_config_init(conf: *mut mbedtls_ssl_config);
}
extern "C" {
    pub fn mbedtls_ssl_config_defaults(
        conf: *mut mbedtls_ssl_config,
        endpoint: ffi::ctypes::c_int,
        transport: ffi::ctypes::c_int,
        preset: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_ssl_config_free(conf: *mut mbedtls_ssl_config);
}
extern "C" {
    pub fn mbedtls_ssl_session_init(session: *mut mbedtls_ssl_session);
}
extern "C" {
    pub fn mbedtls_ssl_session_free(session: *mut mbedtls_ssl_session);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mbedtls_net_context {
    pub fd: ffi::ctypes::c_int,
}
extern "C" {
    pub fn mbedtls_net_init(ctx: *mut mbedtls_net_context);
}
extern "C" {
    pub fn mbedtls_net_connect(
        ctx: *mut mbedtls_net_context,
        host: *const ffi::ctypes::c_char,
        port: *const ffi::ctypes::c_char,
        proto: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_net_bind(
        ctx: *mut mbedtls_net_context,
        bind_ip: *const ffi::ctypes::c_char,
        port: *const ffi::ctypes::c_char,
        proto: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_net_accept(
        bind_ctx: *mut mbedtls_net_context,
        client_ctx: *mut mbedtls_net_context,
        client_ip: *mut ffi::ctypes::c_void,
        buf_size: size_t,
        ip_len: *mut size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_net_set_block(ctx: *mut mbedtls_net_context) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_net_set_nonblock(ctx: *mut mbedtls_net_context) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_net_usleep(usec: ffi::ctypes::c_ulong);
}
extern "C" {
    pub fn mbedtls_net_recv(
        ctx: *mut ffi::ctypes::c_void,
        buf: *mut ffi::ctypes::c_uchar,
        len: size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_net_send(
        ctx: *mut ffi::ctypes::c_void,
        buf: *const ffi::ctypes::c_uchar,
        len: size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_net_recv_timeout(
        ctx: *mut ffi::ctypes::c_void,
        buf: *mut ffi::ctypes::c_uchar,
        len: size_t,
        timeout: u32,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn mbedtls_net_free(ctx: *mut mbedtls_net_context);
}
extern "C" {
    pub fn recv_ota_file_hdr_https(
        Recvbuf: *mut u8,
        writelen: u32,
        len: *mut u32,
        pOtaTgtHdr: *mut update_ota_target_hdr,
        ssl: *mut mbedtls_ssl_context,
    ) -> u32;
}
extern "C" {
    pub fn https_read_socket(
        ssl: *mut mbedtls_ssl_context,
        recevie_buf: *mut u8,
        buf_len: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn download_new_fw_from_server_https(
        first_buf: *mut u8,
        firstbuf_len: ffi::ctypes::c_uint,
        ssl: *mut mbedtls_ssl_context,
        pOtaTgtHdr: *mut update_ota_target_hdr,
        targetIdx: u8,
    ) -> u32;
}
extern "C" {
    pub fn https_update_ota(
        host: *mut ffi::ctypes::c_char,
        port: ffi::ctypes::c_int,
        resource: *mut ffi::ctypes::c_char,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn sdcard_update_ota(filename: *mut ffi::ctypes::c_char) -> ffi::ctypes::c_int;
}
pub const PMU_DEVICE_PMU_OS: PMU_DEVICE = 0;
pub const PMU_DEVICE_PMU_WLAN_DEVICE: PMU_DEVICE = 1;
pub const PMU_DEVICE_PMU_LOGUART_DEVICE: PMU_DEVICE = 2;
pub const PMU_DEVICE_PMU_KM4_RUN: PMU_DEVICE = 3;
pub const PMU_DEVICE_PMU_UART0_DEVICE: PMU_DEVICE = 4;
pub const PMU_DEVICE_PMU_UART1_DEVICE: PMU_DEVICE = 5;
pub const PMU_DEVICE_PMU_I2C0_DEVICE: PMU_DEVICE = 6;
pub const PMU_DEVICE_PMU_TOUCH_DEVICE: PMU_DEVICE = 7;
pub const PMU_DEVICE_PMU_USOC_DEVICE: PMU_DEVICE = 8;
pub const PMU_DEVICE_PMU_DONGLE_DEVICE: PMU_DEVICE = 9;
pub const PMU_DEVICE_PMU_RTC_DEVICE: PMU_DEVICE = 10;
pub const PMU_DEVICE_PMU_CONSOL_DEVICE: PMU_DEVICE = 11;
pub const PMU_DEVICE_PMU_ADC_DEVICE: PMU_DEVICE = 12;
pub const PMU_DEVICE_PMU_WAKWLOCK_TIMEOUT: PMU_DEVICE = 13;
pub const PMU_DEVICE_PMU_KEYSCAN_DEVICE: PMU_DEVICE = 14;
pub const PMU_DEVICE_PMU_PSRAM_DEVICE: PMU_DEVICE = 15;
pub const PMU_DEVICE_PMU_DEV_USER_BASE: PMU_DEVICE = 16;
pub const PMU_DEVICE_PMU_MAX: PMU_DEVICE = 31;
pub type PMU_DEVICE = ffi::ctypes::c_uint;
pub const SLEEP_TYPE_SLEEP_PG: SLEEP_TYPE = 0;
pub const SLEEP_TYPE_SLEEP_CG: SLEEP_TYPE = 1;
pub type SLEEP_TYPE = ffi::ctypes::c_uint;
pub type PSM_HOOK_FUN = ::core::option::Option<
    unsafe extern "C" fn(arg1: ffi::ctypes::c_uint, param_ptr: *mut ffi::ctypes::c_void) -> u32,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PSM_DD_HOOK_INFO {
    pub nDeviceId: u32,
    pub sleep_hook_fun: PSM_HOOK_FUN,
    pub sleep_param_ptr: *mut ffi::ctypes::c_void,
    pub wakeup_hook_fun: PSM_HOOK_FUN,
    pub wakeup_param_ptr: *mut ffi::ctypes::c_void,
}
impl Default for PSM_DD_HOOK_INFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn pmu_yield_os_check() -> u32;
}
extern "C" {
    pub fn pmu_exec_sleep_hook_funs() -> u32;
}
extern "C" {
    pub fn pmu_exec_wakeup_hook_funs(nDeviceIdMax: u32);
}
extern "C" {
    pub fn pmu_set_sleep_type(type_: u32) -> u32;
}
extern "C" {
    pub fn pmu_get_sleep_type() -> u32;
}
extern "C" {
    pub fn pmu_set_max_sleep_time(timer_ms: u32);
}
extern "C" {
    pub fn pmu_deepsleep_cmd(NewStatus: u32);
}
extern "C" {
    pub fn pmu_tickless_debug(NewStatus: u32);
}
extern "C" {
    pub fn pmu_set_dsleep_active_time(TimeOutMs: u32);
}
extern "C" {
    pub fn pmu_acquire_deepwakelock(nDeviceId: u32);
}
extern "C" {
    pub fn pmu_release_deepwakelock(nDeviceId: u32);
}
extern "C" {
    pub fn pmu_set_dev_wakeup_tick(nDeviceId: u32, Ms: u32);
}
extern "C" {
    pub fn pmu_set_sysactive_time(timeout: u32) -> u32;
}
extern "C" {
    pub fn pmu_register_sleep_callback(
        nDeviceId: u32,
        sleep_hook_fun: PSM_HOOK_FUN,
        sleep_param_ptr: *mut ffi::ctypes::c_void,
        wakeup_hook_fun: PSM_HOOK_FUN,
        wakeup_param_ptr: *mut ffi::ctypes::c_void,
    );
}
extern "C" {
    pub fn pmu_unregister_sleep_callback(nDeviceId: u32);
}
extern "C" {
    pub fn freertos_ready_to_dsleep() -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn pmu_acquire_wakelock(nDeviceId: u32);
}
extern "C" {
    pub fn pmu_release_wakelock(nDeviceId: u32);
}
extern "C" {
    pub fn pmu_get_wakelock_status() -> u32;
}
extern "C" {
    pub fn pmu_get_deepwakelock_status() -> u32;
}
extern "C" {
    pub static mut tickless_debug: u32;
}
extern "C" {
    pub static mut tick_last_tcp: u32;
}
extern "C" {
    pub fn pmu_add_wakeup_event(event: u32);
}
extern "C" {
    pub fn pmu_del_wakeup_event(event: u32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xLIST_ITEM {
    pub xItemValue: TickType_t,
    pub pxNext: *mut xLIST_ITEM,
    pub pxPrevious: *mut xLIST_ITEM,
    pub pvOwner: *mut ffi::ctypes::c_void,
    pub pvContainer: *mut xLIST,
}
impl Default for xLIST_ITEM {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type ListItem_t = xLIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xMINI_LIST_ITEM {
    pub xItemValue: TickType_t,
    pub pxNext: *mut xLIST_ITEM,
    pub pxPrevious: *mut xLIST_ITEM,
}
impl Default for xMINI_LIST_ITEM {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type MiniListItem_t = xMINI_LIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xLIST {
    pub uxNumberOfItems: UBaseType_t,
    pub pxIndex: *mut ListItem_t,
    pub xListEnd: MiniListItem_t,
}
impl Default for xLIST {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type List_t = xLIST;
extern "C" {
    pub fn vListInitialise(pxList: *mut List_t);
}
extern "C" {
    pub fn vListInitialiseItem(pxItem: *mut ListItem_t);
}
extern "C" {
    pub fn vListInsert(pxList: *mut List_t, pxNewListItem: *mut ListItem_t);
}
extern "C" {
    pub fn vListInsertEnd(pxList: *mut List_t, pxNewListItem: *mut ListItem_t);
}
extern "C" {
    pub fn uxListRemove(pxItemToRemove: *mut ListItem_t) -> UBaseType_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tskTaskControlBlock {
    _unused: [u8; 0],
}
pub type TaskHandle_t = *mut tskTaskControlBlock;
pub type TaskHookFunction_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ffi::ctypes::c_void) -> BaseType_t>;
pub const eTaskState_eRunning: eTaskState = 0;
pub const eTaskState_eReady: eTaskState = 1;
pub const eTaskState_eBlocked: eTaskState = 2;
pub const eTaskState_eSuspended: eTaskState = 3;
pub const eTaskState_eDeleted: eTaskState = 4;
pub const eTaskState_eInvalid: eTaskState = 5;
pub type eTaskState = ffi::ctypes::c_uint;
pub const eNotifyAction_eNoAction: eNotifyAction = 0;
pub const eNotifyAction_eSetBits: eNotifyAction = 1;
pub const eNotifyAction_eIncrement: eNotifyAction = 2;
pub const eNotifyAction_eSetValueWithOverwrite: eNotifyAction = 3;
pub const eNotifyAction_eSetValueWithoutOverwrite: eNotifyAction = 4;
pub type eNotifyAction = ffi::ctypes::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct xTIME_OUT {
    pub xOverflowCount: BaseType_t,
    pub xTimeOnEntering: TickType_t,
}
pub type TimeOut_t = xTIME_OUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xMEMORY_REGION {
    pub pvBaseAddress: *mut ffi::ctypes::c_void,
    pub ulLengthInBytes: u32,
    pub ulParameters: u32,
}
impl Default for xMEMORY_REGION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type MemoryRegion_t = xMEMORY_REGION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xTASK_PARAMETERS {
    pub pvTaskCode: TaskFunction_t,
    pub pcName: *const ffi::ctypes::c_char,
    pub usStackDepth: u16,
    pub pvParameters: *mut ffi::ctypes::c_void,
    pub uxPriority: UBaseType_t,
    pub puxStackBuffer: *mut StackType_t,
    pub xRegions: [MemoryRegion_t; 3usize],
}
impl Default for xTASK_PARAMETERS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type TaskParameters_t = xTASK_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xTASK_STATUS {
    pub xHandle: TaskHandle_t,
    pub pcTaskName: *const ffi::ctypes::c_char,
    pub xTaskNumber: UBaseType_t,
    pub eCurrentState: eTaskState,
    pub uxCurrentPriority: UBaseType_t,
    pub uxBasePriority: UBaseType_t,
    pub ulRunTimeCounter: u32,
    pub pxStackBase: *mut StackType_t,
    pub usStackHighWaterMark: u16,
}
impl Default for xTASK_STATUS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type TaskStatus_t = xTASK_STATUS;
pub const eSleepModeStatus_eAbortSleep: eSleepModeStatus = 0;
pub const eSleepModeStatus_eStandardSleep: eSleepModeStatus = 1;
pub const eSleepModeStatus_eNoTasksWaitingTimeout: eSleepModeStatus = 2;
pub type eSleepModeStatus = ffi::ctypes::c_uint;
extern "C" {
    pub fn xTaskCreate(
        pxTaskCode: TaskFunction_t,
        pcName: *const ffi::ctypes::c_char,
        usStackDepth: u16,
        pvParameters: *mut ffi::ctypes::c_void,
        uxPriority: UBaseType_t,
        pxCreatedTask: *mut TaskHandle_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn vTaskAllocateMPURegions(xTask: TaskHandle_t, pxRegions: *const MemoryRegion_t);
}
extern "C" {
    pub fn vTaskDelete(xTaskToDelete: TaskHandle_t);
}
extern "C" {
    pub fn vTaskDelay(xTicksToDelay: TickType_t);
}
extern "C" {
    pub fn vTaskDelayUntil(pxPreviousWakeTime: *mut TickType_t, xTimeIncrement: TickType_t);
}
extern "C" {
    pub fn xTaskAbortDelay(xTask: TaskHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn uxTaskPriorityGet(xTask: TaskHandle_t) -> UBaseType_t;
}
extern "C" {
    pub fn uxTaskPriorityGetFromISR(xTask: TaskHandle_t) -> UBaseType_t;
}
extern "C" {
    pub fn eTaskGetState(xTask: TaskHandle_t) -> eTaskState;
}
extern "C" {
    pub fn vTaskGetInfo(
        xTask: TaskHandle_t,
        pxTaskStatus: *mut TaskStatus_t,
        xGetFreeStackSpace: BaseType_t,
        eState: eTaskState,
    );
}
extern "C" {
    pub fn vTaskPrioritySet(xTask: TaskHandle_t, uxNewPriority: UBaseType_t);
}
extern "C" {
    pub fn vTaskSuspend(xTaskToSuspend: TaskHandle_t);
}
extern "C" {
    pub fn vTaskResume(xTaskToResume: TaskHandle_t);
}
extern "C" {
    pub fn xTaskResumeFromISR(xTaskToResume: TaskHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn vTaskStartScheduler();
}
extern "C" {
    pub fn vTaskEndScheduler();
}
extern "C" {
    pub fn vTaskSuspendAll();
}
extern "C" {
    pub fn xTaskResumeAll() -> BaseType_t;
}
extern "C" {
    pub fn xTaskGetTickCount() -> TickType_t;
}
extern "C" {
    pub fn xTaskGetTickCountFromISR() -> TickType_t;
}
extern "C" {
    pub fn uxTaskGetNumberOfTasks() -> UBaseType_t;
}
extern "C" {
    pub fn pcTaskGetName(xTaskToQuery: TaskHandle_t) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn xTaskGetHandle(pcNameToQuery: *const ffi::ctypes::c_char) -> TaskHandle_t;
}
extern "C" {
    pub fn uxTaskGetStackHighWaterMark(xTask: TaskHandle_t) -> UBaseType_t;
}
extern "C" {
    pub fn uxTaskGetStackHighWaterMark2(xTask: TaskHandle_t) -> u16;
}
extern "C" {
    pub fn xTaskCallApplicationTaskHook(
        xTask: TaskHandle_t,
        pvParameter: *mut ffi::ctypes::c_void,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xTaskGetIdleTaskHandle() -> TaskHandle_t;
}
extern "C" {
    pub fn uxTaskGetSystemState(
        pxTaskStatusArray: *mut TaskStatus_t,
        uxArraySize: UBaseType_t,
        pulTotalRunTime: *mut u32,
    ) -> UBaseType_t;
}
extern "C" {
    pub fn vTaskList(pcWriteBuffer: *mut ffi::ctypes::c_char);
}
extern "C" {
    pub fn vTaskGetRunTimeStats(pcWriteBuffer: *mut ffi::ctypes::c_char);
}
extern "C" {
    pub fn xTaskGetIdleRunTimeCounter() -> TickType_t;
}
extern "C" {
    pub fn xTaskGenericNotify(
        xTaskToNotify: TaskHandle_t,
        ulValue: u32,
        eAction: eNotifyAction,
        pulPreviousNotificationValue: *mut u32,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xTaskGenericNotifyFromISR(
        xTaskToNotify: TaskHandle_t,
        ulValue: u32,
        eAction: eNotifyAction,
        pulPreviousNotificationValue: *mut u32,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xTaskNotifyWait(
        ulBitsToClearOnEntry: u32,
        ulBitsToClearOnExit: u32,
        pulNotificationValue: *mut u32,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn vTaskNotifyGiveFromISR(
        xTaskToNotify: TaskHandle_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    );
}
extern "C" {
    pub fn ulTaskNotifyTake(xClearCountOnExit: BaseType_t, xTicksToWait: TickType_t) -> u32;
}
extern "C" {
    pub fn xTaskNotifyStateClear(xTask: TaskHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn xTaskIncrementTick() -> BaseType_t;
}
extern "C" {
    pub fn vTaskPlaceOnEventList(pxEventList: *mut List_t, xTicksToWait: TickType_t);
}
extern "C" {
    pub fn vTaskPlaceOnUnorderedEventList(
        pxEventList: *mut List_t,
        xItemValue: TickType_t,
        xTicksToWait: TickType_t,
    );
}
extern "C" {
    pub fn vTaskPlaceOnEventListRestricted(
        pxEventList: *mut List_t,
        xTicksToWait: TickType_t,
        xWaitIndefinitely: BaseType_t,
    );
}
extern "C" {
    pub fn xTaskRemoveFromEventList(pxEventList: *const List_t) -> BaseType_t;
}
extern "C" {
    pub fn vTaskRemoveFromUnorderedEventList(
        pxEventListItem: *mut ListItem_t,
        xItemValue: TickType_t,
    );
}
extern "C" {
    pub fn vTaskSwitchContext();
}
extern "C" {
    pub fn uxTaskResetEventItemValue() -> TickType_t;
}
extern "C" {
    pub fn xTaskGetCurrentTaskHandle() -> TaskHandle_t;
}
extern "C" {
    pub fn vTaskSetTimeOutState(pxTimeOut: *mut TimeOut_t);
}
extern "C" {
    pub fn xTaskCheckForTimeOut(
        pxTimeOut: *mut TimeOut_t,
        pxTicksToWait: *mut TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn vTaskMissedYield();
}
extern "C" {
    pub fn xTaskGetSchedulerState() -> BaseType_t;
}
extern "C" {
    pub fn xTaskPriorityInherit(pxMutexHolder: TaskHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn xTaskPriorityDisinherit(pxMutexHolder: TaskHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn vTaskPriorityDisinheritAfterTimeout(
        pxMutexHolder: TaskHandle_t,
        uxHighestPriorityWaitingTask: UBaseType_t,
    );
}
extern "C" {
    pub fn uxTaskGetTaskNumber(xTask: TaskHandle_t) -> UBaseType_t;
}
extern "C" {
    pub fn vTaskSetTaskNumber(xTask: TaskHandle_t, uxHandle: UBaseType_t);
}
extern "C" {
    pub fn vTaskStepTick(xTicksToJump: TickType_t);
}
extern "C" {
    pub fn eTaskConfirmSleepModeStatus() -> eSleepModeStatus;
}
extern "C" {
    pub fn pvTaskIncrementMutexHeldCount() -> TaskHandle_t;
}
extern "C" {
    pub fn vTaskInternalSetTimeOutState(pxTimeOut: *mut TimeOut_t);
}
extern "C" {
    pub fn vTaskStackAddr() -> *mut u32;
}
extern "C" {
    pub fn vTaskStackTOPAddr() -> *mut u32;
}
extern "C" {
    pub fn vTaskStackSize() -> u32;
}
extern "C" {
    pub fn vTaskName() -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn os_heap_init();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QueueDefinition {
    _unused: [u8; 0],
}
pub type QueueHandle_t = *mut QueueDefinition;
pub type QueueSetHandle_t = *mut QueueDefinition;
pub type QueueSetMemberHandle_t = *mut QueueDefinition;
extern "C" {
    pub fn xQueueGenericSend(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const ffi::ctypes::c_void,
        xTicksToWait: TickType_t,
        xCopyPosition: BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueuePeek(
        xQueue: QueueHandle_t,
        pvBuffer: *mut ffi::ctypes::c_void,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueuePeekFromISR(
        xQueue: QueueHandle_t,
        pvBuffer: *mut ffi::ctypes::c_void,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueReceive(
        xQueue: QueueHandle_t,
        pvBuffer: *mut ffi::ctypes::c_void,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn uxQueueMessagesWaiting(xQueue: QueueHandle_t) -> UBaseType_t;
}
extern "C" {
    pub fn uxQueueSpacesAvailable(xQueue: QueueHandle_t) -> UBaseType_t;
}
extern "C" {
    pub fn vQueueDelete(xQueue: QueueHandle_t);
}
extern "C" {
    pub fn xQueueGenericSendFromISR(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const ffi::ctypes::c_void,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
        xCopyPosition: BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueGiveFromISR(
        xQueue: QueueHandle_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueReceiveFromISR(
        xQueue: QueueHandle_t,
        pvBuffer: *mut ffi::ctypes::c_void,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueIsQueueEmptyFromISR(xQueue: QueueHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn xQueueIsQueueFullFromISR(xQueue: QueueHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn uxQueueMessagesWaitingFromISR(xQueue: QueueHandle_t) -> UBaseType_t;
}
extern "C" {
    pub fn xQueueCRSendFromISR(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const ffi::ctypes::c_void,
        xCoRoutinePreviouslyWoken: BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueCRReceiveFromISR(
        xQueue: QueueHandle_t,
        pvBuffer: *mut ffi::ctypes::c_void,
        pxTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueCRSend(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const ffi::ctypes::c_void,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueCRReceive(
        xQueue: QueueHandle_t,
        pvBuffer: *mut ffi::ctypes::c_void,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueCreateMutex(ucQueueType: u8) -> QueueHandle_t;
}
extern "C" {
    pub fn xQueueCreateMutexStatic(
        ucQueueType: u8,
        pxStaticQueue: *mut StaticQueue_t,
    ) -> QueueHandle_t;
}
extern "C" {
    pub fn xQueueCreateCountingSemaphore(
        uxMaxCount: UBaseType_t,
        uxInitialCount: UBaseType_t,
    ) -> QueueHandle_t;
}
extern "C" {
    pub fn xQueueCreateCountingSemaphoreStatic(
        uxMaxCount: UBaseType_t,
        uxInitialCount: UBaseType_t,
        pxStaticQueue: *mut StaticQueue_t,
    ) -> QueueHandle_t;
}
extern "C" {
    pub fn xQueueSemaphoreTake(xQueue: QueueHandle_t, xTicksToWait: TickType_t) -> BaseType_t;
}
extern "C" {
    pub fn xQueueGetMutexHolder(xSemaphore: QueueHandle_t) -> TaskHandle_t;
}
extern "C" {
    pub fn xQueueGetMutexHolderFromISR(xSemaphore: QueueHandle_t) -> TaskHandle_t;
}
extern "C" {
    pub fn xQueueTakeMutexRecursive(xMutex: QueueHandle_t, xTicksToWait: TickType_t) -> BaseType_t;
}
extern "C" {
    pub fn xQueueGiveMutexRecursive(xMutex: QueueHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn xQueueGenericCreate(
        uxQueueLength: UBaseType_t,
        uxItemSize: UBaseType_t,
        ucQueueType: u8,
    ) -> QueueHandle_t;
}
extern "C" {
    pub fn xQueueCreateSet(uxEventQueueLength: UBaseType_t) -> QueueSetHandle_t;
}
extern "C" {
    pub fn xQueueAddToSet(
        xQueueOrSemaphore: QueueSetMemberHandle_t,
        xQueueSet: QueueSetHandle_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueRemoveFromSet(
        xQueueOrSemaphore: QueueSetMemberHandle_t,
        xQueueSet: QueueSetHandle_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueSelectFromSet(
        xQueueSet: QueueSetHandle_t,
        xTicksToWait: TickType_t,
    ) -> QueueSetMemberHandle_t;
}
extern "C" {
    pub fn xQueueSelectFromSetFromISR(xQueueSet: QueueSetHandle_t) -> QueueSetMemberHandle_t;
}
extern "C" {
    pub fn vQueueWaitForMessageRestricted(
        xQueue: QueueHandle_t,
        xTicksToWait: TickType_t,
        xWaitIndefinitely: BaseType_t,
    );
}
extern "C" {
    pub fn xQueueGenericReset(xQueue: QueueHandle_t, xNewQueue: BaseType_t) -> BaseType_t;
}
extern "C" {
    pub fn vQueueSetQueueNumber(xQueue: QueueHandle_t, uxQueueNumber: UBaseType_t);
}
extern "C" {
    pub fn uxQueueGetQueueNumber(xQueue: QueueHandle_t) -> UBaseType_t;
}
extern "C" {
    pub fn ucQueueGetQueueType(xQueue: QueueHandle_t) -> u8;
}
pub type SemaphoreHandle_t = QueueHandle_t;
pub const PortName_PortA: PortName = 0;
pub const PortName_PortB: PortName = 1;
pub type PortName = ffi::ctypes::c_uint;
pub const UARTName_UART_0: UARTName = 1073758208;
pub const UARTName_UART_1: UARTName = 1073782784;
pub const UARTName_UART_2: UARTName = 1208033280;
pub const UARTName_UART_3: UARTName = 1208016896;
pub type UARTName = ffi::ctypes::c_uint;
pub const ADCName_ADC0_0: ADCName = 0;
pub const ADCName_ADC0_1: ADCName = 1;
pub const ADCName_ADC0_2: ADCName = 2;
pub const ADCName_ADC0_3: ADCName = 3;
pub type ADCName = ffi::ctypes::c_uint;
pub const SPIName_SPI_0: SPIName = 1074233344;
pub const SPIName_SPI_1: SPIName = 1073799168;
pub type SPIName = ffi::ctypes::c_uint;
pub const I2CName_I2C_0: I2CName = 1208008704;
pub type I2CName = ffi::ctypes::c_uint;
pub const PWMName_PWM_0: PWMName = 1;
pub const PWMName_PWM_1: PWMName = 2;
pub const PWMName_PWM_2: PWMName = 3;
pub const PWMName_PWM_3: PWMName = 4;
pub const PWMName_PWM_4: PWMName = 5;
pub const PWMName_PWM_5: PWMName = 6;
pub type PWMName = ffi::ctypes::c_uint;
pub const GPIO_PORT_PORT_A: GPIO_PORT = 0;
pub const GPIO_PORT_PORT_B: GPIO_PORT = 1;
pub type GPIO_PORT = ffi::ctypes::c_uint;
pub const PinDirection_PIN_INPUT: PinDirection = 0;
pub const PinDirection_PIN_OUTPUT: PinDirection = 1;
pub type PinDirection = ffi::ctypes::c_uint;
pub const PinName_PA_0: PinName = 0;
pub const PinName_PA_1: PinName = 1;
pub const PinName_PA_2: PinName = 2;
pub const PinName_PA_3: PinName = 3;
pub const PinName_PA_4: PinName = 4;
pub const PinName_PA_5: PinName = 5;
pub const PinName_PA_6: PinName = 6;
pub const PinName_PA_7: PinName = 7;
pub const PinName_PA_8: PinName = 8;
pub const PinName_PA_9: PinName = 9;
pub const PinName_PA_10: PinName = 10;
pub const PinName_PA_11: PinName = 11;
pub const PinName_PA_12: PinName = 12;
pub const PinName_PA_13: PinName = 13;
pub const PinName_PA_14: PinName = 14;
pub const PinName_PA_15: PinName = 15;
pub const PinName_PA_16: PinName = 16;
pub const PinName_PA_17: PinName = 17;
pub const PinName_PA_18: PinName = 18;
pub const PinName_PA_19: PinName = 19;
pub const PinName_PA_20: PinName = 20;
pub const PinName_PA_21: PinName = 21;
pub const PinName_PA_22: PinName = 22;
pub const PinName_PA_23: PinName = 23;
pub const PinName_PA_24: PinName = 24;
pub const PinName_PA_25: PinName = 25;
pub const PinName_PA_26: PinName = 26;
pub const PinName_PA_27: PinName = 27;
pub const PinName_PA_28: PinName = 28;
pub const PinName_PA_29: PinName = 29;
pub const PinName_PA_30: PinName = 30;
pub const PinName_PA_31: PinName = 31;
pub const PinName_PB_0: PinName = 32;
pub const PinName_PB_1: PinName = 33;
pub const PinName_PB_2: PinName = 34;
pub const PinName_PB_3: PinName = 35;
pub const PinName_PB_4: PinName = 36;
pub const PinName_PB_5: PinName = 37;
pub const PinName_PB_6: PinName = 38;
pub const PinName_PB_7: PinName = 39;
pub const PinName_PB_8: PinName = 40;
pub const PinName_PB_9: PinName = 41;
pub const PinName_PB_10: PinName = 42;
pub const PinName_PB_11: PinName = 43;
pub const PinName_PB_12: PinName = 44;
pub const PinName_PB_13: PinName = 45;
pub const PinName_PB_14: PinName = 46;
pub const PinName_PB_15: PinName = 47;
pub const PinName_PB_16: PinName = 48;
pub const PinName_PB_17: PinName = 49;
pub const PinName_PB_18: PinName = 50;
pub const PinName_PB_19: PinName = 51;
pub const PinName_PB_20: PinName = 52;
pub const PinName_PB_21: PinName = 53;
pub const PinName_PB_22: PinName = 54;
pub const PinName_PB_23: PinName = 55;
pub const PinName_PB_24: PinName = 56;
pub const PinName_PB_25: PinName = 57;
pub const PinName_PB_26: PinName = 58;
pub const PinName_PB_27: PinName = 59;
pub const PinName_PB_28: PinName = 60;
pub const PinName_PB_29: PinName = 61;
pub const PinName_PB_30: PinName = 62;
pub const PinName_PB_31: PinName = 63;
pub const PinName_VBAT_MEAS: PinName = 226;
pub const PinName_AD_0: PinName = 36;
pub const PinName_AD_1: PinName = 37;
pub const PinName_AD_2: PinName = 38;
pub const PinName_AD_3: PinName = 39;
pub const PinName_AD_4: PinName = 33;
pub const PinName_AD_5: PinName = 34;
pub const PinName_AD_6: PinName = 35;
pub const PinName_AD_7: PinName = 226;
pub const PinName_NC: PinName = 4294967295;
pub type PinName = ffi::ctypes::c_uint;
pub const PinMode_PullNone: PinMode = 0;
pub const PinMode_PullUp: PinMode = 1;
pub const PinMode_PullDown: PinMode = 2;
pub const PinMode_PullDefault: PinMode = 0;
pub type PinMode = ffi::ctypes::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gpio_irq_s {
    pub pin: PinName,
}
impl Default for gpio_irq_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type gpio_irq_t = gpio_irq_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gpio_s {
    pub pin: PinName,
}
impl Default for gpio_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type gpio_t = gpio_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct port_s {
    pub port: PortName,
    pub mask: u32,
}
impl Default for port_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct serial_s {
    pub uart_idx: u8,
    pub tx_len: u32,
    pub rx_len: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct spi_s {
    pub spi_idx: u32,
    pub irq_handler: u32,
    pub irq_id: u32,
    pub state: u32,
    pub sclk: u8,
    pub bus_tx_done_handler: u32,
    pub bus_tx_done_irq_id: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pwmout_s {
    pub pwm_idx: u8,
    pub period: u32,
    pub pulse: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct i2c_s {
    pub i2c_idx: u32,
    pub I2Cx: *mut I2C_TypeDef,
    pub usi_i2c_idx: u32,
    pub USI_I2Cx: *mut USI_TypeDef,
}
impl Default for i2c_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct flash_s {
    pub SpicInitPara: FLASH_InitTypeDef,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct analogin_s {
    pub adc_idx: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gtimer_s {
    pub handler: *mut ffi::ctypes::c_void,
    pub hid: u32,
    pub timer_id: u8,
    pub is_periodcal: u8,
}
impl Default for gtimer_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct i2s_s {
    pub i2s_idx: u8,
    pub sampling_rate: u8,
    pub channel_num: u8,
    pub word_length: u8,
    pub direction: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct gdma_s {
    pub index: u8,
    pub ch_num: u8,
    pub user_cb: IRQ_FUN,
    pub user_cb_data: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct captouch_s {
    pub CT_Channel: [CapTouch_CHInitTypeDef; 4usize],
    pub irq_handler_press: *mut ffi::ctypes::c_void,
    pub irq_handler_release: *mut ffi::ctypes::c_void,
}
impl Default for captouch_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct keyscan_s {
    pub row: u32,
    pub col: u32,
    pub clk: u32,
    pub workmode: u32,
    pub keylimit: u32,
    pub overctrl: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lcdc_s {
    pub lcdc_type: u32,
    pub lcdc_if: lcdc_s__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lcdc_s__bindgen_ty_1 {
    pub LCDC_MCUInitStruct: LCDC_MCUInitTypeDef,
    pub LCDC_RGBInitStruct: LCDC_RGBInitTypeDef,
    pub LCDC_LEDInitStruct: LCDC_LEDInitTypeDef,
    _bindgen_union_align: [u32; 20usize],
}
impl Default for lcdc_s__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for lcdc_s__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "lcdc_s__bindgen_ty_1 {{ union }}")
    }
}
impl Default for lcdc_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for lcdc_s {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "lcdc_s {{ lcdc_type: {:?}, lcdc_if: {:?} }}",
            self.lcdc_type, self.lcdc_if
        )
    }
}
pub const SerialParity_ParityNone: SerialParity = 0;
pub const SerialParity_ParityOdd: SerialParity = 1;
pub const SerialParity_ParityEven: SerialParity = 2;
pub const SerialParity_ParityForced1: SerialParity = 3;
pub const SerialParity_ParityForced0: SerialParity = 4;
pub type SerialParity = ffi::ctypes::c_uint;
pub const SerialIrq_RxIrq: SerialIrq = 0;
pub const SerialIrq_TxIrq: SerialIrq = 1;
pub type SerialIrq = ffi::ctypes::c_uint;
pub const FlowControl_FlowControlNone: FlowControl = 0;
pub const FlowControl_FlowControlRTS: FlowControl = 1;
pub const FlowControl_FlowControlCTS: FlowControl = 2;
pub const FlowControl_FlowControlRTSCTS: FlowControl = 3;
pub type FlowControl = ffi::ctypes::c_uint;
pub type uart_irq_handler = ::core::option::Option<unsafe extern "C" fn(id: u32, event: SerialIrq)>;
pub type serial_t = serial_s;
extern "C" {
    pub fn serial_init(obj: *mut serial_t, tx: PinName, rx: PinName);
}
extern "C" {
    pub fn serial_free(obj: *mut serial_t);
}
extern "C" {
    pub fn serial_baud(obj: *mut serial_t, baudrate: ffi::ctypes::c_int);
}
extern "C" {
    pub fn serial_format(
        obj: *mut serial_t,
        data_bits: ffi::ctypes::c_int,
        parity: SerialParity,
        stop_bits: ffi::ctypes::c_int,
    );
}
extern "C" {
    pub fn serial_irq_handler(obj: *mut serial_t, handler: uart_irq_handler, id: u32);
}
extern "C" {
    pub fn serial_irq_set(obj: *mut serial_t, irq: SerialIrq, enable: u32);
}
extern "C" {
    pub fn serial_getc(obj: *mut serial_t) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn serial_putc(obj: *mut serial_t, c: ffi::ctypes::c_int);
}
extern "C" {
    pub fn serial_readable(obj: *mut serial_t) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn serial_writable(obj: *mut serial_t) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn serial_clear(obj: *mut serial_t);
}
extern "C" {
    pub fn serial_break_set(obj: *mut serial_t);
}
extern "C" {
    pub fn serial_break_clear(obj: *mut serial_t);
}
extern "C" {
    pub fn serial_pinout_tx(tx: PinName);
}
extern "C" {
    pub fn serial_set_flow_control(
        obj: *mut serial_t,
        type_: FlowControl,
        rxflow: PinName,
        txflow: PinName,
    );
}
extern "C" {
    pub fn serial_rts_control(obj: *mut serial_t, rts_state: BOOLEAN);
}
extern "C" {
    pub fn gpio_init(obj: *mut gpio_t, pin: PinName);
}
extern "C" {
    pub fn gpio_set(pin: PinName) -> u32;
}
extern "C" {
    pub fn gpio_mode(obj: *mut gpio_t, mode: PinMode);
}
extern "C" {
    pub fn gpio_dir(obj: *mut gpio_t, direction: PinDirection);
}
extern "C" {
    pub fn gpio_write(obj: *mut gpio_t, value: ffi::ctypes::c_int);
}
extern "C" {
    pub fn gpio_read(obj: *mut gpio_t) -> ffi::ctypes::c_int;
}
pub type i2c_t = i2c_s;
pub const I2C_ERROR_NO_SLAVE: ffi::ctypes::c_int = -1;
pub const I2C_ERROR_BUS_BUSY: ffi::ctypes::c_int = -2;
pub type _bindgen_ty_2 = ffi::ctypes::c_int;
extern "C" {
    pub fn i2c_init(obj: *mut i2c_t, sda: PinName, scl: PinName);
}
extern "C" {
    pub fn i2c_frequency(obj: *mut i2c_t, hz: ffi::ctypes::c_int);
}
extern "C" {
    pub fn i2c_start(obj: *mut i2c_t) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn i2c_stop(obj: *mut i2c_t) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn i2c_reset(obj: *mut i2c_t);
}
extern "C" {
    pub fn i2c_byte_read(obj: *mut i2c_t, last: ffi::ctypes::c_int) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn i2c_byte_write(obj: *mut i2c_t, data: ffi::ctypes::c_int) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn i2c_slave_mode(obj: *mut i2c_t, enable_slave: ffi::ctypes::c_int);
}
extern "C" {
    pub fn i2c_slave_receive(obj: *mut i2c_t) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn i2c_slave_address(obj: *mut i2c_t, idx: ffi::ctypes::c_int, address: u32, mask: u32);
}
extern "C" {
    pub fn i2c_read(
        obj: *mut i2c_t,
        address: ffi::ctypes::c_int,
        data: *mut ffi::ctypes::c_char,
        length: ffi::ctypes::c_int,
        stop: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn i2c_write(
        obj: *mut i2c_t,
        address: ffi::ctypes::c_int,
        data: *const ffi::ctypes::c_char,
        length: ffi::ctypes::c_int,
        stop: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn i2c_slave_read(
        obj: *mut i2c_t,
        data: *mut ffi::ctypes::c_char,
        length: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn i2c_slave_write(
        obj: *mut i2c_t,
        data: *const ffi::ctypes::c_char,
        length: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn i2c_slave_set_for_rd_req(obj: *mut i2c_t, set: ffi::ctypes::c_int)
        -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn i2c_slave_set_for_data_nak(
        obj: *mut i2c_t,
        set_nak: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn i2c_repeatread(
        obj: *mut i2c_t,
        address: ffi::ctypes::c_int,
        pWriteBuf: *mut u8,
        Writelen: ffi::ctypes::c_int,
        pReadBuf: *mut u8,
        Readlen: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
pub type pwmout_t = pwmout_s;
extern "C" {
    pub fn pwmout_init(obj: *mut pwmout_t, pin: PinName);
}
extern "C" {
    pub fn pwmout_free(obj: *mut pwmout_t);
}
extern "C" {
    pub fn pwmout_write(obj: *mut pwmout_t, percent: f32);
}
extern "C" {
    pub fn pwmout_read(obj: *mut pwmout_t) -> f32;
}
extern "C" {
    pub fn pwmout_period(obj: *mut pwmout_t, seconds: f32);
}
extern "C" {
    pub fn pwmout_period_ms(obj: *mut pwmout_t, ms: ffi::ctypes::c_int);
}
extern "C" {
    pub fn pwmout_period_us(obj: *mut pwmout_t, us: ffi::ctypes::c_int);
}
extern "C" {
    pub fn pwmout_pulsewidth(obj: *mut pwmout_t, seconds: f32);
}
extern "C" {
    pub fn pwmout_pulsewidth_ms(obj: *mut pwmout_t, ms: ffi::ctypes::c_int);
}
extern "C" {
    pub fn pwmout_pulsewidth_us(obj: *mut pwmout_t, us: ffi::ctypes::c_int);
}
pub const MBED_SPI_IDX_MBED_SPI0: MBED_SPI_IDX = 240;
pub const MBED_SPI_IDX_MBED_SPI1: MBED_SPI_IDX = 241;
pub type MBED_SPI_IDX = ffi::ctypes::c_uint;
pub type spi_t = spi_s;
extern "C" {
    pub fn spi_init(obj: *mut spi_t, mosi: PinName, miso: PinName, sclk: PinName, ssel: PinName);
}
extern "C" {
    pub fn spi_free(obj: *mut spi_t);
}
extern "C" {
    pub fn spi_format(
        obj: *mut spi_t,
        bits: ffi::ctypes::c_int,
        mode: ffi::ctypes::c_int,
        slave: ffi::ctypes::c_int,
    );
}
extern "C" {
    pub fn spi_frequency(obj: *mut spi_t, hz: ffi::ctypes::c_int);
}
extern "C" {
    pub fn spi_master_write(obj: *mut spi_t, value: ffi::ctypes::c_int) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn spi_slave_receive(obj: *mut spi_t) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn spi_slave_read(obj: *mut spi_t) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn spi_slave_write(obj: *mut spi_t, value: ffi::ctypes::c_int);
}
extern "C" {
    pub fn spi_busy(obj: *mut spi_t) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn spi_flush_rx_fifo(obj: *mut spi_t);
}
extern "C" {
    pub fn spi_enable(obj: *mut spi_t);
}
extern "C" {
    pub fn spi_disable(obj: *mut spi_t);
}
extern "C" {
    pub fn sys_jtag_off();
}
extern "C" {
    pub fn sys_clear_ota_signature();
}
extern "C" {
    pub fn sys_recover_ota_signature();
}
extern "C" {
    pub fn sys_log_uart_on();
}
extern "C" {
    pub fn sys_log_uart_off();
}
extern "C" {
    pub fn sys_adc_calibration(write: u8, offset: *mut u16, gain: *mut u16);
}
extern "C" {
    pub fn sys_reset();
}
pub const RTW_SUCCESS: ffi::ctypes::c_int = 0;
pub const RTW_PENDING: ffi::ctypes::c_int = 1;
pub const RTW_TIMEOUT: ffi::ctypes::c_int = 2;
pub const RTW_PARTIAL_RESULTS: ffi::ctypes::c_int = 3;
pub const RTW_INVALID_KEY: ffi::ctypes::c_int = 4;
pub const RTW_DOES_NOT_EXIST: ffi::ctypes::c_int = 5;
pub const RTW_NOT_AUTHENTICATED: ffi::ctypes::c_int = 6;
pub const RTW_NOT_KEYED: ffi::ctypes::c_int = 7;
pub const RTW_IOCTL_FAIL: ffi::ctypes::c_int = 8;
pub const RTW_BUFFER_UNAVAILABLE_TEMPORARY: ffi::ctypes::c_int = 9;
pub const RTW_BUFFER_UNAVAILABLE_PERMANENT: ffi::ctypes::c_int = 10;
pub const RTW_WPS_PBC_OVERLAP: ffi::ctypes::c_int = 11;
pub const RTW_CONNECTION_LOST: ffi::ctypes::c_int = 12;
pub const RTW_ERROR: ffi::ctypes::c_int = -1;
pub const RTW_BADARG: ffi::ctypes::c_int = -2;
pub const RTW_BADOPTION: ffi::ctypes::c_int = -3;
pub const RTW_NOTUP: ffi::ctypes::c_int = -4;
pub const RTW_NOTDOWN: ffi::ctypes::c_int = -5;
pub const RTW_NOTAP: ffi::ctypes::c_int = -6;
pub const RTW_NOTSTA: ffi::ctypes::c_int = -7;
pub const RTW_BADKEYIDX: ffi::ctypes::c_int = -8;
pub const RTW_RADIOOFF: ffi::ctypes::c_int = -9;
pub const RTW_NOTBANDLOCKED: ffi::ctypes::c_int = -10;
pub const RTW_NOCLK: ffi::ctypes::c_int = -11;
pub const RTW_BADRATESET: ffi::ctypes::c_int = -12;
pub const RTW_BADBAND: ffi::ctypes::c_int = -13;
pub const RTW_BUFTOOSHORT: ffi::ctypes::c_int = -14;
pub const RTW_BUFTOOLONG: ffi::ctypes::c_int = -15;
pub const RTW_BUSY: ffi::ctypes::c_int = -16;
pub const RTW_NOTASSOCIATED: ffi::ctypes::c_int = -17;
pub const RTW_BADSSIDLEN: ffi::ctypes::c_int = -18;
pub const RTW_OUTOFRANGECHAN: ffi::ctypes::c_int = -19;
pub const RTW_BADCHAN: ffi::ctypes::c_int = -20;
pub const RTW_BADADDR: ffi::ctypes::c_int = -21;
pub const RTW_NORESOURCE: ffi::ctypes::c_int = -22;
pub const RTW_UNSUPPORTED: ffi::ctypes::c_int = -23;
pub const RTW_BADLEN: ffi::ctypes::c_int = -24;
pub const RTW_NOTREADY: ffi::ctypes::c_int = -25;
pub const RTW_EPERM: ffi::ctypes::c_int = -26;
pub const RTW_NOMEM: ffi::ctypes::c_int = -27;
pub const RTW_ASSOCIATED: ffi::ctypes::c_int = -28;
pub const RTW_RANGE: ffi::ctypes::c_int = -29;
pub const RTW_NOTFOUND: ffi::ctypes::c_int = -30;
pub const RTW_WME_NOT_ENABLED: ffi::ctypes::c_int = -31;
pub const RTW_TSPEC_NOTFOUND: ffi::ctypes::c_int = -32;
pub const RTW_ACM_NOTSUPPORTED: ffi::ctypes::c_int = -33;
pub const RTW_NOT_WME_ASSOCIATION: ffi::ctypes::c_int = -34;
pub const RTW_SDIO_ERROR: ffi::ctypes::c_int = -35;
pub const RTW_WLAN_DOWN: ffi::ctypes::c_int = -36;
pub const RTW_BAD_VERSION: ffi::ctypes::c_int = -37;
pub const RTW_TXFAIL: ffi::ctypes::c_int = -38;
pub const RTW_RXFAIL: ffi::ctypes::c_int = -39;
pub const RTW_NODEVICE: ffi::ctypes::c_int = -40;
pub const RTW_UNFINISHED: ffi::ctypes::c_int = -41;
pub const RTW_NONRESIDENT: ffi::ctypes::c_int = -42;
pub const RTW_DISABLED: ffi::ctypes::c_int = -43;
pub type _bindgen_ty_3 = ffi::ctypes::c_int;
pub type rtw_result_t = ffi::ctypes::c_long;
pub const RTW_SECURITY_OPEN: ffi::ctypes::c_int = 0;
pub const RTW_SECURITY_WEP_PSK: ffi::ctypes::c_int = 1;
pub const RTW_SECURITY_WEP_SHARED: ffi::ctypes::c_int = 32769;
pub const RTW_SECURITY_WPA_TKIP_PSK: ffi::ctypes::c_int = 2097154;
pub const RTW_SECURITY_WPA_AES_PSK: ffi::ctypes::c_int = 2097156;
pub const RTW_SECURITY_WPA2_AES_PSK: ffi::ctypes::c_int = 4194308;
pub const RTW_SECURITY_WPA2_TKIP_PSK: ffi::ctypes::c_int = 4194306;
pub const RTW_SECURITY_WPA2_MIXED_PSK: ffi::ctypes::c_int = 4194310;
pub const RTW_SECURITY_WPA_WPA2_MIXED: ffi::ctypes::c_int = 6291456;
pub const RTW_SECURITY_WPA2_AES_CMAC: ffi::ctypes::c_int = 4194320;
pub const RTW_SECURITY_WPA2_ENTERPRISE: ffi::ctypes::c_int = 4194336;
pub const RTW_SECURITY_WPA_WPA2_ENTERPRISE: ffi::ctypes::c_int = 6291488;
pub const RTW_SECURITY_WPS_OPEN: ffi::ctypes::c_int = 268435456;
pub const RTW_SECURITY_WPS_SECURE: ffi::ctypes::c_int = 268435460;
pub const RTW_SECURITY_WPA3_AES_PSK: ffi::ctypes::c_int = 8388612;
pub const RTW_SECURITY_UNKNOWN: ffi::ctypes::c_int = -1;
pub const RTW_SECURITY_FORCE_32_BIT: ffi::ctypes::c_int = 2147483647;
pub type _bindgen_ty_4 = ffi::ctypes::c_int;
pub type rtw_security_t = ffi::ctypes::c_ulong;
pub const RTW_ENCRYPTION_UNKNOWN: ffi::ctypes::c_uint = 0;
pub const RTW_ENCRYPTION_OPEN: ffi::ctypes::c_uint = 1;
pub const RTW_ENCRYPTION_WEP40: ffi::ctypes::c_uint = 2;
pub const RTW_ENCRYPTION_WPA_TKIP: ffi::ctypes::c_uint = 3;
pub const RTW_ENCRYPTION_WPA_AES: ffi::ctypes::c_uint = 4;
pub const RTW_ENCRYPTION_WPA2_TKIP: ffi::ctypes::c_uint = 5;
pub const RTW_ENCRYPTION_WPA2_AES: ffi::ctypes::c_uint = 6;
pub const RTW_ENCRYPTION_WPA2_MIXED: ffi::ctypes::c_uint = 7;
pub const RTW_ENCRYPTION_WEP104: ffi::ctypes::c_uint = 9;
pub const RTW_ENCRYPTION_UNDEF: ffi::ctypes::c_uint = 255;
pub type _bindgen_ty_5 = ffi::ctypes::c_uint;
pub type rtw_encryption_t = ffi::ctypes::c_ulong;
pub const RTW_FALSE: ffi::ctypes::c_uint = 0;
pub const RTW_TRUE: ffi::ctypes::c_uint = 1;
pub type _bindgen_ty_6 = ffi::ctypes::c_uint;
pub type rtw_bool_t = ffi::ctypes::c_ulong;
pub const RTW_802_11_BAND_5GHZ: ffi::ctypes::c_uint = 0;
pub const RTW_802_11_BAND_2_4GHZ: ffi::ctypes::c_uint = 1;
pub type _bindgen_ty_7 = ffi::ctypes::c_uint;
pub type rtw_802_11_band_t = ffi::ctypes::c_ulong;
pub const RTW_COUNTRY_WORLD1: ffi::ctypes::c_uint = 0;
pub const RTW_COUNTRY_ETSI1: ffi::ctypes::c_uint = 1;
pub const RTW_COUNTRY_FCC1: ffi::ctypes::c_uint = 2;
pub const RTW_COUNTRY_MKK1: ffi::ctypes::c_uint = 3;
pub const RTW_COUNTRY_ETSI2: ffi::ctypes::c_uint = 4;
pub const RTW_COUNTRY_FCC2: ffi::ctypes::c_uint = 5;
pub const RTW_COUNTRY_WORLD2: ffi::ctypes::c_uint = 6;
pub const RTW_COUNTRY_MKK2: ffi::ctypes::c_uint = 7;
pub const RTW_COUNTRY_GLOBAL: ffi::ctypes::c_uint = 8;
pub const RTW_COUNTRY_WORLD: ffi::ctypes::c_uint = 9;
pub const RTW_COUNTRY_EU: ffi::ctypes::c_uint = 10;
pub const RTW_COUNTRY_JP: ffi::ctypes::c_uint = 11;
pub const RTW_COUNTRY_AS: ffi::ctypes::c_uint = 12;
pub const RTW_COUNTRY_BM: ffi::ctypes::c_uint = 13;
pub const RTW_COUNTRY_CA: ffi::ctypes::c_uint = 14;
pub const RTW_COUNTRY_DM: ffi::ctypes::c_uint = 15;
pub const RTW_COUNTRY_DO: ffi::ctypes::c_uint = 16;
pub const RTW_COUNTRY_FM: ffi::ctypes::c_uint = 17;
pub const RTW_COUNTRY_GD: ffi::ctypes::c_uint = 18;
pub const RTW_COUNTRY_GT: ffi::ctypes::c_uint = 19;
pub const RTW_COUNTRY_GU: ffi::ctypes::c_uint = 20;
pub const RTW_COUNTRY_HT: ffi::ctypes::c_uint = 21;
pub const RTW_COUNTRY_MH: ffi::ctypes::c_uint = 22;
pub const RTW_COUNTRY_MP: ffi::ctypes::c_uint = 23;
pub const RTW_COUNTRY_NI: ffi::ctypes::c_uint = 24;
pub const RTW_COUNTRY_PA: ffi::ctypes::c_uint = 25;
pub const RTW_COUNTRY_PR: ffi::ctypes::c_uint = 26;
pub const RTW_COUNTRY_PW: ffi::ctypes::c_uint = 27;
pub const RTW_COUNTRY_TW: ffi::ctypes::c_uint = 28;
pub const RTW_COUNTRY_US: ffi::ctypes::c_uint = 29;
pub const RTW_COUNTRY_VI: ffi::ctypes::c_uint = 30;
pub const RTW_COUNTRY_AD: ffi::ctypes::c_uint = 31;
pub const RTW_COUNTRY_AE: ffi::ctypes::c_uint = 32;
pub const RTW_COUNTRY_AF: ffi::ctypes::c_uint = 33;
pub const RTW_COUNTRY_AI: ffi::ctypes::c_uint = 34;
pub const RTW_COUNTRY_AL: ffi::ctypes::c_uint = 35;
pub const RTW_COUNTRY_AM: ffi::ctypes::c_uint = 36;
pub const RTW_COUNTRY_AN: ffi::ctypes::c_uint = 37;
pub const RTW_COUNTRY_AR: ffi::ctypes::c_uint = 38;
pub const RTW_COUNTRY_AT: ffi::ctypes::c_uint = 39;
pub const RTW_COUNTRY_AU: ffi::ctypes::c_uint = 40;
pub const RTW_COUNTRY_AW: ffi::ctypes::c_uint = 41;
pub const RTW_COUNTRY_AZ: ffi::ctypes::c_uint = 42;
pub const RTW_COUNTRY_BA: ffi::ctypes::c_uint = 43;
pub const RTW_COUNTRY_BB: ffi::ctypes::c_uint = 44;
pub const RTW_COUNTRY_BD: ffi::ctypes::c_uint = 45;
pub const RTW_COUNTRY_BE: ffi::ctypes::c_uint = 46;
pub const RTW_COUNTRY_BF: ffi::ctypes::c_uint = 47;
pub const RTW_COUNTRY_BG: ffi::ctypes::c_uint = 48;
pub const RTW_COUNTRY_BH: ffi::ctypes::c_uint = 49;
pub const RTW_COUNTRY_BL: ffi::ctypes::c_uint = 50;
pub const RTW_COUNTRY_BN: ffi::ctypes::c_uint = 51;
pub const RTW_COUNTRY_BO: ffi::ctypes::c_uint = 52;
pub const RTW_COUNTRY_BR: ffi::ctypes::c_uint = 53;
pub const RTW_COUNTRY_BS: ffi::ctypes::c_uint = 54;
pub const RTW_COUNTRY_BT: ffi::ctypes::c_uint = 55;
pub const RTW_COUNTRY_BY: ffi::ctypes::c_uint = 56;
pub const RTW_COUNTRY_BZ: ffi::ctypes::c_uint = 57;
pub const RTW_COUNTRY_CF: ffi::ctypes::c_uint = 58;
pub const RTW_COUNTRY_CH: ffi::ctypes::c_uint = 59;
pub const RTW_COUNTRY_CI: ffi::ctypes::c_uint = 60;
pub const RTW_COUNTRY_CL: ffi::ctypes::c_uint = 61;
pub const RTW_COUNTRY_CN: ffi::ctypes::c_uint = 62;
pub const RTW_COUNTRY_CO: ffi::ctypes::c_uint = 63;
pub const RTW_COUNTRY_CR: ffi::ctypes::c_uint = 64;
pub const RTW_COUNTRY_CX: ffi::ctypes::c_uint = 65;
pub const RTW_COUNTRY_CY: ffi::ctypes::c_uint = 66;
pub const RTW_COUNTRY_CZ: ffi::ctypes::c_uint = 67;
pub const RTW_COUNTRY_DE: ffi::ctypes::c_uint = 68;
pub const RTW_COUNTRY_DK: ffi::ctypes::c_uint = 69;
pub const RTW_COUNTRY_DZ: ffi::ctypes::c_uint = 70;
pub const RTW_COUNTRY_EC: ffi::ctypes::c_uint = 71;
pub const RTW_COUNTRY_EE: ffi::ctypes::c_uint = 72;
pub const RTW_COUNTRY_EG: ffi::ctypes::c_uint = 73;
pub const RTW_COUNTRY_ES: ffi::ctypes::c_uint = 74;
pub const RTW_COUNTRY_ET: ffi::ctypes::c_uint = 75;
pub const RTW_COUNTRY_FI: ffi::ctypes::c_uint = 76;
pub const RTW_COUNTRY_FR: ffi::ctypes::c_uint = 77;
pub const RTW_COUNTRY_GB: ffi::ctypes::c_uint = 78;
pub const RTW_COUNTRY_GE: ffi::ctypes::c_uint = 79;
pub const RTW_COUNTRY_GF: ffi::ctypes::c_uint = 80;
pub const RTW_COUNTRY_GH: ffi::ctypes::c_uint = 81;
pub const RTW_COUNTRY_GL: ffi::ctypes::c_uint = 82;
pub const RTW_COUNTRY_GP: ffi::ctypes::c_uint = 83;
pub const RTW_COUNTRY_GR: ffi::ctypes::c_uint = 84;
pub const RTW_COUNTRY_GY: ffi::ctypes::c_uint = 85;
pub const RTW_COUNTRY_HK: ffi::ctypes::c_uint = 86;
pub const RTW_COUNTRY_HN: ffi::ctypes::c_uint = 87;
pub const RTW_COUNTRY_HR: ffi::ctypes::c_uint = 88;
pub const RTW_COUNTRY_HU: ffi::ctypes::c_uint = 89;
pub const RTW_COUNTRY_ID: ffi::ctypes::c_uint = 90;
pub const RTW_COUNTRY_IE: ffi::ctypes::c_uint = 91;
pub const RTW_COUNTRY_IL: ffi::ctypes::c_uint = 92;
pub const RTW_COUNTRY_IN: ffi::ctypes::c_uint = 93;
pub const RTW_COUNTRY_IQ: ffi::ctypes::c_uint = 94;
pub const RTW_COUNTRY_IR: ffi::ctypes::c_uint = 95;
pub const RTW_COUNTRY_IS: ffi::ctypes::c_uint = 96;
pub const RTW_COUNTRY_IT: ffi::ctypes::c_uint = 97;
pub const RTW_COUNTRY_JM: ffi::ctypes::c_uint = 98;
pub const RTW_COUNTRY_JO: ffi::ctypes::c_uint = 99;
pub const RTW_COUNTRY_KE: ffi::ctypes::c_uint = 100;
pub const RTW_COUNTRY_KH: ffi::ctypes::c_uint = 101;
pub const RTW_COUNTRY_KN: ffi::ctypes::c_uint = 102;
pub const RTW_COUNTRY_KP: ffi::ctypes::c_uint = 103;
pub const RTW_COUNTRY_KR: ffi::ctypes::c_uint = 104;
pub const RTW_COUNTRY_KW: ffi::ctypes::c_uint = 105;
pub const RTW_COUNTRY_KY: ffi::ctypes::c_uint = 106;
pub const RTW_COUNTRY_KZ: ffi::ctypes::c_uint = 107;
pub const RTW_COUNTRY_LA: ffi::ctypes::c_uint = 108;
pub const RTW_COUNTRY_LB: ffi::ctypes::c_uint = 109;
pub const RTW_COUNTRY_LC: ffi::ctypes::c_uint = 110;
pub const RTW_COUNTRY_LI: ffi::ctypes::c_uint = 111;
pub const RTW_COUNTRY_LK: ffi::ctypes::c_uint = 112;
pub const RTW_COUNTRY_LR: ffi::ctypes::c_uint = 113;
pub const RTW_COUNTRY_LS: ffi::ctypes::c_uint = 114;
pub const RTW_COUNTRY_LT: ffi::ctypes::c_uint = 115;
pub const RTW_COUNTRY_LU: ffi::ctypes::c_uint = 116;
pub const RTW_COUNTRY_LV: ffi::ctypes::c_uint = 117;
pub const RTW_COUNTRY_MA: ffi::ctypes::c_uint = 118;
pub const RTW_COUNTRY_MC: ffi::ctypes::c_uint = 119;
pub const RTW_COUNTRY_MD: ffi::ctypes::c_uint = 120;
pub const RTW_COUNTRY_ME: ffi::ctypes::c_uint = 121;
pub const RTW_COUNTRY_MF: ffi::ctypes::c_uint = 122;
pub const RTW_COUNTRY_MK: ffi::ctypes::c_uint = 123;
pub const RTW_COUNTRY_MN: ffi::ctypes::c_uint = 124;
pub const RTW_COUNTRY_MO: ffi::ctypes::c_uint = 125;
pub const RTW_COUNTRY_MQ: ffi::ctypes::c_uint = 126;
pub const RTW_COUNTRY_MR: ffi::ctypes::c_uint = 127;
pub const RTW_COUNTRY_MT: ffi::ctypes::c_uint = 128;
pub const RTW_COUNTRY_MU: ffi::ctypes::c_uint = 129;
pub const RTW_COUNTRY_MV: ffi::ctypes::c_uint = 130;
pub const RTW_COUNTRY_MW: ffi::ctypes::c_uint = 131;
pub const RTW_COUNTRY_MX: ffi::ctypes::c_uint = 132;
pub const RTW_COUNTRY_MY: ffi::ctypes::c_uint = 133;
pub const RTW_COUNTRY_NG: ffi::ctypes::c_uint = 134;
pub const RTW_COUNTRY_NL: ffi::ctypes::c_uint = 135;
pub const RTW_COUNTRY_NO: ffi::ctypes::c_uint = 136;
pub const RTW_COUNTRY_NP: ffi::ctypes::c_uint = 137;
pub const RTW_COUNTRY_NZ: ffi::ctypes::c_uint = 138;
pub const RTW_COUNTRY_OM: ffi::ctypes::c_uint = 139;
pub const RTW_COUNTRY_PE: ffi::ctypes::c_uint = 140;
pub const RTW_COUNTRY_PF: ffi::ctypes::c_uint = 141;
pub const RTW_COUNTRY_PG: ffi::ctypes::c_uint = 142;
pub const RTW_COUNTRY_PH: ffi::ctypes::c_uint = 143;
pub const RTW_COUNTRY_PK: ffi::ctypes::c_uint = 144;
pub const RTW_COUNTRY_PL: ffi::ctypes::c_uint = 145;
pub const RTW_COUNTRY_PM: ffi::ctypes::c_uint = 146;
pub const RTW_COUNTRY_PT: ffi::ctypes::c_uint = 147;
pub const RTW_COUNTRY_PY: ffi::ctypes::c_uint = 148;
pub const RTW_COUNTRY_QA: ffi::ctypes::c_uint = 149;
pub const RTW_COUNTRY_RS: ffi::ctypes::c_uint = 150;
pub const RTW_COUNTRY_RU: ffi::ctypes::c_uint = 151;
pub const RTW_COUNTRY_RW: ffi::ctypes::c_uint = 152;
pub const RTW_COUNTRY_SA: ffi::ctypes::c_uint = 153;
pub const RTW_COUNTRY_SE: ffi::ctypes::c_uint = 154;
pub const RTW_COUNTRY_SG: ffi::ctypes::c_uint = 155;
pub const RTW_COUNTRY_SI: ffi::ctypes::c_uint = 156;
pub const RTW_COUNTRY_SK: ffi::ctypes::c_uint = 157;
pub const RTW_COUNTRY_SN: ffi::ctypes::c_uint = 158;
pub const RTW_COUNTRY_SR: ffi::ctypes::c_uint = 159;
pub const RTW_COUNTRY_SV: ffi::ctypes::c_uint = 160;
pub const RTW_COUNTRY_SY: ffi::ctypes::c_uint = 161;
pub const RTW_COUNTRY_TC: ffi::ctypes::c_uint = 162;
pub const RTW_COUNTRY_TD: ffi::ctypes::c_uint = 163;
pub const RTW_COUNTRY_TG: ffi::ctypes::c_uint = 164;
pub const RTW_COUNTRY_TH: ffi::ctypes::c_uint = 165;
pub const RTW_COUNTRY_TN: ffi::ctypes::c_uint = 166;
pub const RTW_COUNTRY_TR: ffi::ctypes::c_uint = 167;
pub const RTW_COUNTRY_TT: ffi::ctypes::c_uint = 168;
pub const RTW_COUNTRY_TZ: ffi::ctypes::c_uint = 169;
pub const RTW_COUNTRY_UA: ffi::ctypes::c_uint = 170;
pub const RTW_COUNTRY_UG: ffi::ctypes::c_uint = 171;
pub const RTW_COUNTRY_UY: ffi::ctypes::c_uint = 172;
pub const RTW_COUNTRY_UZ: ffi::ctypes::c_uint = 173;
pub const RTW_COUNTRY_VC: ffi::ctypes::c_uint = 174;
pub const RTW_COUNTRY_VE: ffi::ctypes::c_uint = 175;
pub const RTW_COUNTRY_VN: ffi::ctypes::c_uint = 176;
pub const RTW_COUNTRY_VU: ffi::ctypes::c_uint = 177;
pub const RTW_COUNTRY_WF: ffi::ctypes::c_uint = 178;
pub const RTW_COUNTRY_WS: ffi::ctypes::c_uint = 179;
pub const RTW_COUNTRY_YE: ffi::ctypes::c_uint = 180;
pub const RTW_COUNTRY_YT: ffi::ctypes::c_uint = 181;
pub const RTW_COUNTRY_ZA: ffi::ctypes::c_uint = 182;
pub const RTW_COUNTRY_ZW: ffi::ctypes::c_uint = 183;
pub const RTW_COUNTRY_MAX: ffi::ctypes::c_uint = 184;
pub type _bindgen_ty_8 = ffi::ctypes::c_uint;
pub type rtw_country_code_t = ffi::ctypes::c_ulong;
pub const RTW_ADAPTIVITY_DISABLE: ffi::ctypes::c_uint = 0;
pub const RTW_ADAPTIVITY_NORMAL: ffi::ctypes::c_uint = 1;
pub const RTW_ADAPTIVITY_CARRIER_SENSE: ffi::ctypes::c_uint = 2;
pub type _bindgen_ty_9 = ffi::ctypes::c_uint;
pub type rtw_adaptivity_mode_t = ffi::ctypes::c_ulong;
pub const RTW_MODE_NONE: ffi::ctypes::c_uint = 0;
pub const RTW_MODE_STA: ffi::ctypes::c_uint = 1;
pub const RTW_MODE_AP: ffi::ctypes::c_uint = 2;
pub const RTW_MODE_STA_AP: ffi::ctypes::c_uint = 3;
pub const RTW_MODE_PROMISC: ffi::ctypes::c_uint = 4;
pub const RTW_MODE_P2P: ffi::ctypes::c_uint = 5;
pub type _bindgen_ty_10 = ffi::ctypes::c_uint;
pub type rtw_mode_t = ffi::ctypes::c_ulong;
pub const RTW_SCAN_FULL: ffi::ctypes::c_uint = 0;
pub const RTW_SCAN_SOCIAL: ffi::ctypes::c_uint = 1;
pub const RTW_SCAN_ONE: ffi::ctypes::c_uint = 2;
pub type _bindgen_ty_11 = ffi::ctypes::c_uint;
pub type rtw_scan_mode_t = ffi::ctypes::c_ulong;
pub const rtw_autoreconnect_mode_t_RTW_AUTORECONNECT_DISABLE: rtw_autoreconnect_mode_t = 0;
pub const rtw_autoreconnect_mode_t_RTW_AUTORECONNECT_FINITE: rtw_autoreconnect_mode_t = 1;
pub const rtw_autoreconnect_mode_t_RTW_AUTORECONNECT_INFINITE: rtw_autoreconnect_mode_t = 2;
pub type rtw_autoreconnect_mode_t = ffi::ctypes::c_uint;
pub const RTW_LINK_DISCONNECTED: ffi::ctypes::c_uint = 0;
pub const RTW_LINK_CONNECTED: ffi::ctypes::c_uint = 1;
pub type _bindgen_ty_12 = ffi::ctypes::c_uint;
pub type rtw_link_status_t = ffi::ctypes::c_ulong;
pub const RTW_SCAN_TYPE_ACTIVE: ffi::ctypes::c_uint = 0;
pub const RTW_SCAN_TYPE_PASSIVE: ffi::ctypes::c_uint = 1;
pub type _bindgen_ty_13 = ffi::ctypes::c_uint;
pub type rtw_scan_type_t = ffi::ctypes::c_ulong;
pub const RTW_BSS_TYPE_INFRASTRUCTURE: ffi::ctypes::c_int = 0;
pub const RTW_BSS_TYPE_ADHOC: ffi::ctypes::c_int = 1;
pub const RTW_BSS_TYPE_ANY: ffi::ctypes::c_int = 2;
pub const RTW_BSS_TYPE_UNKNOWN: ffi::ctypes::c_int = -1;
pub type _bindgen_ty_14 = ffi::ctypes::c_int;
pub type rtw_bss_type_t = ffi::ctypes::c_ulong;
pub const RTW_SCAN_COMMAMD: ffi::ctypes::c_uint = 1;
pub type _bindgen_ty_15 = ffi::ctypes::c_uint;
pub type rtw_scan_command_t = ffi::ctypes::c_ulong;
pub const COMMAND1: ffi::ctypes::c_uint = 1;
pub type _bindgen_ty_16 = ffi::ctypes::c_uint;
pub type rtw_command_type = ffi::ctypes::c_ulong;
pub const RTW_WPS_TYPE_DEFAULT: ffi::ctypes::c_uint = 0;
pub const RTW_WPS_TYPE_USER_SPECIFIED: ffi::ctypes::c_uint = 1;
pub const RTW_WPS_TYPE_MACHINE_SPECIFIED: ffi::ctypes::c_uint = 2;
pub const RTW_WPS_TYPE_REKEY: ffi::ctypes::c_uint = 3;
pub const RTW_WPS_TYPE_PUSHBUTTON: ffi::ctypes::c_uint = 4;
pub const RTW_WPS_TYPE_REGISTRAR_SPECIFIED: ffi::ctypes::c_uint = 5;
pub const RTW_WPS_TYPE_NONE: ffi::ctypes::c_uint = 6;
pub const RTW_WPS_TYPE_WSC: ffi::ctypes::c_uint = 7;
pub type _bindgen_ty_17 = ffi::ctypes::c_uint;
pub type rtw_wps_type_t = ffi::ctypes::c_ulong;
pub const RTW_NETWORK_B: ffi::ctypes::c_uint = 1;
pub const RTW_NETWORK_BG: ffi::ctypes::c_uint = 3;
pub const RTW_NETWORK_BGN: ffi::ctypes::c_uint = 11;
pub type _bindgen_ty_18 = ffi::ctypes::c_uint;
pub type rtw_network_mode_t = ffi::ctypes::c_ulong;
pub const RTW_STA_INTERFACE: ffi::ctypes::c_uint = 0;
pub const RTW_AP_INTERFACE: ffi::ctypes::c_uint = 1;
pub type _bindgen_ty_19 = ffi::ctypes::c_uint;
pub type rtw_interface_t = ffi::ctypes::c_ulong;
pub const RTW_POSITIVE_MATCHING: ffi::ctypes::c_uint = 0;
pub const RTW_NEGATIVE_MATCHING: ffi::ctypes::c_uint = 1;
pub type _bindgen_ty_20 = ffi::ctypes::c_uint;
pub type rtw_packet_filter_rule_t = ffi::ctypes::c_ulong;
pub const RTW_PROMISC_DISABLE: ffi::ctypes::c_uint = 0;
pub const RTW_PROMISC_ENABLE: ffi::ctypes::c_uint = 1;
pub const RTW_PROMISC_ENABLE_1: ffi::ctypes::c_uint = 2;
pub const RTW_PROMISC_ENABLE_2: ffi::ctypes::c_uint = 3;
pub const RTW_PROMISC_ENABLE_3: ffi::ctypes::c_uint = 4;
pub const RTW_PROMISC_ENABLE_4: ffi::ctypes::c_uint = 5;
pub type _bindgen_ty_21 = ffi::ctypes::c_uint;
pub type rtw_rcr_level_t = ffi::ctypes::c_ulong;
pub const RTW_NO_ERROR: ffi::ctypes::c_uint = 0;
pub const RTW_NONE_NETWORK: ffi::ctypes::c_uint = 1;
pub const RTW_CONNECT_FAIL: ffi::ctypes::c_uint = 2;
pub const RTW_WRONG_PASSWORD: ffi::ctypes::c_uint = 3;
pub const RTW_4WAY_HANDSHAKE_TIMEOUT: ffi::ctypes::c_uint = 4;
pub const RTW_DHCP_FAIL: ffi::ctypes::c_uint = 5;
pub const RTW_UNKNOWN: ffi::ctypes::c_uint = 6;
pub type _bindgen_ty_22 = ffi::ctypes::c_uint;
pub type rtw_connect_error_flag_t = ffi::ctypes::c_ulong;
pub const RTW_TX_PWR_PERCENTAGE_100: ffi::ctypes::c_uint = 0;
pub const RTW_TX_PWR_PERCENTAGE_75: ffi::ctypes::c_uint = 1;
pub const RTW_TX_PWR_PERCENTAGE_50: ffi::ctypes::c_uint = 2;
pub const RTW_TX_PWR_PERCENTAGE_25: ffi::ctypes::c_uint = 3;
pub const RTW_TX_PWR_PERCENTAGE_12_5: ffi::ctypes::c_uint = 4;
pub type _bindgen_ty_23 = ffi::ctypes::c_uint;
pub type rtw_tx_pwr_percentage_t = ffi::ctypes::c_ulong;
pub const _WIFI_EVENT_INDICATE_WIFI_EVENT_CONNECT: _WIFI_EVENT_INDICATE = 0;
pub const _WIFI_EVENT_INDICATE_WIFI_EVENT_DISCONNECT: _WIFI_EVENT_INDICATE = 1;
pub const _WIFI_EVENT_INDICATE_WIFI_EVENT_FOURWAY_HANDSHAKE_DONE: _WIFI_EVENT_INDICATE = 2;
pub const _WIFI_EVENT_INDICATE_WIFI_EVENT_SCAN_RESULT_REPORT: _WIFI_EVENT_INDICATE = 3;
pub const _WIFI_EVENT_INDICATE_WIFI_EVENT_SCAN_DONE: _WIFI_EVENT_INDICATE = 4;
pub const _WIFI_EVENT_INDICATE_WIFI_EVENT_RECONNECTION_FAIL: _WIFI_EVENT_INDICATE = 5;
pub const _WIFI_EVENT_INDICATE_WIFI_EVENT_SEND_ACTION_DONE: _WIFI_EVENT_INDICATE = 6;
pub const _WIFI_EVENT_INDICATE_WIFI_EVENT_RX_MGNT: _WIFI_EVENT_INDICATE = 7;
pub const _WIFI_EVENT_INDICATE_WIFI_EVENT_STA_ASSOC: _WIFI_EVENT_INDICATE = 8;
pub const _WIFI_EVENT_INDICATE_WIFI_EVENT_STA_DISASSOC: _WIFI_EVENT_INDICATE = 9;
pub const _WIFI_EVENT_INDICATE_WIFI_EVENT_STA_WPS_START: _WIFI_EVENT_INDICATE = 10;
pub const _WIFI_EVENT_INDICATE_WIFI_EVENT_WPS_FINISH: _WIFI_EVENT_INDICATE = 11;
pub const _WIFI_EVENT_INDICATE_WIFI_EVENT_EAPOL_START: _WIFI_EVENT_INDICATE = 12;
pub const _WIFI_EVENT_INDICATE_WIFI_EVENT_EAPOL_RECVD: _WIFI_EVENT_INDICATE = 13;
pub const _WIFI_EVENT_INDICATE_WIFI_EVENT_NO_NETWORK: _WIFI_EVENT_INDICATE = 14;
pub const _WIFI_EVENT_INDICATE_WIFI_EVENT_BEACON_AFTER_DHCP: _WIFI_EVENT_INDICATE = 15;
pub const _WIFI_EVENT_INDICATE_WIFI_EVENT_IP_CHANGED: _WIFI_EVENT_INDICATE = 16;
pub const _WIFI_EVENT_INDICATE_WIFI_EVENT_ICV_ERROR: _WIFI_EVENT_INDICATE = 17;
pub const _WIFI_EVENT_INDICATE_WIFI_EVENT_CHALLENGE_FAIL: _WIFI_EVENT_INDICATE = 18;
pub const _WIFI_EVENT_INDICATE_WIFI_EVENT_PATHSEL_GEN_RREQ: _WIFI_EVENT_INDICATE = 59;
pub const _WIFI_EVENT_INDICATE_WIFI_EVENT_PATHSEL_GEN_RERR: _WIFI_EVENT_INDICATE = 60;
pub const _WIFI_EVENT_INDICATE_WIFI_EVENT_PATHSEL_RECV_RREQ: _WIFI_EVENT_INDICATE = 61;
pub const _WIFI_EVENT_INDICATE_WIFI_EVENT_PATHSEL_RECV_RREP: _WIFI_EVENT_INDICATE = 62;
pub const _WIFI_EVENT_INDICATE_WIFI_EVENT_PATHSEL_RECV_RERR: _WIFI_EVENT_INDICATE = 63;
pub const _WIFI_EVENT_INDICATE_WIFI_EVENT_PATHSEL_RECV_PANN: _WIFI_EVENT_INDICATE = 65;
pub const _WIFI_EVENT_INDICATE_WIFI_EVENT_PATHSEL_RECV_RANN: _WIFI_EVENT_INDICATE = 66;
pub const _WIFI_EVENT_INDICATE_WIFI_EVENT_PATHSEL_GEN_PREQ: _WIFI_EVENT_INDICATE = 150;
pub const _WIFI_EVENT_INDICATE_WIFI_EVENT_PATHSEL_GEN_PERR: _WIFI_EVENT_INDICATE = 151;
pub const _WIFI_EVENT_INDICATE_WIFI_EVENT_PATHSEL_RECV_PREQ: _WIFI_EVENT_INDICATE = 152;
pub const _WIFI_EVENT_INDICATE_WIFI_EVENT_PATHSEL_RECV_PREP: _WIFI_EVENT_INDICATE = 153;
pub const _WIFI_EVENT_INDICATE_WIFI_EVENT_PATHSEL_RECV_PERR: _WIFI_EVENT_INDICATE = 154;
pub const _WIFI_EVENT_INDICATE_WIFI_EVENT_PATHSEL_RECV_GANN: _WIFI_EVENT_INDICATE = 155;
pub const _WIFI_EVENT_INDICATE_WIFI_EVENT_MAX: _WIFI_EVENT_INDICATE = 156;
pub type _WIFI_EVENT_INDICATE = ffi::ctypes::c_uint;
pub type rtw_event_indicate_t = ffi::ctypes::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct list_head {
    pub next: *mut list_head,
    pub prev: *mut list_head,
}
impl Default for list_head {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rtw_ssid {
    pub len: ffi::ctypes::c_uchar,
    pub val: [ffi::ctypes::c_uchar; 33usize],
}
impl Default for rtw_ssid {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtw_ssid {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "rtw_ssid {{ len: {:?}, val: [...] }}", self.len)
    }
}
pub type rtw_ssid_t = rtw_ssid;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtw_mac {
    pub octet: [ffi::ctypes::c_uchar; 6usize],
}
pub type rtw_mac_t = rtw_mac;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rtw_ap_info {
    pub ssid: rtw_ssid_t,
    pub security_type: rtw_security_t,
    pub password: *mut ffi::ctypes::c_uchar,
    pub password_len: ffi::ctypes::c_int,
    pub channel: ffi::ctypes::c_int,
}
impl Default for rtw_ap_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtw_ap_info {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "rtw_ap_info {{ ssid: {:?}, security_type: {:?}, password: {:?}, password_len: {:?}, channel: {:?} }}" , self . ssid , self . security_type , self . password , self . password_len , self . channel)
    }
}
pub type rtw_ap_info_t = rtw_ap_info;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rtw_network_info {
    pub ssid: rtw_ssid_t,
    pub bssid: rtw_mac_t,
    pub security_type: rtw_security_t,
    pub password: *mut ffi::ctypes::c_uchar,
    pub password_len: ffi::ctypes::c_int,
    pub key_id: ffi::ctypes::c_int,
}
impl Default for rtw_network_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtw_network_info {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "rtw_network_info {{ ssid: {:?}, bssid: {:?}, security_type: {:?}, password: {:?}, password_len: {:?}, key_id: {:?} }}" , self . ssid , self . bssid , self . security_type , self . password , self . password_len , self . key_id)
    }
}
pub type rtw_network_info_t = rtw_network_info;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rtw_scan_result {
    pub SSID: rtw_ssid_t,
    pub BSSID: rtw_mac_t,
    pub signal_strength: ffi::ctypes::c_short,
    pub bss_type: rtw_bss_type_t,
    pub security: rtw_security_t,
    pub wps_type: rtw_wps_type_t,
    pub channel: ffi::ctypes::c_uint,
    pub band: rtw_802_11_band_t,
}
impl Default for rtw_scan_result {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtw_scan_result {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "rtw_scan_result {{ SSID: {:?}, BSSID: {:?}, signal_strength: {:?}, bss_type: {:?}, security: {:?}, wps_type: {:?}, channel: {:?}, band: {:?} }}" , self . SSID , self . BSSID , self . signal_strength , self . bss_type , self . security , self . wps_type , self . channel , self . band)
    }
}
pub type rtw_scan_result_t = rtw_scan_result;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rtw_scan_handler_result {
    pub ap_details: rtw_scan_result_t,
    pub scan_complete: rtw_bool_t,
    pub user_data: *mut ffi::ctypes::c_void,
}
impl Default for rtw_scan_handler_result {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtw_scan_handler_result {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "rtw_scan_handler_result {{ ap_details: {:?}, scan_complete: {:?}, user_data: {:?} }}",
            self.ap_details, self.scan_complete, self.user_data
        )
    }
}
pub type rtw_scan_handler_result_t = rtw_scan_handler_result;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rtw_wifi_setting {
    pub mode: rtw_mode_t,
    pub ssid: [ffi::ctypes::c_uchar; 33usize],
    pub channel: ffi::ctypes::c_uchar,
    pub security_type: rtw_security_t,
    pub password: [ffi::ctypes::c_uchar; 65usize],
    pub key_idx: ffi::ctypes::c_uchar,
}
impl Default for rtw_wifi_setting {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtw_wifi_setting {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "rtw_wifi_setting {{ mode: {:?}, ssid: [...], channel: {:?}, security_type: {:?}, password: [...], key_idx: {:?} }}" , self . mode , self . channel , self . security_type , self . key_idx)
    }
}
pub type rtw_wifi_setting_t = rtw_wifi_setting;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rtw_wifi_config {
    pub boot_mode: ffi::ctypes::c_uint,
    pub ssid: [ffi::ctypes::c_uchar; 32usize],
    pub ssid_len: ffi::ctypes::c_uchar,
    pub security_type: ffi::ctypes::c_uchar,
    pub password: [ffi::ctypes::c_uchar; 65usize],
    pub password_len: ffi::ctypes::c_uchar,
    pub channel: ffi::ctypes::c_uchar,
}
impl Default for rtw_wifi_config {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for rtw_wifi_config {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "rtw_wifi_config {{ boot_mode: {:?}, ssid: [...], ssid_len: {:?}, security_type: {:?}, password: [...], password_len: {:?}, channel: {:?} }}" , self . boot_mode , self . ssid_len , self . security_type , self . password_len , self . channel)
    }
}
pub type rtw_wifi_config_t = rtw_wifi_config;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtw_maclist_t {
    pub count: ffi::ctypes::c_uint,
    pub mac_list: [rtw_mac_t; 1usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rtw_bss_info_t {
    pub version: ffi::ctypes::c_uint,
    pub length: ffi::ctypes::c_uint,
    pub BSSID: rtw_mac_t,
    pub beacon_period: ffi::ctypes::c_ushort,
    pub capability: ffi::ctypes::c_ushort,
    pub SSID_len: ffi::ctypes::c_uchar,
    pub SSID: [ffi::ctypes::c_uchar; 32usize],
    pub channel: ffi::ctypes::c_uchar,
    pub atim_window: ffi::ctypes::c_ushort,
    pub dtim_period: ffi::ctypes::c_uchar,
    pub RSSI: ffi::ctypes::c_short,
    pub n_cap: ffi::ctypes::c_uchar,
    pub nbss_cap: ffi::ctypes::c_uint,
    pub basic_mcs: [ffi::ctypes::c_uchar; 16usize],
    pub ie_offset: ffi::ctypes::c_ushort,
    pub ie_length: ffi::ctypes::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rtw_packet_filter_pattern_t {
    pub offset: ffi::ctypes::c_ushort,
    pub mask_size: ffi::ctypes::c_ushort,
    pub mask: *mut ffi::ctypes::c_uchar,
    pub pattern: *mut ffi::ctypes::c_uchar,
}
impl Default for rtw_packet_filter_pattern_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ieee80211_frame_info {
    pub i_fc: ffi::ctypes::c_ushort,
    pub i_dur: ffi::ctypes::c_ushort,
    pub i_addr1: [ffi::ctypes::c_uchar; 6usize],
    pub i_addr2: [ffi::ctypes::c_uchar; 6usize],
    pub i_addr3: [ffi::ctypes::c_uchar; 6usize],
    pub i_seq: ffi::ctypes::c_ushort,
    pub bssid: [ffi::ctypes::c_uchar; 6usize],
    pub encrypt: ffi::ctypes::c_uchar,
    pub rssi: ffi::ctypes::c_schar,
}
pub type ieee80211_frame_info_t = ieee80211_frame_info;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rtw_packet_filter_info_t {
    pub filter_id: ffi::ctypes::c_char,
    pub patt: rtw_packet_filter_pattern_t,
    pub rule: rtw_packet_filter_rule_t,
    pub enable: ffi::ctypes::c_uchar,
}
impl Default for rtw_packet_filter_info_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rtw_mac_filter_list {
    pub node: list_head,
    pub mac_addr: [ffi::ctypes::c_uchar; 6usize],
}
impl Default for rtw_mac_filter_list {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type rtw_mac_filter_list_t = rtw_mac_filter_list;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct wowlan_pattern {
    pub eth_da: [ffi::ctypes::c_uchar; 6usize],
    pub eth_sa: [ffi::ctypes::c_uchar; 6usize],
    pub eth_proto_type: [ffi::ctypes::c_uchar; 2usize],
    pub header_len: [ffi::ctypes::c_uchar; 1usize],
    pub ip_proto: [ffi::ctypes::c_uchar; 1usize],
    pub ip_sa: [ffi::ctypes::c_uchar; 4usize],
    pub ip_da: [ffi::ctypes::c_uchar; 4usize],
    pub src_port: [ffi::ctypes::c_uchar; 2usize],
    pub dest_port: [ffi::ctypes::c_uchar; 2usize],
    pub mask: [ffi::ctypes::c_uchar; 5usize],
}
pub type wowlan_pattern_t = wowlan_pattern;
pub type __u8 = ffi::ctypes::c_uchar;
pub type __s8 = ffi::ctypes::c_char;
pub type __u16 = ffi::ctypes::c_ushort;
pub type __s16 = ffi::ctypes::c_short;
pub type __u32 = ffi::ctypes::c_uint;
pub type __s32 = ffi::ctypes::c_int;
pub type __u64 = ffi::ctypes::c_ulonglong;
pub type __i64 = ffi::ctypes::c_longlong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sockaddr_t {
    pub sa_len: __u8,
    pub sa_family: __u8,
    pub sa_data: [ffi::ctypes::c_char; 14usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct iw_param {
    pub value: __s32,
    pub fixed: __u8,
    pub disabled: __u8,
    pub flags: __u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iw_point {
    pub pointer: *mut ffi::ctypes::c_void,
    pub length: __u16,
    pub flags: __u16,
}
impl Default for iw_point {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct iw_freq {
    pub m: __s32,
    pub e: __s16,
    pub i: __u8,
    pub flags: __u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct iw_quality {
    pub qual: __u8,
    pub level: __u8,
    pub noise: __u8,
    pub updated: __u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct iw_discarded {
    pub nwid: __u32,
    pub code: __u32,
    pub fragment: __u32,
    pub retries: __u32,
    pub misc: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct iw_missed {
    pub beacon: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct iw_thrspy {
    pub addr: sockaddr_t,
    pub qual: iw_quality,
    pub low: iw_quality,
    pub high: iw_quality,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct iw_scan_req {
    pub scan_type: __u8,
    pub essid_len: __u8,
    pub num_channels: __u8,
    pub flags: __u8,
    pub bssid: sockaddr_t,
    pub essid: [__u8; 32usize],
    pub min_channel_time: __u32,
    pub max_channel_time: __u32,
    pub channel_list: [iw_freq; 32usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct iw_encode_ext {
    pub ext_flags: __u32,
    pub tx_seq: [__u8; 8usize],
    pub rx_seq: [__u8; 8usize],
    pub addr: sockaddr_t,
    pub alg: __u16,
    pub key_len: __u16,
    pub key: __IncompleteArrayField<__u8>,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct iw_mlme {
    pub cmd: __u16,
    pub reason_code: __u16,
    pub addr: sockaddr_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct iw_pmksa {
    pub cmd: __u32,
    pub bssid: sockaddr_t,
    pub pmkid: [__u8; 16usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct iw_michaelmicfailure {
    pub flags: __u32,
    pub src_addr: sockaddr_t,
    pub tsc: [__u8; 8usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct iw_pmkid_cand {
    pub flags: __u32,
    pub index: __u32,
    pub bssid: sockaddr_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct iw_statistics {
    pub status: __u16,
    pub qual: iw_quality,
    pub discard: iw_discarded,
    pub miss: iw_missed,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iwreq_data {
    pub name: [ffi::ctypes::c_char; 16usize],
    pub essid: iw_point,
    pub nwid: iw_param,
    pub freq: iw_freq,
    pub sens: iw_param,
    pub snr: iw_param,
    pub bitrate: iw_param,
    pub txpower: iw_param,
    pub rts: iw_param,
    pub frag: iw_param,
    pub mode: __u32,
    pub retry: iw_param,
    pub encoding: iw_point,
    pub power: iw_param,
    pub qual: iw_quality,
    pub ap_addr: sockaddr_t,
    pub addr: sockaddr_t,
    pub param: iw_param,
    pub data: iw_point,
    pub passphrase: iw_point,
    _bindgen_union_align: [u64; 2usize],
}
impl Default for iwreq_data {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for iwreq_data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "iwreq_data {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iwreq {
    pub ifr_name: [ffi::ctypes::c_char; 16usize],
    pub u: iwreq_data,
}
impl Default for iwreq {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for iwreq {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "iwreq {{ ifr_name: {:?}, u: {:?} }}",
            self.ifr_name, self.u
        )
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct iw_range {
    pub throughput: __u32,
    pub min_nwid: __u32,
    pub max_nwid: __u32,
    pub old_num_channels: __u16,
    pub old_num_frequency: __u8,
    pub event_capa: [__u32; 6usize],
    pub sensitivity: __s32,
    pub max_qual: iw_quality,
    pub avg_qual: iw_quality,
    pub num_bitrates: __u8,
    pub bitrate: [__s32; 32usize],
    pub min_rts: __s32,
    pub max_rts: __s32,
    pub min_frag: __s32,
    pub max_frag: __s32,
    pub min_pmp: __s32,
    pub max_pmp: __s32,
    pub min_pmt: __s32,
    pub max_pmt: __s32,
    pub pmp_flags: __u16,
    pub pmt_flags: __u16,
    pub pm_capa: __u16,
    pub encoding_size: [__u16; 8usize],
    pub num_encoding_sizes: __u8,
    pub max_encoding_tokens: __u8,
    pub encoding_login_index: __u8,
    pub txpower_capa: __u16,
    pub num_txpower: __u8,
    pub txpower: [__s32; 8usize],
    pub we_version_compiled: __u8,
    pub we_version_source: __u8,
    pub retry_capa: __u16,
    pub retry_flags: __u16,
    pub r_time_flags: __u16,
    pub min_retry: __s32,
    pub max_retry: __s32,
    pub min_r_time: __s32,
    pub max_r_time: __s32,
    pub num_channels: __u16,
    pub num_frequency: __u8,
    pub freq: [iw_freq; 32usize],
    pub enc_capa: __u32,
    pub min_pms: __s32,
    pub max_pms: __s32,
    pub pms_flags: __u16,
    pub modul_capa: __s32,
    pub bitrate_capa: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct iw_priv_args {
    pub cmd: __u32,
    pub set_args: __u16,
    pub get_args: __u16,
    pub name: [ffi::ctypes::c_char; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iw_event {
    pub len: __u16,
    pub cmd: __u16,
    pub u: iwreq_data,
}
impl Default for iw_event {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for iw_event {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "iw_event {{ len: {:?}, cmd: {:?}, u: {:?} }}",
            self.len, self.cmd, self.u
        )
    }
}
extern "C" {
    pub static mut g_user_ap_sta_num: ffi::ctypes::c_uchar;
}
extern "C" {
    pub fn rltk_wlan_init(idx_wlan: ffi::ctypes::c_int, mode: rtw_mode_t) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rltk_wlan_deinit();
}
extern "C" {
    pub fn rltk_wlan_deinit_fastly();
}
extern "C" {
    pub fn rltk_wlan_start(idx_wlan: ffi::ctypes::c_int) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rltk_wlan_statistic(idx: ffi::ctypes::c_uchar);
}
extern "C" {
    pub fn rltk_wlan_running(idx: ffi::ctypes::c_uchar) -> ffi::ctypes::c_uchar;
}
extern "C" {
    pub fn rltk_wlan_control(
        cmd: ffi::ctypes::c_ulong,
        data: *mut ffi::ctypes::c_void,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rltk_wlan_handshake_done() -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rltk_wlan_rf_on() -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rltk_wlan_rf_off() -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rltk_wlan_check_bus() -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rltk_wlan_wireless_mode(mode: ffi::ctypes::c_uchar) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rltk_wlan_get_wireless_mode(pmode: *mut ffi::ctypes::c_uchar) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rltk_wlan_set_wps_phase(is_trigger_wps: ffi::ctypes::c_uchar) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtw_ps_enable(enable: ffi::ctypes::c_int) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rltk_wlan_is_connected_to_ap() -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rltk_wlan_btcoex_set_bt_state(state: ffi::ctypes::c_uchar);
}
extern "C" {
    pub fn rltk_wlan_set_scan_chan_interval(interval_ms: ffi::ctypes::c_ushort);
}
extern "C" {
    pub fn rltk_wlan_change_channel_plan(channel_plan: ffi::ctypes::c_uchar) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rltk_wlan_enable_adaptivity(enable: ffi::ctypes::c_uchar);
}
extern "C" {
    pub fn rltk_wlan_set_adaptivity_mode(mode: ffi::ctypes::c_uchar);
}
extern "C" {
    pub fn rltk_wlan_enable_trp_tis_cert(enable: ffi::ctypes::c_uchar);
}
extern "C" {
    pub fn rltk_wlan_set_tx_pwr_lmt(value: ffi::ctypes::c_uchar);
}
extern "C" {
    pub fn rltk_wlan_set_tx_pwr_by_rate(value: ffi::ctypes::c_uchar);
}
extern "C" {
    pub fn rltk_wlan_enable_powersave(enable: ffi::ctypes::c_uchar);
}
extern "C" {
    pub fn rltk_psk_essid_set(index: ffi::ctypes::c_uchar, value: ffi::ctypes::c_int);
}
extern "C" {
    pub fn rltk_psk_essid_strncpy_to(
        index: ffi::ctypes::c_uchar,
        src: *const ffi::ctypes::c_char,
        length: ffi::ctypes::c_uint,
    );
}
extern "C" {
    pub fn rltk_psk_essid_memcpy_to(index: ffi::ctypes::c_uchar, src: *mut ffi::ctypes::c_uchar);
}
extern "C" {
    pub fn rltk_psk_essid_memcpy_from(
        index: ffi::ctypes::c_uchar,
        dst: *mut ffi::ctypes::c_uchar,
        length: ffi::ctypes::c_uint,
    );
}
extern "C" {
    pub fn rltk_psk_essid_strcpy(index: ffi::ctypes::c_uchar, dst: *mut ffi::ctypes::c_uchar);
}
extern "C" {
    pub fn rltk_psk_essid_strlen() -> ffi::ctypes::c_uint;
}
extern "C" {
    pub fn rltk_psk_passphrase_set(index: ffi::ctypes::c_uchar, value: ffi::ctypes::c_int);
}
extern "C" {
    pub fn rltk_psk_passphrase_memcpy_to(
        index: ffi::ctypes::c_uchar,
        src: *mut ffi::ctypes::c_uchar,
    );
}
extern "C" {
    pub fn rltk_psk_passphrase_memcpy_from(
        index: ffi::ctypes::c_uchar,
        dst: *mut ffi::ctypes::c_uchar,
        length: ffi::ctypes::c_uint,
    );
}
extern "C" {
    pub fn rltk_psk_passphrase_get() -> *mut ffi::ctypes::c_uchar;
}
extern "C" {
    pub fn rltk_psk_passphrase_strlen() -> ffi::ctypes::c_uint;
}
extern "C" {
    pub fn rltk_wpa_global_PSK_set(index: ffi::ctypes::c_uchar, value: ffi::ctypes::c_int);
}
extern "C" {
    pub fn rltk_psk_passphrase64_memcpy_from(
        dst: *mut ffi::ctypes::c_uchar,
        length: ffi::ctypes::c_uint,
    );
}
extern "C" {
    pub fn rltk_psk_passphrase64_strlen() -> ffi::ctypes::c_uint;
}
extern "C" {
    pub fn rltk_wpa_global_PSK_memcpy_from(
        index: ffi::ctypes::c_uchar,
        dst: *mut ffi::ctypes::c_uchar,
        length: ffi::ctypes::c_uint,
    );
}
extern "C" {
    pub fn rltk_wpa_global_PSK_memcpy_to(
        index: ffi::ctypes::c_uchar,
        src: *mut ffi::ctypes::c_uchar,
    );
}
extern "C" {
    pub fn wext_get_ssid(ifname: *const ffi::ctypes::c_char, ssid: *mut __u8)
        -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_ssid(
        ifname: *const ffi::ctypes::c_char,
        ssid: *const __u8,
        ssid_len: __u16,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_bssid(
        ifname: *const ffi::ctypes::c_char,
        bssid: *const __u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_get_bssid(
        ifname: *const ffi::ctypes::c_char,
        bssid: *mut __u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_auth_param(
        ifname: *const ffi::ctypes::c_char,
        idx: __u16,
        value: __u32,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_mfp_support(
        ifname: *const ffi::ctypes::c_char,
        value: __u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_key_ext(
        ifname: *const ffi::ctypes::c_char,
        alg: __u16,
        addr: *const __u8,
        key_idx: ffi::ctypes::c_int,
        set_tx: ffi::ctypes::c_int,
        seq: *const __u8,
        seq_len: __u16,
        key: *mut __u8,
        key_len: __u16,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_get_enc_ext(
        ifname: *const ffi::ctypes::c_char,
        alg: *mut __u16,
        key_idx: *mut __u8,
        passphrase: *mut __u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_passphrase(
        ifname: *const ffi::ctypes::c_char,
        passphrase: *const __u8,
        passphrase_len: __u16,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_get_passphrase(
        ifname: *const ffi::ctypes::c_char,
        passphrase: *mut __u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_mode(
        ifname: *const ffi::ctypes::c_char,
        mode: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_get_mode(
        ifname: *const ffi::ctypes::c_char,
        mode: *mut ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_ap_ssid(
        ifname: *const ffi::ctypes::c_char,
        ssid: *const __u8,
        ssid_len: __u16,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_country(
        ifname: *const ffi::ctypes::c_char,
        country_code: rtw_country_code_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_get_rssi(
        ifname: *const ffi::ctypes::c_char,
        rssi: *mut ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_get_snr(
        ifname: *const ffi::ctypes::c_char,
        snr: *mut ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_channel(ifname: *const ffi::ctypes::c_char, ch: __u8) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_get_channel(
        ifname: *const ffi::ctypes::c_char,
        ch: *mut __u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_register_multicast_address(
        ifname: *const ffi::ctypes::c_char,
        mac: *mut rtw_mac_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_unregister_multicast_address(
        ifname: *const ffi::ctypes::c_char,
        mac: *mut rtw_mac_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_scan(
        ifname: *const ffi::ctypes::c_char,
        buf: *mut ffi::ctypes::c_char,
        buf_len: __u16,
        flags: __u16,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_get_scan(
        ifname: *const ffi::ctypes::c_char,
        buf: *mut ffi::ctypes::c_char,
        buf_len: __u16,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_mac_address(
        ifname: *const ffi::ctypes::c_char,
        mac: *mut ffi::ctypes::c_char,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_get_mac_address(
        ifname: *const ffi::ctypes::c_char,
        mac: *mut ffi::ctypes::c_char,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_enable_powersave(
        ifname: *const ffi::ctypes::c_char,
        lps_mode: __u8,
        ips_mode: __u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_resume_powersave(ifname: *const ffi::ctypes::c_char) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_disable_powersave(ifname: *const ffi::ctypes::c_char) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_tdma_param(
        ifname: *const ffi::ctypes::c_char,
        slot_period: __u8,
        rfon_period_len_1: __u8,
        rfon_period_len_2: __u8,
        rfon_period_len_3: __u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_lps_dtim(
        ifname: *const ffi::ctypes::c_char,
        lps_dtim: __u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_get_lps_dtim(
        ifname: *const ffi::ctypes::c_char,
        lps_dtim: *mut __u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_lps_thresh(
        ifname: *const ffi::ctypes::c_char,
        low_thresh: __u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_beacon_mode(
        ifname: *const ffi::ctypes::c_char,
        mode: __u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_lps_level(
        ifname: *const ffi::ctypes::c_char,
        lps_level: __u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_get_tx_power(
        ifname: *const ffi::ctypes::c_char,
        poweridx: *mut __u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_txpower(
        ifname: *const ffi::ctypes::c_char,
        poweridx: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_get_associated_client_list(
        ifname: *const ffi::ctypes::c_char,
        client_list_buffer: *mut ffi::ctypes::c_void,
        buffer_length: __u16,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_get_ap_info(
        ifname: *const ffi::ctypes::c_char,
        ap_info: *mut rtw_bss_info_t,
        security: *mut rtw_security_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_mp_command(
        ifname: *const ffi::ctypes::c_char,
        cmd: *mut ffi::ctypes::c_char,
        show_msg: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_private_command(
        ifname: *const ffi::ctypes::c_char,
        cmd: *mut ffi::ctypes::c_char,
        show_msg: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_private_command_with_retval(
        ifname: *const ffi::ctypes::c_char,
        cmd: *mut ffi::ctypes::c_char,
        ret_buf: *mut ffi::ctypes::c_char,
        ret_len: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_wlan_indicate(
        cmd: ffi::ctypes::c_uint,
        wrqu: *mut iwreq_data,
        extra: *mut ffi::ctypes::c_char,
    );
}
extern "C" {
    pub fn wext_set_pscan_channel(
        ifname: *const ffi::ctypes::c_char,
        ch: *mut __u8,
        pscan_config: *mut __u8,
        length: __u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_autoreconnect(
        ifname: *const ffi::ctypes::c_char,
        mode: __u8,
        retry_times: __u8,
        timeout: __u16,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_get_autoreconnect(
        ifname: *const ffi::ctypes::c_char,
        mode: *mut __u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_adaptivity(adaptivity_mode: rtw_adaptivity_mode_t) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_adaptivity_th_l2h_ini(l2h_threshold: __u8) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_trp_tis(enable: __u8) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_support_wpa3(enable: __u8) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_get_auto_chl(
        ifname: *const ffi::ctypes::c_char,
        channel_set: *mut ffi::ctypes::c_uchar,
        channel_num: ffi::ctypes::c_uchar,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_sta_num(ap_sta_num: ffi::ctypes::c_uchar) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_del_station(
        ifname: *const ffi::ctypes::c_char,
        hwaddr: *mut ffi::ctypes::c_uchar,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_init_mac_filter() -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_deinit_mac_filter() -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_add_mac_filter(hwaddr: *mut ffi::ctypes::c_uchar) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_del_mac_filter(hwaddr: *mut ffi::ctypes::c_uchar) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_indicate_mgnt(enable: ffi::ctypes::c_int);
}
extern "C" {
    pub fn wext_add_custom_ie(
        ifname: *const ffi::ctypes::c_char,
        cus_ie: *mut ffi::ctypes::c_void,
        ie_num: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_update_custom_ie(
        ifname: *const ffi::ctypes::c_char,
        cus_ie: *mut ffi::ctypes::c_void,
        ie_index: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_del_custom_ie(ifname: *const ffi::ctypes::c_char) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_send_mgnt(
        ifname: *const ffi::ctypes::c_char,
        buf: *mut ffi::ctypes::c_char,
        buf_len: __u16,
        flags: __u16,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_send_eapol(
        ifname: *const ffi::ctypes::c_char,
        buf: *mut ffi::ctypes::c_char,
        buf_len: __u16,
        flags: __u16,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_gen_ie(
        ifname: *const ffi::ctypes::c_char,
        buf: *mut ffi::ctypes::c_char,
        buf_len: __u16,
        flags: __u16,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_get_drv_ability(
        ifname: *const ffi::ctypes::c_char,
        ability: *mut __u32,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_enable_forwarding(ifname: *const ffi::ctypes::c_char) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_disable_forwarding(ifname: *const ffi::ctypes::c_char) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_set_ch_deauth(
        ifname: *const ffi::ctypes::c_char,
        enable: __u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_wowlan_ctrl(
        ifname: *const ffi::ctypes::c_char,
        enable: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_wowlan_set_pattern(
        ifname: *const ffi::ctypes::c_char,
        pattern: wowlan_pattern_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wext_wlan_redl_fw(ifname: *const ffi::ctypes::c_char) -> ffi::ctypes::c_int;
}
extern "C" {
    pub static mut p_wlan_mgmt_filter: ::core::option::Option<
        unsafe extern "C" fn(ie: *mut __u8, ie_len: __u16, frame_type: __u16) -> ffi::ctypes::c_int,
    >;
}
extern "C" {
    pub static mut p_wlan_action_filter: ::core::option::Option<
        unsafe extern "C" fn(ie: *mut __u8, ie_len: __u16, frame_type: __u16) -> ffi::ctypes::c_int,
    >;
}
pub type rtw_event_handler_t = ::core::option::Option<
    unsafe extern "C" fn(
        buf: *mut ffi::ctypes::c_char,
        buf_len: ffi::ctypes::c_int,
        flags: ffi::ctypes::c_int,
        handler_user_data: *mut ffi::ctypes::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct event_list_elem_t {
    pub handler: rtw_event_handler_t,
    pub handler_user_data: *mut ffi::ctypes::c_void,
}
impl Default for event_list_elem_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn init_event_callback_list();
}
extern "C" {
    pub fn wifi_indication(
        event: rtw_event_indicate_t,
        buf: *mut ffi::ctypes::c_char,
        buf_len: ffi::ctypes::c_int,
        flags: ffi::ctypes::c_int,
    );
}
extern "C" {
    pub fn wifi_reg_event_handler(
        event_cmds: ffi::ctypes::c_uint,
        handler_func: rtw_event_handler_t,
        handler_user_data: *mut ffi::ctypes::c_void,
    );
}
extern "C" {
    pub fn wifi_unreg_event_handler(
        event_cmds: ffi::ctypes::c_uint,
        handler_func: rtw_event_handler_t,
    );
}
pub const _WL_BAND_TYPE_WL_BAND_2_4G: _WL_BAND_TYPE = 0;
pub const _WL_BAND_TYPE_WL_BAND_5G: _WL_BAND_TYPE = 1;
pub const _WL_BAND_TYPE_WL_BAND_2_4G_5G_BOTH: _WL_BAND_TYPE = 2;
pub const _WL_BAND_TYPE_WL_BANDMAX: _WL_BAND_TYPE = 3;
pub type _WL_BAND_TYPE = ffi::ctypes::c_uint;
pub use self::_WL_BAND_TYPE as WL_BAND_TYPE;
pub type PWL_BAND_TYPE = *mut _WL_BAND_TYPE;
pub type rtw_scan_result_callback_t = ::core::option::Option<
    unsafe extern "C" fn(
        result_ptr: *mut *mut rtw_scan_result_t,
        user_data: *mut ffi::ctypes::c_void,
    ),
>;
pub type rtw_scan_result_handler_t = ::core::option::Option<
    unsafe extern "C" fn(malloced_scan_result: *mut rtw_scan_handler_result_t) -> rtw_result_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scan_buf_arg {
    pub buf: *mut ffi::ctypes::c_char,
    pub buf_len: ffi::ctypes::c_int,
}
impl Default for scan_buf_arg {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct internal_scan_handler {
    pub pap_details: *mut *mut rtw_scan_result_t,
    pub ap_details: *mut rtw_scan_result_t,
    pub scan_cnt: ffi::ctypes::c_int,
    pub scan_complete: rtw_bool_t,
    pub max_ap_size: ffi::ctypes::c_uchar,
    pub gscan_result_handler: rtw_scan_result_handler_t,
    pub scan_running: ffi::ctypes::c_int,
    pub user_data: *mut ffi::ctypes::c_void,
    pub scan_start_time: ffi::ctypes::c_uint,
}
impl Default for internal_scan_handler {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type internal_scan_handler_t = internal_scan_handler;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct internal_join_result_t {
    pub network_info: rtw_network_info_t,
    pub join_sema: *mut ffi::ctypes::c_void,
}
impl Default for internal_join_result_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for internal_join_result_t {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "internal_join_result_t {{ network_info: {:?}, join_sema: {:?} }}",
            self.network_info, self.join_sema
        )
    }
}
extern "C" {
    pub fn wifi_manager_init() -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_connect(
        ssid: *mut ffi::ctypes::c_char,
        security_type: rtw_security_t,
        password: *mut ffi::ctypes::c_char,
        ssid_len: ffi::ctypes::c_int,
        password_len: ffi::ctypes::c_int,
        key_id: ffi::ctypes::c_int,
        semaphore: *mut ffi::ctypes::c_void,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_connect_bssid(
        bssid: *mut ffi::ctypes::c_uchar,
        ssid: *mut ffi::ctypes::c_char,
        security_type: rtw_security_t,
        password: *mut ffi::ctypes::c_char,
        bssid_len: ffi::ctypes::c_int,
        ssid_len: ffi::ctypes::c_int,
        password_len: ffi::ctypes::c_int,
        key_id: ffi::ctypes::c_int,
        semaphore: *mut ffi::ctypes::c_void,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_disconnect() -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_is_connected_to_ap() -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_is_up(interface: rtw_interface_t) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_is_ready_to_transceive(interface: rtw_interface_t) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_set_mac_address(mac: *mut ffi::ctypes::c_char) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_get_mac_address(mac: *mut ffi::ctypes::c_char) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_enable_powersave() -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_resume_powersave() -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_disable_powersave() -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_get_txpower(poweridx: *mut ffi::ctypes::c_int) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_set_txpower(poweridx: ffi::ctypes::c_int) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_get_associated_client_list(
        client_list_buffer: *mut ffi::ctypes::c_void,
        buffer_length: ffi::ctypes::c_ushort,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_get_ap_bssid(bssid: *mut ffi::ctypes::c_uchar) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_get_ap_info(
        ap_info: *mut rtw_bss_info_t,
        security: *mut rtw_security_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_set_country(country_code: rtw_country_code_t) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_get_sta_max_data_rate(inidata_rate: *mut __u8) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_get_rssi(pRSSI: *mut ffi::ctypes::c_int) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_get_snr(pSNR: *mut ffi::ctypes::c_int) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_set_channel(channel: ffi::ctypes::c_int) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_get_channel(channel: *mut ffi::ctypes::c_int) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_change_channel_plan(channel_plan: u8) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_register_multicast_address(mac: *mut rtw_mac_t) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_unregister_multicast_address(mac: *mut rtw_mac_t) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_set_mib();
}
extern "C" {
    pub fn wifi_set_country_code();
}
extern "C" {
    pub fn wifi_rf_on() -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_rf_off() -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_on(mode: rtw_mode_t) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_off() -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_set_mode(mode: rtw_mode_t) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_off_fastly() -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_set_power_mode(
        ips_mode: ffi::ctypes::c_uchar,
        lps_mode: ffi::ctypes::c_uchar,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_set_tdma_param(
        slot_period: ffi::ctypes::c_uchar,
        rfon_period_len_1: ffi::ctypes::c_uchar,
        rfon_period_len_2: ffi::ctypes::c_uchar,
        rfon_period_len_3: ffi::ctypes::c_uchar,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_set_lps_dtim(dtim: ffi::ctypes::c_uchar) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_get_lps_dtim(dtim: *mut ffi::ctypes::c_uchar) -> ffi::ctypes::c_int;
}
pub const LPS_THRESH_PKT_COUNT: ffi::ctypes::c_uint = 0;
pub const LPS_THRESH_DIRECT_ENTER: ffi::ctypes::c_uint = 1;
pub const LPS_THRESH_TP: ffi::ctypes::c_uint = 2;
pub type _bindgen_ty_24 = ffi::ctypes::c_uint;
pub type rtw_lps_thresh_t = ffi::ctypes::c_uchar;
extern "C" {
    pub fn wifi_set_lps_thresh(mode: rtw_lps_thresh_t) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_set_lps_level(lps_level: ffi::ctypes::c_uchar) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_set_mfp_support(value: ffi::ctypes::c_uchar) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_start_ap(
        ssid: *mut ffi::ctypes::c_char,
        security_type: rtw_security_t,
        password: *mut ffi::ctypes::c_char,
        ssid_len: ffi::ctypes::c_int,
        password_len: ffi::ctypes::c_int,
        channel: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_start_ap_with_hidden_ssid(
        ssid: *mut ffi::ctypes::c_char,
        security_type: rtw_security_t,
        password: *mut ffi::ctypes::c_char,
        ssid_len: ffi::ctypes::c_int,
        password_len: ffi::ctypes::c_int,
        channel: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_scan(
        scan_type: rtw_scan_type_t,
        bss_type: rtw_bss_type_t,
        result_ptr: *mut ffi::ctypes::c_void,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_scan_networks(
        results_handler: rtw_scan_result_handler_t,
        user_data: *mut ffi::ctypes::c_void,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_scan_networks_mcc(
        results_handler: rtw_scan_result_handler_t,
        user_data: *mut ffi::ctypes::c_void,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_scan_networks_with_ssid(
        results_handler: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ffi::ctypes::c_char,
                arg2: ffi::ctypes::c_int,
                arg3: *mut ffi::ctypes::c_char,
                arg4: *mut ffi::ctypes::c_void,
            ) -> ffi::ctypes::c_int,
        >,
        user_data: *mut ffi::ctypes::c_void,
        scan_buflen: ffi::ctypes::c_int,
        ssid: *mut ffi::ctypes::c_char,
        ssid_len: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_set_pscan_chan(
        channel_list: *mut __u8,
        pscan_config: *mut __u8,
        length: __u8,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_get_setting(
        ifname: *const ffi::ctypes::c_char,
        pSetting: *mut rtw_wifi_setting_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_show_setting(
        ifname: *const ffi::ctypes::c_char,
        pSetting: *mut rtw_wifi_setting_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_set_network_mode(mode: rtw_network_mode_t) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_get_network_mode(pmode: *mut rtw_network_mode_t) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_set_promisc(
        enabled: rtw_rcr_level_t,
        callback: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ffi::ctypes::c_uchar,
                arg2: ffi::ctypes::c_uint,
                arg3: *mut ffi::ctypes::c_void,
            ),
        >,
        len_used: ffi::ctypes::c_uchar,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_enter_promisc_mode();
}
extern "C" {
    pub fn wifi_set_wps_phase(is_trigger_wps: ffi::ctypes::c_uchar) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_restart_ap(
        ssid: *mut ffi::ctypes::c_uchar,
        security_type: rtw_security_t,
        password: *mut ffi::ctypes::c_uchar,
        ssid_len: ffi::ctypes::c_int,
        password_len: ffi::ctypes::c_int,
        channel: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_config_autoreconnect(
        mode: __u8,
        retry_times: __u8,
        timeout: __u16,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_set_autoreconnect(mode: __u8) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_get_autoreconnect(mode: *mut __u8) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_get_last_error() -> ffi::ctypes::c_int;
}
pub const CUSTOM_IE_TYPE_PROBE_REQ: CUSTOM_IE_TYPE = 1;
pub const CUSTOM_IE_TYPE_PROBE_RSP: CUSTOM_IE_TYPE = 2;
pub const CUSTOM_IE_TYPE_BEACON: CUSTOM_IE_TYPE = 4;
pub const CUSTOM_IE_TYPE_ASSOC_REQ: CUSTOM_IE_TYPE = 8;
pub type CUSTOM_IE_TYPE = ffi::ctypes::c_uint;
pub type rtw_custom_ie_type_t = __u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cus_ie {
    pub ie: *mut __u8,
    pub type_: __u8,
}
impl Default for _cus_ie {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type rtw_custom_ie_t = _cus_ie;
pub type p_rtw_custom_ie_t = *mut _cus_ie;
extern "C" {
    pub fn wifi_add_custom_ie(
        cus_ie: *mut ffi::ctypes::c_void,
        ie_num: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_update_custom_ie(
        cus_ie: *mut ffi::ctypes::c_void,
        ie_index: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_del_custom_ie() -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_init_packet_filter();
}
extern "C" {
    pub fn wifi_add_packet_filter(
        filter_id: ffi::ctypes::c_uchar,
        patt: *mut rtw_packet_filter_pattern_t,
        rule: rtw_packet_filter_rule_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_enable_packet_filter(filter_id: ffi::ctypes::c_uchar) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_disable_packet_filter(filter_id: ffi::ctypes::c_uchar) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_remove_packet_filter(filter_id: ffi::ctypes::c_uchar) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_retransmit_packet_filter(enable: u8, filter_interval_ms: u8) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_filter_by_ap_and_phone_mac(
        enable: u8,
        ap_mac: *mut ffi::ctypes::c_void,
        phone_mac: *mut ffi::ctypes::c_void,
    );
}
extern "C" {
    pub fn wifi_promisc_ctrl_packet_rpt(enable: u8) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_get_antenna_info(antenna: *mut ffi::ctypes::c_uchar) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_set_indicate_mgnt(enable: ffi::ctypes::c_int);
}
extern "C" {
    pub fn wifi_get_drv_ability(ability: *mut u32) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_set_channel_plan(channel_plan: u8) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_get_channel_plan(channel_plan: *mut u8) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_enable_forwarding() -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_disable_forwarding() -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_set_ch_deauth(enable: __u8) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_set_ap_polling_sta(enabled: __u8);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wowlan_pattern_param_t {
    pub filter_id: ffi::ctypes::c_uint,
    pub polarity: ffi::ctypes::c_uint,
    pub type_: ffi::ctypes::c_uint,
    pub offset: ffi::ctypes::c_uint,
    pub bitmask: *mut ffi::ctypes::c_uchar,
    pub pattern: *mut ffi::ctypes::c_uchar,
}
impl Default for wowlan_pattern_param_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn wifi_wowlan_ctrl(enable: ffi::ctypes::c_int) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn wifi_wowlan_set_pattern(pattern: wowlan_pattern_t) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn rtw_rf_cmd(Status: u32);
}
extern "C" {
    pub fn rtw_get_tsf(Port: u32) -> u32;
}
extern "C" {
    pub fn wifi_get_band_type() -> WL_BAND_TYPE;
}
extern "C" {
    pub fn sys_now() -> ffi::ctypes::c_uint;
}
extern "C" {
    pub fn lwip_init();
}
pub type u8_t = ffi::ctypes::c_uchar;
pub type s8_t = ffi::ctypes::c_schar;
pub type u16_t = ffi::ctypes::c_ushort;
pub type s16_t = ffi::ctypes::c_short;
pub type u32_t = ffi::ctypes::c_uint;
pub type s32_t = ffi::ctypes::c_long;
pub type mem_ptr_t = u32_t;
pub type sys_prot_t = ffi::ctypes::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
extern "C" {
    pub fn imaxabs(j: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(numer: intmax_t, denomer: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        arg1: *const ffi::ctypes::c_char,
        arg2: *mut *mut ffi::ctypes::c_char,
        arg3: ffi::ctypes::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        arg1: *const ffi::ctypes::c_char,
        arg2: *mut *mut ffi::ctypes::c_char,
        arg3: ffi::ctypes::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        arg1: *const wchar_t,
        arg2: *mut *mut wchar_t,
        arg3: ffi::ctypes::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        arg1: *const wchar_t,
        arg2: *mut *mut wchar_t,
        arg3: ffi::ctypes::c_int,
    ) -> uintmax_t;
}
pub type err_t = s8_t;
pub const err_enum_t_ERR_OK: err_enum_t = 0;
pub const err_enum_t_ERR_MEM: err_enum_t = -1;
pub const err_enum_t_ERR_BUF: err_enum_t = -2;
pub const err_enum_t_ERR_TIMEOUT: err_enum_t = -3;
pub const err_enum_t_ERR_RTE: err_enum_t = -4;
pub const err_enum_t_ERR_INPROGRESS: err_enum_t = -5;
pub const err_enum_t_ERR_VAL: err_enum_t = -6;
pub const err_enum_t_ERR_WOULDBLOCK: err_enum_t = -7;
pub const err_enum_t_ERR_USE: err_enum_t = -8;
pub const err_enum_t_ERR_ALREADY: err_enum_t = -9;
pub const err_enum_t_ERR_ISCONN: err_enum_t = -10;
pub const err_enum_t_ERR_CONN: err_enum_t = -11;
pub const err_enum_t_ERR_IF: err_enum_t = -12;
pub const err_enum_t_ERR_ABRT: err_enum_t = -13;
pub const err_enum_t_ERR_RST: err_enum_t = -14;
pub const err_enum_t_ERR_CLSD: err_enum_t = -15;
pub const err_enum_t_ERR_ARG: err_enum_t = -16;
pub type err_enum_t = ffi::ctypes::c_int;
extern "C" {
    pub fn err_to_errno(err: err_t) -> ffi::ctypes::c_int;
}
pub type sys_sem_t = SemaphoreHandle_t;
pub type sys_mutex_t = SemaphoreHandle_t;
pub type sys_mbox_t = QueueHandle_t;
pub type sys_thread_t = TaskHandle_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _sys_arch_state_t {
    pub cTaskName: [ffi::ctypes::c_char; 10usize],
    pub nStackDepth: ffi::ctypes::c_ushort,
    pub nTaskCount: ffi::ctypes::c_ushort,
}
pub type sys_arch_state_t = _sys_arch_state_t;
pub type lwip_thread_fn =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut ffi::ctypes::c_void)>;
extern "C" {
    pub fn sys_sem_new(sem: *mut sys_sem_t, count: u8_t) -> err_t;
}
extern "C" {
    pub fn sys_sem_signal(sem: *mut sys_sem_t);
}
extern "C" {
    pub fn sys_arch_sem_wait(sem: *mut sys_sem_t, timeout: u32_t) -> u32_t;
}
extern "C" {
    pub fn sys_sem_free(sem: *mut sys_sem_t);
}
extern "C" {
    pub fn sys_sem_valid(sem: *mut sys_sem_t) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn sys_sem_set_invalid(sem: *mut sys_sem_t);
}
extern "C" {
    pub fn sys_msleep(ms: u32_t);
}
extern "C" {
    pub fn sys_mbox_new(mbox: *mut sys_mbox_t, size: ffi::ctypes::c_int) -> err_t;
}
extern "C" {
    pub fn sys_mbox_post(mbox: *mut sys_mbox_t, msg: *mut ffi::ctypes::c_void);
}
extern "C" {
    pub fn sys_mbox_trypost(mbox: *mut sys_mbox_t, msg: *mut ffi::ctypes::c_void) -> err_t;
}
extern "C" {
    pub fn sys_arch_mbox_fetch(
        mbox: *mut sys_mbox_t,
        msg: *mut *mut ffi::ctypes::c_void,
        timeout: u32_t,
    ) -> u32_t;
}
extern "C" {
    pub fn sys_arch_mbox_tryfetch(
        mbox: *mut sys_mbox_t,
        msg: *mut *mut ffi::ctypes::c_void,
    ) -> u32_t;
}
extern "C" {
    pub fn sys_mbox_free(mbox: *mut sys_mbox_t);
}
extern "C" {
    pub fn sys_mbox_valid(mbox: *mut sys_mbox_t) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn sys_mbox_set_invalid(mbox: *mut sys_mbox_t);
}
extern "C" {
    pub fn sys_thread_new(
        name: *const ffi::ctypes::c_char,
        thread: lwip_thread_fn,
        arg: *mut ffi::ctypes::c_void,
        stacksize: ffi::ctypes::c_int,
        prio: ffi::ctypes::c_int,
    ) -> sys_thread_t;
}
extern "C" {
    pub fn sys_thread_new_tcm(
        name: *const ffi::ctypes::c_char,
        thread: lwip_thread_fn,
        arg: *mut ffi::ctypes::c_void,
        stacksize: ffi::ctypes::c_int,
        prio: ffi::ctypes::c_int,
    ) -> sys_thread_t;
}
extern "C" {
    pub fn sys_init();
}
extern "C" {
    pub fn sys_jiffies() -> u32_t;
}
extern "C" {
    pub fn sys_arch_protect() -> sys_prot_t;
}
extern "C" {
    pub fn sys_arch_unprotect(pval: sys_prot_t);
}
pub type lwip_cyclic_timer_handler = ::core::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct lwip_cyclic_timer {
    pub interval_ms: u32_t,
    pub handler: lwip_cyclic_timer_handler,
}
extern "C" {
    pub static mut lwip_cyclic_timers: [lwip_cyclic_timer; 0usize];
}
pub type sys_timeout_handler =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut ffi::ctypes::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sys_timeo {
    pub next: *mut sys_timeo,
    pub time: u32_t,
    pub h: sys_timeout_handler,
    pub arg: *mut ffi::ctypes::c_void,
}
impl Default for sys_timeo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn sys_timeouts_init();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sys_timeouts {
    pub next: *mut sys_timeo,
}
impl Default for sys_timeouts {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn sys_arch_timeouts() -> *mut sys_timeouts;
}
extern "C" {
    pub fn sys_timeout(msecs: u32_t, handler: sys_timeout_handler, arg: *mut ffi::ctypes::c_void);
}
extern "C" {
    pub fn sys_untimeout(handler: sys_timeout_handler, arg: *mut ffi::ctypes::c_void);
}
extern "C" {
    pub fn sys_restart_timeouts();
}
extern "C" {
    pub fn sys_timeouts_mbox_fetch(mbox: *mut sys_mbox_t, msg: *mut *mut ffi::ctypes::c_void);
}
extern "C" {
    pub fn lwip_htons(x: u16_t) -> u16_t;
}
extern "C" {
    pub fn lwip_htonl(x: u32_t) -> u32_t;
}
extern "C" {
    pub fn lwip_itoa(result: *mut ffi::ctypes::c_char, bufsize: size_t, number: ffi::ctypes::c_int);
}
extern "C" {
    pub fn lwip_strnicmp(
        str1: *const ffi::ctypes::c_char,
        str2: *const ffi::ctypes::c_char,
        len: size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn lwip_stricmp(
        str1: *const ffi::ctypes::c_char,
        str2: *const ffi::ctypes::c_char,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn lwip_strnstr(
        buffer: *const ffi::ctypes::c_char,
        token: *const ffi::ctypes::c_char,
        n: size_t,
    ) -> *mut ffi::ctypes::c_char;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ip4_addr {
    pub addr: u32_t,
}
pub type ip4_addr_t = ip4_addr;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ip4_addr2 {
    pub addrw: [u16_t; 2usize],
}
extern "C" {
    pub fn ip4_addr_isbroadcast_u32(addr: u32_t, netif: *const netif) -> u8_t;
}
extern "C" {
    pub fn ip4_addr_netmask_valid(netmask: u32_t) -> u8_t;
}
extern "C" {
    pub fn ipaddr_addr(cp: *const ffi::ctypes::c_char) -> u32_t;
}
extern "C" {
    pub fn ip4addr_aton(
        cp: *const ffi::ctypes::c_char,
        addr: *mut ip4_addr_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn ip4addr_ntoa(addr: *const ip4_addr_t) -> *mut ffi::ctypes::c_char;
}
extern "C" {
    pub fn ip4addr_ntoa_r(
        addr: *const ip4_addr_t,
        buf: *mut ffi::ctypes::c_char,
        buflen: ffi::ctypes::c_int,
    ) -> *mut ffi::ctypes::c_char;
}
pub const lwip_ip_addr_type_IPADDR_TYPE_V4: lwip_ip_addr_type = 0;
pub const lwip_ip_addr_type_IPADDR_TYPE_V6: lwip_ip_addr_type = 6;
pub const lwip_ip_addr_type_IPADDR_TYPE_ANY: lwip_ip_addr_type = 46;
pub type lwip_ip_addr_type = ffi::ctypes::c_uint;
pub type ip_addr_t = ip4_addr_t;
extern "C" {
    pub static ip_addr_any: ip_addr_t;
}
extern "C" {
    pub static ip_addr_broadcast: ip_addr_t;
}
pub const pbuf_layer_PBUF_TRANSPORT: pbuf_layer = 0;
pub const pbuf_layer_PBUF_IP: pbuf_layer = 1;
pub const pbuf_layer_PBUF_LINK: pbuf_layer = 2;
pub const pbuf_layer_PBUF_RAW_TX: pbuf_layer = 3;
pub const pbuf_layer_PBUF_RAW: pbuf_layer = 4;
pub type pbuf_layer = ffi::ctypes::c_uint;
pub const pbuf_type_PBUF_RAM: pbuf_type = 0;
pub const pbuf_type_PBUF_ROM: pbuf_type = 1;
pub const pbuf_type_PBUF_REF: pbuf_type = 2;
pub const pbuf_type_PBUF_POOL: pbuf_type = 3;
pub type pbuf_type = ffi::ctypes::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pbuf {
    pub next: *mut pbuf,
    pub payload: *mut ffi::ctypes::c_void,
    pub tot_len: u16_t,
    pub len: u16_t,
    pub type_: u8_t,
    pub flags: u8_t,
    pub ref_: u16_t,
}
impl Default for pbuf {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pbuf_rom {
    pub next: *mut pbuf,
    pub payload: *const ffi::ctypes::c_void,
}
impl Default for pbuf_rom {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type pbuf_free_custom_fn = ::core::option::Option<unsafe extern "C" fn(p: *mut pbuf)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pbuf_custom {
    pub pbuf: pbuf,
    pub custom_free_function: pbuf_free_custom_fn,
}
impl Default for pbuf_custom {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn pbuf_alloc(l: pbuf_layer, length: u16_t, type_: pbuf_type) -> *mut pbuf;
}
extern "C" {
    pub fn pbuf_alloced_custom(
        l: pbuf_layer,
        length: u16_t,
        type_: pbuf_type,
        p: *mut pbuf_custom,
        payload_mem: *mut ffi::ctypes::c_void,
        payload_mem_len: u16_t,
    ) -> *mut pbuf;
}
extern "C" {
    pub fn pbuf_realloc(p: *mut pbuf, size: u16_t);
}
extern "C" {
    pub fn pbuf_header(p: *mut pbuf, header_size: s16_t) -> u8_t;
}
extern "C" {
    pub fn pbuf_header_force(p: *mut pbuf, header_size: s16_t) -> u8_t;
}
extern "C" {
    pub fn pbuf_ref(p: *mut pbuf);
}
extern "C" {
    pub fn pbuf_free(p: *mut pbuf) -> u8_t;
}
extern "C" {
    pub fn pbuf_clen(p: *const pbuf) -> u16_t;
}
extern "C" {
    pub fn pbuf_cat(head: *mut pbuf, tail: *mut pbuf);
}
extern "C" {
    pub fn pbuf_chain(head: *mut pbuf, tail: *mut pbuf);
}
extern "C" {
    pub fn pbuf_dechain(p: *mut pbuf) -> *mut pbuf;
}
extern "C" {
    pub fn pbuf_copy(p_to: *mut pbuf, p_from: *const pbuf) -> err_t;
}
extern "C" {
    pub fn pbuf_copy_partial(
        p: *const pbuf,
        dataptr: *mut ffi::ctypes::c_void,
        len: u16_t,
        offset: u16_t,
    ) -> u16_t;
}
extern "C" {
    pub fn pbuf_take(buf: *mut pbuf, dataptr: *const ffi::ctypes::c_void, len: u16_t) -> err_t;
}
extern "C" {
    pub fn pbuf_take_at(
        buf: *mut pbuf,
        dataptr: *const ffi::ctypes::c_void,
        len: u16_t,
        offset: u16_t,
    ) -> err_t;
}
extern "C" {
    pub fn pbuf_skip(in_: *mut pbuf, in_offset: u16_t, out_offset: *mut u16_t) -> *mut pbuf;
}
extern "C" {
    pub fn pbuf_coalesce(p: *mut pbuf, layer: pbuf_layer) -> *mut pbuf;
}
extern "C" {
    pub fn pbuf_get_at(p: *const pbuf, offset: u16_t) -> u8_t;
}
extern "C" {
    pub fn pbuf_try_get_at(p: *const pbuf, offset: u16_t) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn pbuf_put_at(p: *mut pbuf, offset: u16_t, data: u8_t);
}
extern "C" {
    pub fn pbuf_memcmp(
        p: *const pbuf,
        offset: u16_t,
        s2: *const ffi::ctypes::c_void,
        n: u16_t,
    ) -> u16_t;
}
extern "C" {
    pub fn pbuf_memfind(
        p: *const pbuf,
        mem: *const ffi::ctypes::c_void,
        mem_len: u16_t,
        start_offset: u16_t,
    ) -> u16_t;
}
extern "C" {
    pub fn pbuf_strstr(p: *const pbuf, substr: *const ffi::ctypes::c_char) -> u16_t;
}
pub type mem_size_t = u16_t;
extern "C" {
    pub fn mem_init();
}
extern "C" {
    pub fn mem_trim(mem: *mut ffi::ctypes::c_void, size: mem_size_t) -> *mut ffi::ctypes::c_void;
}
extern "C" {
    pub fn mem_malloc(size: mem_size_t) -> *mut ffi::ctypes::c_void;
}
extern "C" {
    pub fn mem_calloc(count: mem_size_t, size: mem_size_t) -> *mut ffi::ctypes::c_void;
}
extern "C" {
    pub fn mem_free(mem: *mut ffi::ctypes::c_void);
}
pub const memp_t_MEMP_RAW_PCB: memp_t = 0;
pub const memp_t_MEMP_UDP_PCB: memp_t = 1;
pub const memp_t_MEMP_TCP_PCB: memp_t = 2;
pub const memp_t_MEMP_TCP_PCB_LISTEN: memp_t = 3;
pub const memp_t_MEMP_TCP_SEG: memp_t = 4;
pub const memp_t_MEMP_REASSDATA: memp_t = 5;
pub const memp_t_MEMP_FRAG_PBUF: memp_t = 6;
pub const memp_t_MEMP_NETBUF: memp_t = 7;
pub const memp_t_MEMP_NETCONN: memp_t = 8;
pub const memp_t_MEMP_TCPIP_MSG_API: memp_t = 9;
pub const memp_t_MEMP_TCPIP_MSG_INPKT: memp_t = 10;
pub const memp_t_MEMP_IGMP_GROUP: memp_t = 11;
pub const memp_t_MEMP_SYS_TIMEOUT: memp_t = 12;
pub const memp_t_MEMP_NETDB: memp_t = 13;
pub const memp_t_MEMP_PBUF: memp_t = 14;
pub const memp_t_MEMP_PBUF_POOL: memp_t = 15;
pub const memp_t_MEMP_MAX: memp_t = 16;
pub type memp_t = ffi::ctypes::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct memp {
    pub next: *mut memp,
}
impl Default for memp {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct memp_desc {
    pub size: u16_t,
    pub num: u16_t,
    pub base: *mut u8_t,
    pub tab: *mut *mut memp,
}
impl Default for memp_desc {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn memp_init_pool(desc: *const memp_desc);
}
extern "C" {
    pub fn memp_malloc_pool(desc: *const memp_desc) -> *mut ffi::ctypes::c_void;
}
extern "C" {
    pub fn memp_free_pool(desc: *const memp_desc, mem: *mut ffi::ctypes::c_void);
}
extern "C" {
    pub static memp_pools: [*const memp_desc; 16usize];
}
extern "C" {
    pub fn memp_init();
}
extern "C" {
    pub fn memp_malloc(type_: memp_t) -> *mut ffi::ctypes::c_void;
}
extern "C" {
    pub fn memp_free(type_: memp_t, mem: *mut ffi::ctypes::c_void);
}
pub const lwip_internal_netif_client_data_index_LWIP_NETIF_CLIENT_DATA_INDEX_DHCP:
    lwip_internal_netif_client_data_index = 0;
pub const lwip_internal_netif_client_data_index_LWIP_NETIF_CLIENT_DATA_INDEX_AUTOIP:
    lwip_internal_netif_client_data_index = 1;
pub const lwip_internal_netif_client_data_index_LWIP_NETIF_CLIENT_DATA_INDEX_IGMP:
    lwip_internal_netif_client_data_index = 2;
pub const lwip_internal_netif_client_data_index_LWIP_NETIF_CLIENT_DATA_INDEX_MAX:
    lwip_internal_netif_client_data_index = 3;
pub type lwip_internal_netif_client_data_index = ffi::ctypes::c_uint;
pub const netif_mac_filter_action_NETIF_DEL_MAC_FILTER: netif_mac_filter_action = 0;
pub const netif_mac_filter_action_NETIF_ADD_MAC_FILTER: netif_mac_filter_action = 1;
pub type netif_mac_filter_action = ffi::ctypes::c_uint;
pub type netif_init_fn = ::core::option::Option<unsafe extern "C" fn(netif: *mut netif) -> err_t>;
pub type netif_input_fn =
    ::core::option::Option<unsafe extern "C" fn(p: *mut pbuf, inp: *mut netif) -> err_t>;
pub type netif_output_fn = ::core::option::Option<
    unsafe extern "C" fn(netif: *mut netif, p: *mut pbuf, ipaddr: *const ip4_addr_t) -> err_t,
>;
pub type netif_linkoutput_fn =
    ::core::option::Option<unsafe extern "C" fn(netif: *mut netif, p: *mut pbuf) -> err_t>;
pub type netif_status_callback_fn = ::core::option::Option<unsafe extern "C" fn(netif: *mut netif)>;
pub type netif_igmp_mac_filter_fn = ::core::option::Option<
    unsafe extern "C" fn(
        netif: *mut netif,
        group: *const ip4_addr_t,
        action: netif_mac_filter_action,
    ) -> err_t,
>;
extern "C" {
    pub fn netif_alloc_client_data_id() -> u8_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netif {
    pub next: *mut netif,
    pub ip4_addr: ip_addr_t,
    pub netmask: ip_addr_t,
    pub gw: ip_addr_t,
    pub input: netif_input_fn,
    pub output: netif_output_fn,
    pub linkoutput: netif_linkoutput_fn,
    pub state: *mut ffi::ctypes::c_void,
    pub client_data: [*mut ffi::ctypes::c_void; 3usize],
    pub rs_count: u8_t,
    pub mtu: u16_t,
    pub hwaddr_len: u8_t,
    pub hwaddr: [u8_t; 6usize],
    pub flags: u8_t,
    pub name: [ffi::ctypes::c_char; 2usize],
    pub num: u8_t,
    pub igmp_mac_filter: netif_igmp_mac_filter_fn,
}
impl Default for netif {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static mut netif_list: *mut netif;
}
extern "C" {
    pub static mut netif_default: *mut netif;
}
extern "C" {
    pub fn netif_init();
}
extern "C" {
    pub fn netif_add(
        netif: *mut netif,
        ipaddr: *const ip4_addr_t,
        netmask: *const ip4_addr_t,
        gw: *const ip4_addr_t,
        state: *mut ffi::ctypes::c_void,
        init: netif_init_fn,
        input: netif_input_fn,
    ) -> *mut netif;
}
extern "C" {
    pub fn netif_set_addr(
        netif: *mut netif,
        ipaddr: *const ip4_addr_t,
        netmask: *const ip4_addr_t,
        gw: *const ip4_addr_t,
    );
}
extern "C" {
    pub fn netif_remove(netif: *mut netif);
}
extern "C" {
    pub fn netif_find(name: *const ffi::ctypes::c_char) -> *mut netif;
}
extern "C" {
    pub fn netif_set_default(netif: *mut netif);
}
extern "C" {
    pub fn netif_set_ipaddr(netif: *mut netif, ipaddr: *const ip4_addr_t);
}
extern "C" {
    pub fn netif_set_netmask(netif: *mut netif, netmask: *const ip4_addr_t);
}
extern "C" {
    pub fn netif_set_gw(netif: *mut netif, gw: *const ip4_addr_t);
}
extern "C" {
    pub fn netif_set_up(netif: *mut netif);
}
extern "C" {
    pub fn netif_set_down(netif: *mut netif);
}
extern "C" {
    pub fn netif_set_link_up(netif: *mut netif);
}
extern "C" {
    pub fn netif_set_link_down(netif: *mut netif);
}
extern "C" {
    pub fn netif_input(p: *mut pbuf, inp: *mut netif) -> err_t;
}
pub type tcpip_init_done_fn =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut ffi::ctypes::c_void)>;
pub type tcpip_callback_fn =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut ffi::ctypes::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcpip_callback_msg {
    _unused: [u8; 0],
}
extern "C" {
    pub fn tcpip_init(tcpip_init_done: tcpip_init_done_fn, arg: *mut ffi::ctypes::c_void);
}
extern "C" {
    pub fn tcpip_inpkt(p: *mut pbuf, inp: *mut netif, input_fn: netif_input_fn) -> err_t;
}
extern "C" {
    pub fn tcpip_input(p: *mut pbuf, inp: *mut netif) -> err_t;
}
extern "C" {
    pub fn tcpip_callback_with_block(
        function: tcpip_callback_fn,
        ctx: *mut ffi::ctypes::c_void,
        block: u8_t,
    ) -> err_t;
}
extern "C" {
    pub fn tcpip_callbackmsg_new(
        function: tcpip_callback_fn,
        ctx: *mut ffi::ctypes::c_void,
    ) -> *mut tcpip_callback_msg;
}
extern "C" {
    pub fn tcpip_callbackmsg_delete(msg: *mut tcpip_callback_msg);
}
extern "C" {
    pub fn tcpip_trycallback(msg: *mut tcpip_callback_msg) -> err_t;
}
extern "C" {
    pub fn pbuf_free_callback(p: *mut pbuf) -> err_t;
}
extern "C" {
    pub fn mem_free_callback(m: *mut ffi::ctypes::c_void) -> err_t;
}
extern "C" {
    pub fn tcpip_timeout(
        msecs: u32_t,
        h: sys_timeout_handler,
        arg: *mut ffi::ctypes::c_void,
    ) -> err_t;
}
extern "C" {
    pub fn tcpip_untimeout(h: sys_timeout_handler, arg: *mut ffi::ctypes::c_void) -> err_t;
}
pub const DHCP_State_TypeDef_DHCP_START: DHCP_State_TypeDef = 0;
pub const DHCP_State_TypeDef_DHCP_WAIT_ADDRESS: DHCP_State_TypeDef = 1;
pub const DHCP_State_TypeDef_DHCP_ADDRESS_ASSIGNED: DHCP_State_TypeDef = 2;
pub const DHCP_State_TypeDef_DHCP_RELEASE_IP: DHCP_State_TypeDef = 3;
pub const DHCP_State_TypeDef_DHCP_STOP: DHCP_State_TypeDef = 4;
pub const DHCP_State_TypeDef_DHCP_TIMEOUT: DHCP_State_TypeDef = 5;
pub type DHCP_State_TypeDef = ffi::ctypes::c_uint;
extern "C" {
    pub fn wifi_rx_beacon_hdl(
        buf: *mut ffi::ctypes::c_char,
        buf_len: ffi::ctypes::c_int,
        flags: ffi::ctypes::c_int,
        userdata: *mut ffi::ctypes::c_void,
    );
}
extern "C" {
    pub fn rtw_wakelock_timeout(timeoutms: u32);
}
extern "C" {
    pub fn dhcp_release_unicast(netif: *mut netif) -> err_t;
}
extern "C" {
    pub fn LwIP_Init();
}
extern "C" {
    pub fn LwIP_ReleaseIP(idx: u8);
}
extern "C" {
    pub fn LwIP_DHCP(idx: u8, dhcp_state: u8) -> u8;
}
extern "C" {
    pub fn LwIP_GetMAC(pnetif: *mut netif) -> *mut ffi::ctypes::c_uchar;
}
extern "C" {
    pub fn LwIP_GetMAC_Idx(idx: u8) -> *mut u8;
}
extern "C" {
    pub fn LwIP_GetIP(pnetif: *mut netif) -> *mut ffi::ctypes::c_uchar;
}
extern "C" {
    pub fn LwIP_GetIP_Idx(idx: u8) -> *mut ffi::ctypes::c_uchar;
}
extern "C" {
    pub fn LwIP_GetGW(pnetif: *mut netif) -> *mut ffi::ctypes::c_uchar;
}
extern "C" {
    pub fn LwIP_GetGW_Idx(idx: u8) -> *mut ffi::ctypes::c_uchar;
}
extern "C" {
    pub fn LwIP_GetMASK(pnetif: *mut netif) -> *mut u8;
}
extern "C" {
    pub fn LwIP_GetMASK_Idx(idx: u8) -> *mut u8;
}
extern "C" {
    pub fn LwIP_wlan_set_netif_info(
        idx_wlan: ffi::ctypes::c_int,
        dev: *mut ffi::ctypes::c_void,
        dev_addr: *mut ffi::ctypes::c_uchar,
    );
}
extern "C" {
    pub fn LwIP_ethernetif_recv(idx: u8, total_len: ffi::ctypes::c_int);
}
extern "C" {
    pub fn LwIP_netif_is_valid_IP(
        idx: ffi::ctypes::c_int,
        ip_dest: *mut ffi::ctypes::c_uchar,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn LwIP_GetBC(pnetif: *mut netif) -> *mut u8;
}
extern "C" {
    pub fn LwIP_GetDNS(dns: *mut ip4_addr);
}
extern "C" {
    pub fn LwIP_SetDNS(dns: *mut ip4_addr);
}
extern "C" {
    pub fn LwIP_UseStaticIP(pnetif: *mut netif);
}
extern "C" {
    pub fn LwIP_AUTOIP(pnetif: *mut netif);
}
extern "C" {
    pub fn LWIP_Get_Dynamic_Sleep_Interval() -> u32;
}
extern "C" {
    pub fn netif_get_idx(pnetif: *mut netif) -> ffi::ctypes::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub un: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub u32_addr: [u32_t; 4usize],
    pub u8_addr: [u8_t; 16usize],
    _bindgen_union_align: [u32; 4usize],
}
impl Default for in6_addr__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for in6_addr__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "in6_addr__bindgen_ty_1 {{ union }}")
    }
}
impl Default for in6_addr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for in6_addr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "in6_addr {{ un: {:?} }}", self.un)
    }
}
extern "C" {
    pub static in6addr_any: in6_addr;
}
extern "C" {
    pub static mut errno: ffi::ctypes::c_int;
}
pub type sa_family_t = u8_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sockaddr_in {
    pub sin_len: u8_t,
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [ffi::ctypes::c_char; 8usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sockaddr {
    pub sa_len: u8_t,
    pub sa_family: sa_family_t,
    pub sa_data: [ffi::ctypes::c_char; 14usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sockaddr_storage {
    pub s2_len: u8_t,
    pub ss_family: sa_family_t,
    pub s2_data1: [ffi::ctypes::c_char; 2usize],
    pub s2_data2: [u32_t; 3usize],
}
pub type socklen_t = u32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lwip_sock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lwip_setgetsockopt_data {
    pub s: ffi::ctypes::c_int,
    pub level: ffi::ctypes::c_int,
    pub optname: ffi::ctypes::c_int,
    pub optval: lwip_setgetsockopt_data__bindgen_ty_1,
    pub optlen: socklen_t,
    pub err: err_t,
    pub completed_sem: *mut ffi::ctypes::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lwip_setgetsockopt_data__bindgen_ty_1 {
    pub p: *mut ffi::ctypes::c_void,
    pub pc: *const ffi::ctypes::c_void,
    _bindgen_union_align: u64,
}
impl Default for lwip_setgetsockopt_data__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for lwip_setgetsockopt_data__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "lwip_setgetsockopt_data__bindgen_ty_1 {{ union }}")
    }
}
impl Default for lwip_setgetsockopt_data {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ::core::fmt::Debug for lwip_setgetsockopt_data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "lwip_setgetsockopt_data {{ s: {:?}, level: {:?}, optname: {:?}, optval: {:?}, optlen: {:?}, err: {:?}, completed_sem: {:?} }}" , self . s , self . level , self . optname , self . optval , self . optlen , self . err , self . completed_sem)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ffi::ctypes::c_void,
    pub iov_len: size_t,
}
impl Default for iovec {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msghdr {
    pub msg_name: *mut ffi::ctypes::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: ffi::ctypes::c_int,
    pub msg_control: *mut ffi::ctypes::c_void,
    pub msg_controllen: socklen_t,
    pub msg_flags: ffi::ctypes::c_int,
}
impl Default for msghdr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct linger {
    pub l_onoff: ffi::ctypes::c_int,
    pub l_linger: ffi::ctypes::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
extern "C" {
    pub fn lwip_socket_thread_init();
}
extern "C" {
    pub fn lwip_socket_thread_cleanup();
}
extern "C" {
    pub fn lwip_accept(
        s: ffi::ctypes::c_int,
        addr: *mut sockaddr,
        addrlen: *mut socklen_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn lwip_bind(
        s: ffi::ctypes::c_int,
        name: *const sockaddr,
        namelen: socklen_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn lwip_shutdown(s: ffi::ctypes::c_int, how: ffi::ctypes::c_int) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn lwip_getpeername(
        s: ffi::ctypes::c_int,
        name: *mut sockaddr,
        namelen: *mut socklen_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn lwip_getsockname(
        s: ffi::ctypes::c_int,
        name: *mut sockaddr,
        namelen: *mut socklen_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn lwip_getsockopt(
        s: ffi::ctypes::c_int,
        level: ffi::ctypes::c_int,
        optname: ffi::ctypes::c_int,
        optval: *mut ffi::ctypes::c_void,
        optlen: *mut socklen_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn lwip_setsockopt(
        s: ffi::ctypes::c_int,
        level: ffi::ctypes::c_int,
        optname: ffi::ctypes::c_int,
        optval: *const ffi::ctypes::c_void,
        optlen: socklen_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn lwip_getsocklasterr(s: ffi::ctypes::c_int) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn lwip_close(s: ffi::ctypes::c_int) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn lwip_connect(
        s: ffi::ctypes::c_int,
        name: *const sockaddr,
        namelen: socklen_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn lwip_listen(s: ffi::ctypes::c_int, backlog: ffi::ctypes::c_int) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn lwip_recv(
        s: ffi::ctypes::c_int,
        mem: *mut ffi::ctypes::c_void,
        len: size_t,
        flags: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn lwip_read(
        s: ffi::ctypes::c_int,
        mem: *mut ffi::ctypes::c_void,
        len: size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn lwip_recvfrom(
        s: ffi::ctypes::c_int,
        mem: *mut ffi::ctypes::c_void,
        len: size_t,
        flags: ffi::ctypes::c_int,
        from: *mut sockaddr,
        fromlen: *mut socklen_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn lwip_send(
        s: ffi::ctypes::c_int,
        dataptr: *const ffi::ctypes::c_void,
        size: size_t,
        flags: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn lwip_sendmsg(
        s: ffi::ctypes::c_int,
        message: *const msghdr,
        flags: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn lwip_sendto(
        s: ffi::ctypes::c_int,
        dataptr: *const ffi::ctypes::c_void,
        size: size_t,
        flags: ffi::ctypes::c_int,
        to: *const sockaddr,
        tolen: socklen_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn lwip_socket(
        domain: ffi::ctypes::c_int,
        type_: ffi::ctypes::c_int,
        protocol: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn lwip_write(
        s: ffi::ctypes::c_int,
        dataptr: *const ffi::ctypes::c_void,
        size: size_t,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn lwip_writev(
        s: ffi::ctypes::c_int,
        iov: *const iovec,
        iovcnt: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn lwip_select(
        maxfdp1: ffi::ctypes::c_int,
        readset: *mut _types_fd_set,
        writeset: *mut _types_fd_set,
        exceptset: *mut _types_fd_set,
        timeout: *mut timeval,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn lwip_ioctl(
        s: ffi::ctypes::c_int,
        cmd: ffi::ctypes::c_long,
        argp: *mut ffi::ctypes::c_void,
    ) -> ffi::ctypes::c_int;
}
extern "C" {
    pub fn lwip_fcntl(
        s: ffi::ctypes::c_int,
        cmd: ffi::ctypes::c_int,
        val: ffi::ctypes::c_int,
    ) -> ffi::ctypes::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ffi::ctypes::c_uint,
    pub fp_offset: ffi::ctypes::c_uint,
    pub overflow_arg_area: *mut ffi::ctypes::c_void,
    pub reg_save_area: *mut ffi::ctypes::c_void,
}
impl Default for __va_list_tag {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
